<!DOCTYPE html><html><head><meta charset="utf-8"><title>手把手教你Rx响应式开发 - 响应式应用开发极简入门教程 | Tech. Design. Life.</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="很多面向对象的开发人员都遇到过这样的问题：软件开发过程中，需要开发人员主动地告诉系统什么东西改变了，以此来触发响应。那有人就会想，如果有一个办法可以让系统自动发现状态的改变，是不是更好呢？这就引出了响应式开发最基本的概念……"><meta name="keywords" content="Programming,iOS,Swift,RxSwift,响应式,开发,入门"><meta property="og:type" content="article"><meta property="og:title" content="手把手教你Rx响应式开发 - 响应式应用开发极简入门教程"><meta property="og:url" content="http://blog.superyoung.win/2017/01/25/learning_Rx/Reactive-Programming/index.html"><meta property="og:site_name" content="Tech. Design. Life."><meta property="og:description" content="很多面向对象的开发人员都遇到过这样的问题：软件开发过程中，需要开发人员主动地告诉系统什么东西改变了，以此来触发响应。那有人就会想，如果有一个办法可以让系统自动发现状态的改变，是不是更好呢？这就引出了响应式开发最基本的概念……"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://blog.superyoung.win/images/Programming/rx_logo.png"><meta property="og:updated_time" content="2018-02-12T04:35:43.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="手把手教你Rx响应式开发 - 响应式应用开发极简入门教程"><meta name="twitter:description" content="很多面向对象的开发人员都遇到过这样的问题：软件开发过程中，需要开发人员主动地告诉系统什么东西改变了，以此来触发响应。那有人就会想，如果有一个办法可以让系统自动发现状态的改变，是不是更好呢？这就引出了响应式开发最基本的概念……"><meta name="twitter:image" content="http://blog.superyoung.win/images/Programming/rx_logo.png"><link rel="alternate" href="/atom.xml" title="Tech. Design. Life." type="application/atom+xml"><link rel="icon" href="/favicon.png"><link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/css/style.css"></head></html><body><div id="container"><div id="wrap"><header id="header"><div id="banner"></div><div id="header-outer" class="outer"><div id="header-title" class="inner"><h1 id="logo-wrap"><a href="/" id="logo">Tech. Design. Life.</a></h1></div><div id="header-inner" class="inner"><nav id="main-nav"><a id="main-nav-toggle" class="nav-icon"></a> <a class="main-nav-link" href="/">首页</a> <a class="main-nav-link" href="/archives">归档</a></nav><nav id="sub-nav"><a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a> <a id="nav-search-btn" class="nav-icon" title="搜索"></a></nav><div id="search-form-wrap"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.superyoung.win"></form></div></div></div></header><div class="outer"><section id="main"><article id="post-learning_Rx/Reactive-Programming" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2017/01/25/learning_Rx/Reactive-Programming/" class="article-date"><time datetime="2017-01-25T07:47:23.000Z" itemprop="datePublished">2017-01-25</time></a></div><div class="article-inner"><header class="article-header"><h1 class="article-title" itemprop="name">手把手教你Rx响应式开发 - 响应式应用开发极简入门教程</h1></header><div class="article-entry" itemprop="articleBody"><p>很多面向对象的开发人员都遇到过这样的问题：软件开发过程中，需要开发人员主动地告诉系统什么东西改变了，以此来触发响应。</p><p>那有人就会想，如果有一个办法可以让系统自动发现状态的改变，是不是更好呢？</p><p>这就引出了响应式开发最基本的概念……<br><a id="more"></a></p><p><em>原文在此：<a href="https://www.raywenderlich.com/138547/getting-started-with-rxswift-and-rxcocoa" target="_blank" rel="noopener">Getting Started With RxSwift and RxCocoa by Ellen Shapiro on October 17, 2016</a></em></p><p><img src="/images/Programming/rx_logo.png" alt="ReactiveX Logo"></p><h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><p>很多面向对象的开发人员都遇到过这样的问题：软件开发过程中，需要开发人员主动地告诉系统什么东西改变了，以此来触发响应。</p><p>那有人就会想，如果有一个办法可以让系统自动发现状态的改变，是不是更好呢？</p><p>这就引出了响应式开发最基本的概念：你的应用可以对状态直接进行响应而不需要开发人员参与。这种开发方式可以让开发人员更加专注于逻辑的表达而不是如何对状态进行保存。</p><p>在 iOS 中可以使用 Objc 和 Swift 的 KVO 和 didSet 等方法，但是有时候啊这些方法可能就显得太笨重了，Objc 和 Swift 均有不同的响应式框架来解决这个问题。这里主要介绍的是 swift 的 RxSwift 框架。</p><p><a href="https://www.raywenderlich.com/126522/reactivecocoa-vs-rxswift" target="_blank" rel="noopener">如果你想知道更多的背景信息，关于各大主流框架的区别， <em>Rui Peres</em> 写了一篇文章</a></p><h2 id="0x01-什么是-RxSwift-和-RxCocoa"><a href="#0x01-什么是-RxSwift-和-RxCocoa" class="headerlink" title="0x01 什么是 RxSwift 和 RxCocoa"></a>0x01 什么是 RxSwift 和 RxCocoa</h2><p>ReactiveX 是一个支持很多编程语言和平台语言工具库 项目。而 RxSwift 和 RxCocoa 是 ReactiveX 套装的一部分。</p><p>RxSwift 是一个和 Swift 语言进行交互的框架，而 RxCocoa 则使得 Cocoa 的 APIs 更容易被 Reactive 技术调用。</p><p>RxSwift 和 RxCocoa 可以通过 pod 来安装，具体方法自行查看其 github 项目主页。</p><h2 id="0x02-基本概念：Observable被观察者-和-Observer-观察者"><a href="#0x02-基本概念：Observable被观察者-和-Observer-观察者" class="headerlink" title="0x02 基本概念：Observable被观察者 和 Observer 观察者"></a>0x02 基本概念：<code>Observable</code><em>被观察者</em> 和 <code>Observer</code> <em>观察者</em></h2><p>我曾经被这些概念混淆了很久，在不同的文章中有不同的称呼，特别是在中文博客中，什么“流”与“信号”齐飞，却少有人按照英文字面的翻译<br>Observable =&gt; 被观察者，Observer =&gt; 观察者，在这篇文章中我将使用这个字面翻译，原因等你看完文章会体会到的。</p><p>其实，这个英文名字起的很有意思，Observable 是一个形容词，其实将形容词作为一个类名非常贴切，其在牛津词典中的解释是：<em>Able to be noticed or perceived</em>，而 Observer 是一个名词，在牛津词典中的解释是：<em>A person who watches or notices something</em>。</p><p>而这两个词在 Rx 中的含义是：</p><ul><li>一个<code>被观察者</code>是一个能够提交通知的东西。</li><li>一个<code>观察者</code>可以订阅一个<code>被观察者</code>对象，可以接收对象改变的通知，同时进行一些自定义操作。</li></ul><h2 id="0x03-基本概念：DisposeBag-销毁包"><a href="#0x03-基本概念：DisposeBag-销毁包" class="headerlink" title="0x03 基本概念：DisposeBag 销毁包"></a>0x03 基本概念：<code>DisposeBag</code> <em>销毁包</em></h2><p>是 RxSwift 和 RxCocoa 的工具，用来帮助和 ARC 内存管理进行交互的工具。这是一个给<code>观察者</code>对象的虚拟的 “包”，当其父对象被 deallocate 后，观察者对象的内存也会被释放。</p><p>假设某个观察者对象的一个属性是 DisposeBag ，那么当它的 <code>deinit()</code> 方法被调用的时候，这个 “bag” 被清空，并且每个被销毁的观察者都自动的解除订阅，这就允许 ARC 系统去正常地回收内存了。</p><p>没有 <code>DisposeBag</code> 的话，将会有两种结果：</p><ol><li>要么观察者会创造保留环，造成内存泄漏</li><li>要么它会在对象的外面被释放掉，造成程序崩溃</li></ol><p>所以，一定要记得在设置观察者对象的时候增加 DisposeBag。</p><hr><h2 id="0x04-接下来举个例子：购买巧克力"><a href="#0x04-接下来举个例子：购买巧克力" class="headerlink" title="0x04 接下来举个例子：购买巧克力"></a>0x04 接下来举个例子：购买巧克力</h2><p><em>项目文件：<a href="https://github.com/shengyang998/Chocolates-starter" target="_blank" rel="noopener">传送门</a></em></p><p>Build 并且运行项目，现在这个 demo 还是没有使用响应式的，接下来的教程中，将会展示如何使用响应式来完成这个 demo。</p><h2 id="0x05-响应式操作购物车数量"><a href="#0x05-响应式操作购物车数量" class="headerlink" title="0x05 响应式操作购物车数量"></a>0x05 响应式操作购物车数量</h2><p>打开 <code>ShoppingCart.swift</code>，找到购物车内数组的声明<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> chocolates = [<span class="type">Chocolate</span>]()</div></pre></td></tr></table></figure><p></p><p>现在还不是响应式的，要想响应式，将其改成<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> chocolates: <span class="type">Variable</span>&lt;[<span class="type">Chocolate</span>]&gt; = <span class="type">Variable</span>([])</div></pre></td></tr></table></figure><p></p><p>上面语句的作用详述如下：</p><ol><li>你定义了一个 RxSwift 的 Variable，这个 Variable 是 Swift 数组类型的，数组用了 Chocolate 类型来定义。</li><li><code>Variable</code> 是一个类，所以它是引用类型。也就是 chocolates 是 Variable 的一个实例。</li><li><code>Variable</code> 有一个属性叫 <code>value</code>。这里是你的 Chocolate 数组存放的地方。</li><li><code>Variable</code> 的膜法来自于一个叫 <code>asObservable()</code> 的方法。你可以增加一个观察者来代替每次去手动 check the value。</li><li>另外以后访问那个数组的时候，都要通过 <code>value</code> 来访问了。</li></ol><p>修复 Xcode 当前提示的所有错误，然后继续下面的操作：</p><ol><li>在文件 <code>ChocolatesOfTheWorldViewController.swift</code> 中增加</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</div></pre></td></tr></table></figure><ol><li>在 // MARK: Rx Setup 下面增加</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupCartObserver</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="type">ShoppingCart</span>.sharedCart.chocolates.asObservable()</div><div class="line">    .subscribe(onNext:&#123;</div><div class="line">        (chocolates) <span class="keyword">in</span></div><div class="line">        <span class="keyword">self</span>.cartButton.title = <span class="string">"<span class="subst">\(chocolates.<span class="built_in">count</span>)</span> \u&#123;1f36b&#125;"</span></div><div class="line">        &#125;)</div><div class="line">    .addDisposableTo(disposeBag)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这将会设置一个响应式的观察者去自动更新购物车。</p><p>上面的代码具体做了什么？详述如下：</p><ol><li>首先，获取购物车的 chocolates as an Observable</li><li>每次 Observable 中的值更新后都会调用其观察者的 <code>subscribe(onNext:)</code> ，其中传入的参数就是被改变的值。</li><li>记得每次 subscribe 后都要 addDisposableTo。</li></ol><p>接下来，在 <code>viewDidLoad()</code> 方法中调用 <code>setupCartObserver()</code>，并且删除那个非私有的 <code>updateCartButton()</code> 方法，修复错误。</p><h2 id="0x06-响应式操作-TableView"><a href="#0x06-响应式操作-TableView" class="headerlink" title="0x06 响应式操作 TableView"></a>0x06 响应式操作 TableView</h2><p>现在你已经让购物车响应式了，接下来你将会看到如何使用 RxCocoa 来让 UITableView 响应式。</p><p>RxCocoa 包含一些 UI 控件的响应式的 API，这使得你可以控制像 UITableView 等控件而不需要 override 代理和数据源方法</p><p>为了演示怎么做，删除整个 UITableViewDataSource 和 UITableViewDelegate 扩展，然后删除 viewDidLoad 方法里注册 dataSource 和 delegate 的语句。</p><p>编译并且运行一下，你将会发现整个 TableView 都空了，那么好，接下来你需要使 TableView 中的一些东西响应化，首先，在文件 <code>ChocolatesOfTheWorldViewController.swift</code> 中，把属性<code>europeanChocolates</code>改成一个被观察者：<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> europeanChocolates = <span class="type">Observable</span>.just(<span class="type">Chocolate</span>.ofEurope)</div></pre></td></tr></table></figure><p></p><p><code>被观察者的值</code>不会有任何改变，但是当你仍然想要像一个被观察者的值一样访问它的时候，使用<code>just(_:)</code>方法。<br><em>注意，使用 <code>just(_:)</code> 方法常常代表了你过度地使用了Reactive Programming。假设一个值永远不会变，你为什么要使用一个设计用来 react 的编程技巧呢？在这个例子中，你使用 Rx 来设定 TableViewCell 如何改变。但是最好你能够时时注意你是怎么使用 Rx 技术。不要因为你有个锤子就把所有困难看成钉子。;)</em></p><p>现在你已经让 europeanChocolates 变成被观察者了，那么接下来增加下面的函数：<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupCellConfig</span><span class="params">()</span></span>&#123;</div><div class="line">    europeanChocolates.bindTo(tableView</div><div class="line">        .rx.items(cellIdentifier: <span class="type">ChocolateCell</span>.<span class="type">Identifier</span>, cellType: <span class="type">ChocolateCell</span>.<span class="keyword">self</span>))&#123;</div><div class="line">            (row, chocolate, cell) <span class="keyword">in</span></div><div class="line">            cell.configureWithChocolate(chocolate: chocolate)</div><div class="line">        &#125;.addDisposableTo(disposeBag)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>猜猜看这里做了什么？其实这里做的事是：</p><ol><li>在这里，你调用了<code>bindTo(_:)</code>去关联被观察者 europeanChocolates，上面的代码应该每行都调用一次</li><li>通过 <code>rx.</code> 可以访问 RxCocoa 对于 UI 控件的扩展，在这里是 UITableView</li><li>调用 Rx 方法，<code>items(cellIdentifier: cellType:)</code>，传入 cell identifier 和 cell 的类型。这将允许 Rx 调用离队方法（dequeuing method）</li><li>也可以传入一个 block ，每一个新 item 都会执行这个 block。你会获得关于这一行的返回信息，和 cell，这使得它配置 cell 超级简单。</li><li>加入 disposeBag</li></ol><p>通常情况下经过<code>tableView(_:numberOfRowsInSection:)</code>和<code>numberOfSection(in:)</code>计算的值现在自动根据被观察的值来自动计算。而<code>tableView(_: cellForRowAt:)</code>代理方法已经被闭包代替。</p><p>现在，去<code>viewDidLoad()</code>方法中添加下面这行代码，调用你的新设置方法：<br><code>setupCellConfig()</code></p><p>现在，如果你点击 tableView 的任何一行，都不会有反应。因为当你删除<code>tableView(_: didSelectRowAt:)</code>的时候，tableView 已经不能识别点击动作了。</p><p>为了解决点击问题，RxCocoa 有一个<code>modelSelected(_:)</code>方法，这个方法会返回一个 Observable，你可以使用它去观察关于被选择对象的信息。增加如下方法：<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupCellTapHandling</span><span class="params">()</span></span>&#123;</div><div class="line">    tableView.rx.modelSelected(<span class="type">Chocolate</span>.<span class="keyword">self</span>) <span class="comment">//1</span></div><div class="line">    .subscribe(onNext:&#123; <span class="comment">//2</span></div><div class="line">        chocolate <span class="keyword">in</span></div><div class="line">        <span class="type">ShoppingCart</span>.sharedCart.chocolates.value.append(chocolate)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> selectedRowIndexPath = <span class="keyword">self</span>.tableView.indexPathForSelectedRow&#123;</div><div class="line">            <span class="keyword">self</span>.tableView.deselectRow(at: selectedRowIndexPath, animated:<span class="literal">true</span>)</div><div class="line">        &#125; <span class="comment">//3</span></div><div class="line">        &#125;).addDisposableTo(disposeBag) <span class="comment">//4</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>一步一步来解释：</p><ol><li>给 table view 的扩展方法<code>modelSelected(_:)</code>传入一个<code>Chocolate model</code>来获取返回值的正确类型。这个方法返回一个 Observable。</li><li>获取那个 Observable，调用<code>subscribe(onNext:)</code>方法，传入一个尾随闭包，这个闭包将会在每次 model 被选中的时候执行。</li><li>当<code>self.tableView.indexPathForSelectedRow</code>有值的时候，也就是被选中的时候，取消选择它。</li><li>记得加入 DisposeBag</li></ol><p>最后记得在 viewDidLoad 中加入对上面函数的调用。</p><h2 id="0x07-文本响应式输入"><a href="#0x07-文本响应式输入" class="headerlink" title="0x07 文本响应式输入"></a>0x07 文本响应式输入</h2><p>在一般应用中，文字输入的处理一般都交给<code>UITextFieldDelegate</code>来做，通常其方法里会包含很多的 if/else 来决定哪个操作和逻辑应该被执行。Reactive 则不同。体会一下：</p><p>在<code>BillingInfoViewController.swift</code>中增加 DisposeBag<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</div></pre></td></tr></table></figure><p></p><p>下面的代码展示了如何根据用户的输入展示信用卡的图标：<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupCardImageDisplay</span><span class="params">()</span></span>&#123;</div><div class="line">    cardType.asObservable()</div><div class="line">    .subscribe(onNext:&#123;</div><div class="line">        cardType <span class="keyword">in</span></div><div class="line">        <span class="keyword">self</span>.careditCardImageView.image = cardType.image</div><div class="line">        &#125;).addDisposableTo(disposeBag)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>接下来处理一些有趣的事，如果用户打字很快，你可能不想立即处理输入的字符，否则可能会导致应用执行缓慢。解决办法很简单，使用<code>throttle</code>，按照间隔时间来执行逻辑而不是每次改变都执行。</p><p>废话不多说，直接上代码：</p><p>首先，在<code>BillingInfoViewController</code>中增加如下代码：<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">let</span> throttleInterVal = <span class="number">0.1</span></div></pre></td></tr></table></figure><p></p><p>这里以秒为单位定义了 throttle length 的常数。</p><p>然后再增加如下代码：<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupTextChangeHandling</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">let</span> creditCardValid = creditCardNumberTextField</div><div class="line">    .rx.text.throttle(throttleInterVal, scheduler: <span class="type">MainScheduler</span>.instance) <span class="comment">//1</span></div><div class="line">    .<span class="built_in">map</span>&#123; <span class="keyword">self</span>.validate(cardText: $<span class="number">0</span>) &#125; <span class="comment">//2</span></div><div class="line"></div><div class="line">    creditCardValid.subscribe(onNext:&#123;</div><div class="line">        <span class="keyword">self</span>.creditCardNumberTextField.valid = $<span class="number">0</span> <span class="comment">//3</span></div><div class="line">        &#125;).addDisposableTo(disposeBag) <span class="comment">//4</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p><strong>Note:如果你在设置 creditCardValid 的时候得到一个“<em>Generic parameter R could not be inferred</em>”错误，你可以显式地指明 creditCardValid 的类型：<code>let creditCardValid: Observable</code>。理论上编译器应该能够自动推断出这个类型，但是有时候它可能 need some push 🙂</strong></p><p>好，那么这些代码做了什么呢？我们继续一步步分析：</p><ol><li>你对输入进行了 <code>throttle</code> 操作，所以验证逻辑只会根据你在上面设置的时间来执行。<code>scheduler</code>参数是一个更高级的概念，简单来说它是用来绑定一个线程的，如果你要使用主线程的话，则设置为<code>MainScheduler</code>（UI 操作都需要主线程）</li><li>通过调用<code>validate(cardText)</code>来把 throttle 输入流 map 成一个 Boolean 类型的流。</li><li>获取并且订阅 creditCardValid ，基于输入来改变 text field 的验证状态。</li><li>加入 DisposeBag ，不费话了</li></ol><p>接下来响应式操作 Expiration date 和 CVV Code在<code>setupTextChangeHandling()</code>底部继续增加如下代码：<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> expirationValid = expirationDateTextField</div><div class="line">.rx.text.throttle(throttleInterval, scheduler: <span class="type">MainScheduler</span>.instance)</div><div class="line">  .<span class="built_in">map</span> &#123; <span class="keyword">self</span>.validate(expirationDateText: $<span class="number">0</span>) &#125;</div><div class="line"></div><div class="line">expirationValid.subscribe(onNext: &#123;</div><div class="line">    <span class="keyword">self</span>.expirationDateTextField.valid = $<span class="number">0</span></div><div class="line">    &#125;).addDisposableTo(disposeBag)</div><div class="line"></div><div class="line"><span class="keyword">let</span> cvvValid = cvvTextField</div><div class="line">  .rx.text.<span class="built_in">map</span> &#123; <span class="keyword">self</span>.validate(cvvText: $<span class="number">0</span>) &#125;</div><div class="line"></div><div class="line">cvvValid</div><div class="line">  .subscribe(onNext: &#123; <span class="keyword">self</span>.cvvTextField.valid = $<span class="number">0</span> &#125;)</div><div class="line">  .addDisposableTo(disposeBag)</div></pre></td></tr></table></figure><p></p><p>现在，你获取了三个文本框的所有被观察者的值，那么增加下面的代码：<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> everythingValid = <span class="type">Observable</span></div><div class="line">    .combineLatest(creditCardValid, expirationValid, cvvValid)&#123;</div><div class="line">    $<span class="number">0</span> &amp;&amp; $<span class="number">1</span> &amp;&amp; $<span class="number">2</span> <span class="comment">//all must be true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">everythingValid.bindTo(purchaseButton.rx.enable)</div><div class="line">    .addDisposableTo(disposeBag)</div></pre></td></tr></table></figure><p></p><p>这里用到了 Observable 的类方法：<code>combineLatest()</code>，好好体会一下。</p><p><code>everythingValid</code>然后和 UIButton 在 rx 扩展内的<code>enabled</code>属性绑定了，所以按钮的状态被 <code>everythingValid</code> 的值来控制。如果所有三个文本域都为真，按钮才能被按下</p><p>好的，现在你已经写好设置方法了，在<code>viewDidLoad()</code>中调用它吧：<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">setupCardImageDisplay()</div><div class="line">setupTextChangeHandling()</div></pre></td></tr></table></figure><p></p><p>接下来运行一下看看效果，好好体会，如果有什么问题，尽管提交 issue。</p><h2 id="0x08-尾声"><a href="#0x08-尾声" class="headerlink" title="0x08 尾声"></a>0x08 尾声</h2><p>如果你想多尝试一下，试试看：</p><ol><li>让 <code>CartViewController</code> 使用一个响应式的 TableView 来展示购物车的数据，而不是一个 Label。</li><li>允许用户直接在购物车页面增加或者移除巧克力，自动更新总价。</li></ol><p>好了，这只是一个开始，如果你想了解更多关于响应式编程的内容的话，下面的内容你绝对不会错过：</p><ol><li><a href="http://slack.rxswift.org/" target="_blank" rel="noopener">RxSwift Slack</a></li><li><a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md" target="_blank" rel="noopener">RxSwift’s Getting Started guide</a></li><li><a href="https://realm.io/news/slug-max-alexander-functional-reactive-rxswift/" target="_blank" rel="noopener">Max Alexander’s talk on Rx at Realm</a></li><li><a href="http://rx-marin.com" target="_blank" rel="noopener">rx-marin</a></li></ol></div><footer class="article-footer"><a data-url="http://blog.superyoung.win/2017/01/25/learning_Rx/Reactive-Programming/" data-id="cjctwd6b5000b39fye309m398" class="article-share-link">Share</a> <a href="http://blog.superyoung.win/2017/01/25/learning_Rx/Reactive-Programming/#disqus_thread" class="article-comment-link">留言</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Programming/">Programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RxSwift/">RxSwift</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/入门/">入门</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/响应式/">响应式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul></footer></div><nav id="article-nav"><a href="/2017/01/25/learning_iOS/SequenceType/" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">Newer</strong><div class="article-nav-title">关于 SequenceType</div></a><a href="/2017/01/15/learning_iOS/debugPrint/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">Debug Print in iOS Programming</div></a></nav></article><section id="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></section><aside id="sidebar"><div class="widget-wrap"><h3 class="widget-title">标签云</h3><div class="widget tagcloud"><a href="/tags/ARC/" style="font-size:10px">ARC</a> <a href="/tags/Bit-plane/" style="font-size:10px">Bit-plane</a> <a href="/tags/Block/" style="font-size:10px">Block</a> <a href="/tags/Class/" style="font-size:10px">Class</a> <a href="/tags/Coming-soon/" style="font-size:13.33px">Coming soon...</a> <a href="/tags/Command/" style="font-size:10px">Command</a> <a href="/tags/Computation/" style="font-size:10px">Computation</a> <a href="/tags/Coordinate/" style="font-size:10px">Coordinate</a> <a href="/tags/DATE/" style="font-size:10px">DATE</a> <a href="/tags/DATETIME/" style="font-size:10px">DATETIME</a> <a href="/tags/DataFrame/" style="font-size:10px">DataFrame</a> <a href="/tags/DataSource/" style="font-size:10px">DataSource</a> <a href="/tags/Debug/" style="font-size:10px">Debug</a> <a href="/tags/Delegate/" style="font-size:10px">Delegate</a> <a href="/tags/Difference/" style="font-size:11.67px">Difference</a> <a href="/tags/Digital/" style="font-size:10px">Digital</a> <a href="/tags/Driver/" style="font-size:11.67px">Driver</a> <a href="/tags/Emacs/" style="font-size:10px">Emacs</a> <a href="/tags/Enum/" style="font-size:10px">Enum</a> <a href="/tags/Experience/" style="font-size:10px">Experience</a> <a href="/tags/G/" style="font-size:10px">G++</a> <a href="/tags/GCC/" style="font-size:10px">GCC</a> <a href="/tags/GDB/" style="font-size:10px">GDB</a> <a href="/tags/GNU/" style="font-size:10px">GNU</a> <a href="/tags/Git/" style="font-size:10px">Git</a> <a href="/tags/GitHub/" style="font-size:10px">GitHub</a> <a href="/tags/Grubbs/" style="font-size:10px">Grubbs</a> <a href="/tags/Guide/" style="font-size:11.67px">Guide</a> <a href="/tags/High-Sierra/" style="font-size:10px">High Sierra</a> <a href="/tags/Image/" style="font-size:10px">Image</a> <a href="/tags/Installation/" style="font-size:10px">Installation</a> <a href="/tags/LLDB/" style="font-size:10px">LLDB</a> <a href="/tags/Language/" style="font-size:11.67px">Language</a> <a href="/tags/Linux/" style="font-size:11.67px">Linux</a> <a href="/tags/Matlab/" style="font-size:11.67px">Matlab</a> <a href="/tags/MySQL/" style="font-size:10px">MySQL</a> <a href="/tags/OS-X/" style="font-size:11.67px">OS X</a> <a href="/tags/ObjC/" style="font-size:10px">ObjC</a> <a href="/tags/Objective-C/" style="font-size:15px">Objective C</a> <a href="/tags/Pages/" style="font-size:10px">Pages</a> <a href="/tags/Pandas/" style="font-size:10px">Pandas</a> <a href="/tags/Parallel/" style="font-size:10px">Parallel</a> <a href="/tags/Path/" style="font-size:10px">Path</a> <a href="/tags/Photoshop/" style="font-size:10px">Photoshop</a> <a href="/tags/Processing/" style="font-size:10px">Processing</a> <a href="/tags/Programming/" style="font-size:20px">Programming</a> <a href="/tags/Python/" style="font-size:13.33px">Python</a> <a href="/tags/Redirect/" style="font-size:10px">Redirect</a> <a href="/tags/Rules/" style="font-size:10px">Rules</a> <a href="/tags/RxSwift/" style="font-size:13.33px">RxSwift</a> <a href="/tags/SVN/" style="font-size:10px">SVN</a> <a href="/tags/Science/" style="font-size:10px">Science</a> <a href="/tags/Sequence/" style="font-size:10px">Sequence</a> <a href="/tags/Series/" style="font-size:10px">Series</a> <a href="/tags/Server/" style="font-size:13.33px">Server</a> <a href="/tags/Shell/" style="font-size:11.67px">Shell</a> <a href="/tags/Sierra/" style="font-size:10px">Sierra</a> <a href="/tags/Spotlight/" style="font-size:10px">Spotlight</a> <a href="/tags/Struct/" style="font-size:10px">Struct</a> <a href="/tags/Swift/" style="font-size:16.67px">Swift</a> <a href="/tags/System/" style="font-size:10px">System</a> <a href="/tags/TIMESTAMP/" style="font-size:10px">TIMESTAMP</a> <a href="/tags/TenserFlow/" style="font-size:10px">TenserFlow</a> <a href="/tags/Tutorial/" style="font-size:11.67px">Tutorial</a> <a href="/tags/UIAlertController/" style="font-size:10px">UIAlertController</a> <a href="/tags/UITableView/" style="font-size:10px">UITableView</a> <a href="/tags/Unit/" style="font-size:11.67px">Unit</a> <a href="/tags/Wavelet/" style="font-size:10px">Wavelet</a> <a href="/tags/Working/" style="font-size:10px">Working</a> <a href="/tags/autoclosure/" style="font-size:10px">autoclosure</a> <a href="/tags/blog/" style="font-size:10px">blog</a> <a href="/tags/filter/" style="font-size:10px">filter</a> <a href="/tags/hexo/" style="font-size:10px">hexo</a> <a href="/tags/iOS/" style="font-size:18.33px">iOS</a> <a href="/tags/instance/" style="font-size:10px">instance</a> <a href="/tags/keyboard/" style="font-size:10px">keyboard</a> <a href="/tags/language/" style="font-size:10px">language</a> <a href="/tags/lazy-evaluation/" style="font-size:10px">lazy evaluation</a> <a href="/tags/log/" style="font-size:10px">log</a> <a href="/tags/macOS/" style="font-size:11.67px">macOS</a> <a href="/tags/map/" style="font-size:10px">map</a> <a href="/tags/parfor/" style="font-size:10px">parfor</a> <a href="/tags/reduce/" style="font-size:10px">reduce</a> <a href="/tags/type/" style="font-size:11.67px">type</a> <a href="/tags/which/" style="font-size:10px">which</a> <a href="/tags/优化算法/" style="font-size:10px">优化算法</a> <a href="/tags/优化问题/" style="font-size:10px">优化问题</a> <a href="/tags/修图/" style="font-size:10px">修图</a> <a href="/tags/入门/" style="font-size:10px">入门</a> <a href="/tags/响应式/" style="font-size:13.33px">响应式</a> <a href="/tags/噪声/" style="font-size:10px">噪声</a> <a href="/tags/坐标系统/" style="font-size:10px">坐标系统</a> <a href="/tags/小波/" style="font-size:10px">小波</a> <a href="/tags/开发/" style="font-size:13.33px">开发</a> <a href="/tags/异常值/" style="font-size:10px">异常值</a> <a href="/tags/教程/" style="font-size:11.67px">教程</a> <a href="/tags/服务器/" style="font-size:11.67px">服务器</a> <a href="/tags/机器学习/" style="font-size:10px">机器学习</a> <a href="/tags/模拟退火算法/" style="font-size:10px">模拟退火算法</a> <a href="/tags/神经网络/" style="font-size:10px">神经网络</a> <a href="/tags/缺失值/" style="font-size:10px">缺失值</a> <a href="/tags/遗传算法/" style="font-size:10px">遗传算法</a> <a href="/tags/配置/" style="font-size:11.67px">配置</a> <a href="/tags/降噪/" style="font-size:10px">降噪</a></div></div><div class="widget-wrap"><h3 class="widget-title">最新文章</h3><div class="widget"><ul><li><a href="/2018/01/25/notes/install_tensorflow_from_source_for_macos/">Instruction of Installing TensorFlow From Source</a></li><li><a href="/2017/10/28/learning_emacs/start_server/">Setting Up Emacs Server to Speed Up Your Emacs</a></li><li><a href="/2017/10/07/learning_python/compile_executable_with_cython/">用 Cython 把 Python 文件编译成可执行文件</a></li><li><a href="/2017/10/01/notes/update_high_sierra/">升级 macOS High Sierra 失败怎么办？😰</a></li><li><a href="/2017/05/09/learning_data_analysis_with_python/about_pandas/">Python 中的数据挖掘库 Pandas 的常用操作和容易出现误解的地方</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">归档</h3><div class="widget"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li></ul></div></div></aside></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2018 Yu Shengyang<br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></div></div></footer><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?c2f3493bffeb398373d9cda4fd1c6636";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-91049921-1","auto"),ga("send","pageview")</script></div><nav id="mobile-nav"><a href="/" class="mobile-nav-link">首页</a> <a href="/archives" class="mobile-nav-link">归档</a></nav><script>var disqus_shortname="blog-ysy",disqus_url="http://blog.superyoung.win/2017/01/25/learning_Rx/Reactive-Programming/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script src="/js/script.js"></script></div></body>