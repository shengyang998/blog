<!DOCTYPE html><html><head><meta charset="utf-8"><title>OO vs FP | Tech. Design. Life.</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="OO or FP? What’s relationship between them?A friend of mine posted the following on facebook. He meant it as a troll; and it worked, because it irked me."><meta property="og:type" content="article"><meta property="og:title" content="OO vs FP"><meta property="og:url" content="http://blog.superyoung.win/2017/02/04/learning_programming_principles/oovsfp/index.html"><meta property="og:site_name" content="Tech. Design. Life."><meta property="og:description" content="OO or FP? What’s relationship between them?A friend of mine posted the following on facebook. He meant it as a troll; and it worked, because it irked me."><meta property="og:image" content="http://blog.superyoung.win/images/Programming/oovsfp.jpg"><meta property="og:updated_time" content="2017-02-04T10:05:23.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="OO vs FP"><meta name="twitter:description" content="OO or FP? What’s relationship between them?A friend of mine posted the following on facebook. He meant it as a troll; and it worked, because it irked me."><meta name="twitter:image" content="http://blog.superyoung.win/images/Programming/oovsfp.jpg"><link rel="alternate" href="/atom.xml" title="Tech. Design. Life." type="application/atom+xml"><link rel="icon" href="/favicon.png"><link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/css/style.css"></head></html><body><div id="container"><div id="wrap"><header id="header"><div id="banner"></div><div id="header-outer" class="outer"><div id="header-title" class="inner"><h1 id="logo-wrap"><a href="/" id="logo">Tech. Design. Life.</a></h1></div><div id="header-inner" class="inner"><nav id="main-nav"><a id="main-nav-toggle" class="nav-icon"></a> <a class="main-nav-link" href="/">首页</a> <a class="main-nav-link" href="/archives">归档</a></nav><nav id="sub-nav"><a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a> <a id="nav-search-btn" class="nav-icon" title="搜索"></a></nav><div id="search-form-wrap"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.superyoung.win"></form></div></div></div></header><div class="outer"><section id="main"><article id="post-learning_programming_principles/oovsfp" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/2017/02/04/learning_programming_principles/oovsfp/" class="article-date"><time datetime="2017-02-04T08:44:50.000Z" itemprop="datePublished">2017-02-04</time></a></div><div class="article-inner"><header class="article-header"><h1 class="article-title" itemprop="name">OO vs FP</h1></header><div class="article-entry" itemprop="articleBody"><p>OO or FP? What’s relationship between them?</p><p>A friend of mine posted the following on facebook. He meant it as a troll; and it worked, because it irked me.</p><p><img src="/images/Programming/oovsfp.jpg" alt="oovsfp"><br><a id="more"></a></p><p><em>This is a post that translated from <a href="http://blog.cleancoder.com/uncle-bob/2014/11/24/FPvsOO.html" target="_blank" rel="external">The Clean Coder Blog</a></em></p><p>There are many programmers who have said similar things over the years. They consider Object Orientation and Functional Programming to be mutually exclusive forms of programming. From their ivory towers in the clouds some FP super-beings occasionally look down on the poor naive OO programmers and cluck their tongues.</p><p>That clucking is echoed by the OO super-beings in their ivory towers, who look askance at the waste and parentheses pollution of functional languages.</p><p>These views are based on a deep ignorance of what OO and FP really are.</p><p>Let me make a few points:</p><ul><li><p>OO is not about state. 面向对象不是关于状态的</p><p>Objects are not data structures. Objects may use data structures; but the manner in which those data structures are used or contained is hidden. This is why data fields are private. From the outside looking in you cannot see any state. All you can see are functions. Therefore Objects are about functions not about state.</p><p>对象不是数据结构，对象可能使用数据结构，但是数据结构被使用的方式是被隐藏的。这就是为什么数据域往往是<code>private</code>的。从对象的外面往里面看，你将不能看到任何状态，你能看到的只有<code>functions</code>。因此，对象是关于函数的而不是关于状态的。</p><p>When objects are used as data structures it is a design smell; and it always has been. When tools like Hibernate call themselves object-relational mappers, they are incorrect. ORMs don’t map relational data to objects; they map relational data to data structures. Those data structures are not objects.</p><p>如果对象被用做数据结构，那就是一个设计问题了。当像 <code>Hibernate</code> 这样的工具调用他们自己的 <code>object-relational mappers</code> 时将会发生错误。<code>对象关系映射ORM</code> 不映射 relational data to objects，他们映射 relational data to data structures。那些数据结构不是对象。</p><p>Objects are bags of functions, not bags of data.</p><p>对象一堆函数而不是一堆数据。</p></li><li><p>Functional Programs, like OO Programs, are composed of functions that operate on data. 函数式程序和面向对象程序一样，是由操作数据的函数组成的</p><p>You might protest and suggest that it is the manner of that binding that matters. But think about it. That’s silly. Is there really so much difference between f(o), o.f(), and (f o)? Are we really saying that the difference is just about the syntax of a function call?[0]</p><p><code>f(0)</code>, <code>o.f()</code>, <code>(f o)</code>之间有很大不同吗？</p></li></ul><h2 id="The-Differences"><a href="#The-Differences" class="headerlink" title="The Differences"></a>The Differences</h2><p>So what are the differences between OO and FP? What does OO have that FP doesn’t, and what does FP have that OO doesn’t?</p><p>所以 OO 和 FP 到底有什么不同呢？</p><ol><li><p>FP imposes discipline upon assignment. 函数式编程赋值准则。</p><p>A true functional programming language has no assignment operator. You cannot change the state of a variable. Indeed, the word “variable” is a misnomer in a functional language because you cannot vary them.</p><p>函数式编程语言没有赋值操作符。你不能改变一个变量的状态，实际上，函数式语言根本没有变量可言，因为你不可以改变他们。</p><p>Yes, I know, Funcitonal Programmers often say hi-falutin’ things like “Functions are first-class objects in functional languages.” That may be true; but functions are first-class objects in Smalltalk, and Smalltalk is an OO language, not a functional language.</p><p>The overriding difference between a functional language and a non-functional language is that functional languages don’t have assignment statements.[1]</p><p>OO 和 FP 之间的重要区别就是 FP 没有复制语句。</p><p>Does this mean that you can never change the state of something in a functional language? No, not at all. Functional languages generally offer ceremonies that you can perform in order to change the state of something. F# allows you to declare “mutable variables” for example. Clojure allows you to create special, uh, objects who’s values can be changed using various magic incantations.</p><p>这不意味着你永远不能改变一个东西的值。比如……</p><p>The point is that a functional language imposes some kind of ceremony or discipline on changes of state. You have to jump through the right hoops in order to do it.</p><p>And so, for the most part, you don’t.</p></li><li><p>OO imposes discipline on function pointers. 面向对象函数指针准则。</p><p>“Huh?” you say. But that, in fact, is what OO comes down to. For all the hi-falutin’ rhetoric about OO and “real-world objects” and “programming closer to the way we think”, what OO really comes down to is that OO languages replace function pointers with convenient polymorphism. [2]</p><p>How do you implement polymorphism? You implement it with function pointers. OO languages simply do that implementation for you, and hide the function pointers from you. This is nice because function pointers are very difficult to manage well. Trying to write polymorphic code with function pointers (as in C) depends on complex and inconvenient conventions that everyone must follow in every case. This is usually unrealistic.</p><p>In Java, every function you call is polymorphic. There is no way you can call a function that is not polymorphic. And that means that every java function is called indirectly through a pointer to a function.[3]</p><p>If you wanted polymophism in C, you’d have to manage those pointers yourself; and that’s hard. If you wanted polymorphism in Lisp you’d have to manage those pointers yourself (pass them in as arguments to some higher level algorithm (which, by the way IS the Strategy pattern.)) But in an OO language, those pointers are managed for you. The language takes care to initialize them, and marshal them, and call all the functions through them.</p></li></ol><h2 id="Mutually-Exclusive-完全不相容？"><a href="#Mutually-Exclusive-完全不相容？" class="headerlink" title="Mutually Exclusive? 完全不相容？"></a>Mutually Exclusive? 完全不相容？</h2><p>Are these two disciplines mutually exclusive? Can you have a language that imposes discipline on both assignment and pointers to functions? Of course you can. These two things don’t have anything to do with each other. And that means that <code>OO and FP are not mutually exclusive at all</code>. It means that you can write OO-Functional programs.</p><p>函数式编程和面向对象编程并不是完全不相容的。你完全可以写<code>OO-Functional</code>程序。</p><p>It also means that all the design principles, and design patterns, used by OO programmers can be used by functional programmers if they care to accept the discipline that OO imposes on their pointers to functions.</p><p>But why would a functional programmer do that? What benefit does polymorphism have that normal Functional Programs don’t have? By the same token, what benefit would OO programmers gain from imposing discipline on assignment?</p><p>但是为什么一个函数式编程要求程序员这样做？OO 又有什么好处？从另一方面来说，我们在面向对象程序中实行函数式编程中的赋值准则有什么好处？</p><h2 id="Benefits-of-Polymorphism-多态性的优势"><a href="#Benefits-of-Polymorphism-多态性的优势" class="headerlink" title="Benefits of Polymorphism 多态性的优势"></a>Benefits of Polymorphism 多态性的优势</h2><p>There really is only one benefit to Polymorphism; but it’s a big one. It is the inversion of source code and run time dependencies.</p><p>In most software systems when one function calls another, the runtime dependency and the source code dependency point in the same direction. The calling module depends on the called module. However, when polymorphism is injected between the two there is an inversion of the source code dependency. The calling module still depends on the called module at run time. However, the source code of the calling module does not depend upon the source code of the called module. Rather both modules depend upon a polymorphic interface.</p><p>This inversion allows the called module to act like a plugin. Indeed, this is how all plugins work.</p><p>Plugin architectures are very robust because stable high value business rules can be kept from depending upon volatile low value modules such as user interfaces and databases.</p><p>The net result is that in order to be robust a system must employ polymorphism across significant architectural boundaries.</p><h2 id="Benefits-of-Immutability-不可变的优势"><a href="#Benefits-of-Immutability-不可变的优势" class="headerlink" title="Benefits of Immutability 不可变的优势"></a>Benefits of Immutability 不可变的优势</h2><p>The benefit of not using assignment statements should be obvious. You can’t have concurrent update problems if you never update anything.</p><p>不使用赋值语句的优势是明显的：当你更新任何东西的时候，不会有任何更新问题发生。</p><p>Since functional programming languages do not have assignment statements, programs written in those languages don’t change the state of very many variables. Mutation is reserved for very specific sections of the system that can tolerate the high ceremony required. Those sections are inherently safe from multiple threads and multiple cores.</p><p>而且函数式编程语言没有赋值语句，导致了使用这种语言写的程序不会改变变量的状态。所以可以很容易的让编译器进行多线程优化。</p><p>The bottom line is that functional programs are much safer in multiprocessing and multiprocessor environments.</p><h2 id="The-Deep-Philosophies"><a href="#The-Deep-Philosophies" class="headerlink" title="The Deep Philosophies"></a>The Deep Philosophies</h2><p>Of course adherents to both Object Orientation and Functional Programming will protest my reductionist analysis. They will contend that there are deep philosophical, psychological, and mathematical reasons why their favorite style is better than the other.</p><p>My reaction to that is: Phooey!</p><p>Everybody thinks their way is the best. Everybody is wrong.<br>What about Design Principles, and Design Patterns?</p><p>The passage at the start of this article that irked me suggests that all the design principles and design patterns that we’ve identified over the last several decades apply only to OO; and that Functional Programming reduces them all down to: functions.</p><p>Wow! Talk about being reductionist!</p><p>This idea is bonkers in the extreme. The principles of software design still apply, regardless of your programming style. The fact that you’ve decided to use a language that doesn’t have an assignment operator does not mean that you can ignore the Single Responsibility Principle; or that the Open Closed Principle is somehow automatic. The fact that the Strategy pattern makes use of polymorphism does not mean that the pattern cannot be used in a good functional language[4].</p><p>The bottom, bottom line here is simply this. OO programming is good, when you know what it is. Functional programming is good when you know what it is. And functional OO programming is also good once you know what it is.</p><blockquote><ol><li>I imagine there are a few python programmers who might have something to say about that.</li><li>This, of course, means that Scala is not a “true” functional language.</li><li>This, of course, means that C++ is not a “true” OO language.</li><li>Yeah, don’t say it, I know. OK, an “analog” to a pointer to a function. (sigh).</li><li>A good functional language is one that allows for convenient polymorphism. Clojure is a good example.</li></ol></blockquote></div><footer class="article-footer"><a data-url="http://blog.superyoung.win/2017/02/04/learning_programming_principles/oovsfp/" data-id="ciyr053v00000880gxvnmzp5o" class="article-share-link">Share</a> <a href="http://blog.superyoung.win/2017/02/04/learning_programming_principles/oovsfp/#disqus_thread" class="article-comment-link">留言</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/FP/">FP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Functional-Programming/">Functional Programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OO/">OO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Object-Orientation/">Object Orientation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Principle/">Principle</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Programming/">Programming</a></li></ul></footer></div><nav id="article-nav"><a href="/2017/02/02/learning_swift/map_reduce_filter/" id="article-nav-older" class="article-nav-link-wrap"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">An Introduction to Map(), flatMap(), Reduce() and Filter() in Swift</div></a></nav></article><section id="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></section><aside id="sidebar"><div class="widget-wrap"><h3 class="widget-title">标签云</h3><div class="widget tagcloud"><a href="/tags/ARC/" style="font-size:10px">ARC</a> <a href="/tags/Block/" style="font-size:10px">Block</a> <a href="/tags/Coming-soon/" style="font-size:14px">Coming soon...</a> <a href="/tags/Coordinate/" style="font-size:10px">Coordinate</a> <a href="/tags/DataSource/" style="font-size:10px">DataSource</a> <a href="/tags/Debug/" style="font-size:10px">Debug</a> <a href="/tags/Delegate/" style="font-size:10px">Delegate</a> <a href="/tags/FP/" style="font-size:10px">FP</a> <a href="/tags/Functional-Programming/" style="font-size:10px">Functional Programming</a> <a href="/tags/GDB/" style="font-size:10px">GDB</a> <a href="/tags/GitHub/" style="font-size:10px">GitHub</a> <a href="/tags/LLDB/" style="font-size:10px">LLDB</a> <a href="/tags/Language/" style="font-size:10px">Language</a> <a href="/tags/OO/" style="font-size:10px">OO</a> <a href="/tags/ObjC/" style="font-size:10px">ObjC</a> <a href="/tags/Object-Orientation/" style="font-size:10px">Object Orientation</a> <a href="/tags/Objective-C/" style="font-size:16px">Objective C</a> <a href="/tags/Pages/" style="font-size:10px">Pages</a> <a href="/tags/Photoshop/" style="font-size:10px">Photoshop</a> <a href="/tags/Principle/" style="font-size:10px">Principle</a> <a href="/tags/Programming/" style="font-size:20px">Programming</a> <a href="/tags/Rules/" style="font-size:10px">Rules</a> <a href="/tags/RxSwift/" style="font-size:10px">RxSwift</a> <a href="/tags/Sequence/" style="font-size:10px">Sequence</a> <a href="/tags/Swift/" style="font-size:16px">Swift</a> <a href="/tags/System/" style="font-size:10px">System</a> <a href="/tags/UIAlertController/" style="font-size:10px">UIAlertController</a> <a href="/tags/UITableView/" style="font-size:10px">UITableView</a> <a href="/tags/autoclosure/" style="font-size:10px">autoclosure</a> <a href="/tags/blog/" style="font-size:10px">blog</a> <a href="/tags/filter/" style="font-size:10px">filter</a> <a href="/tags/hexo/" style="font-size:10px">hexo</a> <a href="/tags/iOS/" style="font-size:18px">iOS</a> <a href="/tags/instance/" style="font-size:10px">instance</a> <a href="/tags/keyboard/" style="font-size:10px">keyboard</a> <a href="/tags/language/" style="font-size:10px">language</a> <a href="/tags/lazy-evaluation/" style="font-size:10px">lazy evaluation</a> <a href="/tags/map/" style="font-size:10px">map</a> <a href="/tags/reduce/" style="font-size:10px">reduce</a> <a href="/tags/type/" style="font-size:12px">type</a> <a href="/tags/修图/" style="font-size:10px">修图</a> <a href="/tags/入门/" style="font-size:10px">入门</a> <a href="/tags/响应式/" style="font-size:10px">响应式</a> <a href="/tags/坐标系统/" style="font-size:10px">坐标系统</a> <a href="/tags/开发/" style="font-size:10px">开发</a></div></div><div class="widget-wrap"><h3 class="widget-title">最新文章</h3><div class="widget"><ul><li><a href="/2017/02/04/learning_programming_principles/oovsfp/">OO vs FP</a></li><li><a href="/2017/02/02/learning_swift/map_reduce_filter/">An Introduction to Map(), flatMap(), Reduce() and Filter() in Swift</a></li><li><a href="/2017/01/31/learning_swift/LLDB_Usage/">LLDB Tutorial</a></li><li><a href="/2017/01/29/learning_swift/autoclosure/">Autoclosure and Lazy Evaluation</a></li><li><a href="/2017/01/29/learning_iOS/ARC_Rules/">ARC Rules</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">归档</h3><div class="widget"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li></ul></div></div></aside></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2017 Yu Shengyang<br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></div></div></footer><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?c2f3493bffeb398373d9cda4fd1c6636";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>!function(e,t,a,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=t.createElement(a),s=t.getElementsByTagName(a)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-91049921-1","auto"),ga("send","pageview")</script></div><nav id="mobile-nav"><a href="/" class="mobile-nav-link">首页</a> <a href="/archives" class="mobile-nav-link">归档</a></nav><script>var disqus_shortname="blog-ysy",disqus_url="http://blog.superyoung.win/2017/02/04/learning_programming_principles/oovsfp/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script src="/js/script.js"></script></div></body>