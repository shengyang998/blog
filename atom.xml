<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tech. Design. Life.</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.superyoung.win/"/>
  <updated>2019-04-06T10:28:14.981Z</updated>
  <id>http://blog.superyoung.win/</id>
  
  <author>
    <name>Yu Shengyang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS 循环引用</title>
    <link href="http://blog.superyoung.win/2019/04/04/learning_iOS/retain_cycle/"/>
    <id>http://blog.superyoung.win/2019/04/04/learning_iOS/retain_cycle/</id>
    <published>2019-04-04T06:01:47.050Z</published>
    <updated>2019-04-06T10:28:14.981Z</updated>
    
    <content type="html"><![CDATA[<p>最近处理了一些循环引用问题，记录一下，供日后回顾。</p><a id="more"></a><h2 id="引发循环引用的原因"><a href="#引发循环引用的原因" class="headerlink" title="引发循环引用的原因"></a>引发循环引用的原因</h2><p>循环引用很容易理解，但是为了更形象，让我们来做个假设。<br>假如有一个人买了一台 Nintendo Switch（NS）（那么此时他就拥有了一台 NS），而如果这个时候他打开了一款游戏，他很沉迷游戏。如果把 NS 看做一个闭包的话，那么就可以认为这台 NS 反过来（强）持有了这个人。也就是在此时，循环引用产生了，如果没有外界因素的话他很难停止游戏，这块内存将不会被释放。<br>要打破这个循环引用的话，有两种办法：</p><ol><li>强制自己不要太沉迷，也就是用 weak/unowned 修饰被闭包捕获的 self；</li><li>不要持有 NS，比如通过租借或者其他办法，反正不能自己持有。也就是说闭包是通过另一个对象提供的，而且自己本身不持有另一个对象。<br>用图来理解的话如下：我们只需要打破引用循环中的任何一条线即可。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A ---/---&gt; B</span><br><span class="line">A &lt;--/---- B</span><br></pre></td></tr></table></figure></li></ol><p>循环引用产生的根本原因就是对象之间产生了循环的强引用，如果我们可以打破这个链条的任何一个环节，循环引用也就不存在了。<br>其中一个问题就在于如何打破这个链条，打破链条其实很简单，但是是不是符合你的需求这就比较麻烦了。<br>另一个问题在于，如果这个链条比较长的话，你可能根本不会意识到你的代码产生了循环引用。这种情况，一个是要自己细心，另外是如果能引入代码 peer review 的话会好一点，可能你看不出的细节问题别人从另一个角度来看就看得出来了。或者实在不行后期借助 instrument 工具来调查循环引用的问题。</p><h2 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h2><ol><li>类实例方法是隐式强引用 self 的。<br>所以如果你把实例方法传到领一个实例中，而这另一个实例又是当前类实例的一个属性，那这个循环引用就很难解开了。这里的解决办法有两个，一个是改造现有类，把实例方法转换成闭包；另一个办法是在把当前实例方法传给另一个实例的时候，使用闭包再包装一层，然后在这一层闭包中使用 weak/unowned 捕获 self。两种办法都能解决问题，就看你的选择了。</li><li><p>捕获列表中 weak 和 unowned 的区别<br>weak 指的是弱引用，同时也会把紧跟其后的对象转变为 Optional 类型。而 unowned 可以理解为隐式解包的弱引用，如果被引用的对象为 nil，则程序崩。<br>个人的习惯是，如果被捕获的对象生命周期和当前对象的生命周期一致的话，没有异步调用的话，使用 unowned。如果有异步调用的话情况就比较复杂了，使用 weak 可以保证程序不会崩溃，但是也可能导致程序不按需求来执行。<br>举个例子，如果你有一个对象发起了网络请求，如果这个对象在发起请求后，收到回复前被释放了，网络请求是否要保留呢？如果网络请求不需要继续执行的话，使用 weak self，然后判空，若 self 为空则 return，这个逻辑很简单也很合理。但是假设如果网络请求还需要保留呢？self 为空，那网络请求就算获取到也不能进行后续操作了呀。这种情况直接使用 weak 就略显复杂了是吧。这种情况也有两种解决的办法：</p></li><li><p>使用捕获列表直接捕获所需要的属性，这样做 swift 会自动捕获且仅捕获所需要的属性，而不会自动捕获 self。<br>例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; [aProperty] <span class="keyword">in</span></span><br><span class="line"><span class="comment">// Do anthing with aProperty</span></span><br><span class="line"><span class="keyword">let</span> a = aProperty</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>需要注意的是，这种捕获方式下，被捕获的属性是<strong>不能</strong>被更改的，因为默认捕获的是常量，所以如果你需要修改某个属性，你可能必须捕获 self。</p><ol start="2"><li>除此以外，考虑一下类结构合理吗？是不是应该重新设计一下类的结构，比如是否需要把那个属性抽出当前类？</li></ol><p>大概就那么多，欢迎交流。</p><blockquote><p>生命中大部分时光是属于孤独的，努力成长是在孤独里可以进行的最好的游戏。<br>——《夏目友人帐》</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近处理了一些循环引用问题，记录一下，供日后回顾。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://blog.superyoung.win/tags/iOS/"/>
    
      <category term="Retain Cycle" scheme="http://blog.superyoung.win/tags/Retain-Cycle/"/>
    
  </entry>
  
  <entry>
    <title>《失控》笔记</title>
    <link href="http://blog.superyoung.win/2018/09/02/reading_out_of_control/reading_out_of_control/"/>
    <id>http://blog.superyoung.win/2018/09/02/reading_out_of_control/reading_out_of_control/</id>
    <published>2018-09-02T13:44:07.893Z</published>
    <updated>2018-12-27T16:00:39.055Z</updated>
    
    <content type="html"><![CDATA[<ul><li>混乱中，秩序会自然产生吗？</li><li>活系统：非平衡的稳态</li><li>集体的智慧</li><li>线性思维方式与系统性思维方式</li><li>谁先出现，稳定性还是多样性？</li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;&lt;li&gt;混乱中，秩序会自然产生吗？&lt;/li&gt;&lt;li&gt;活系统：非平衡的稳态&lt;/li&gt;&lt;li&gt;集体的智慧&lt;/li&gt;&lt;li&gt;线性思维方式与系统性思维方式&lt;/li&gt;&lt;li&gt;谁先出现，稳定性还是多样性？&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="智能" scheme="http://blog.superyoung.win/tags/%E6%99%BA%E8%83%BD/"/>
    
      <category term="复杂系统" scheme="http://blog.superyoung.win/tags/%E5%A4%8D%E6%9D%82%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="失控" scheme="http://blog.superyoung.win/tags/%E5%A4%B1%E6%8E%A7/"/>
    
      <category term="Kevin Kelly" scheme="http://blog.superyoung.win/tags/Kevin-Kelly/"/>
    
  </entry>
  
  <entry>
    <title>《代码整洁之道》笔记</title>
    <link href="http://blog.superyoung.win/2018/07/29/learning_clean_code/clean_code/"/>
    <id>http://blog.superyoung.win/2018/07/29/learning_clean_code/clean_code/</id>
    <published>2018-07-29T15:32:15.663Z</published>
    <updated>2019-01-25T08:45:49.346Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这座楼，除了我的房间以外，已经彻底基皮化了。”<br>“基皮化？”她莫名其妙。<br>“基皮就是没用的东西，垃圾邮件啊，空火柴盒啊，口香糖包装纸啊，昨天的报纸啊。周围没人的时候，基皮就会自我繁殖。比如，如果你睡前在房间里留了些基皮，第二天醒来就会发现基皮增加了一倍。基皮总是会越变越多。”<br>“我明白了。”女孩迟疑地盯着他，不知该不该相信他，一时无法确定他是不是在开玩笑。<br>“这就是基皮第一定律，”他说，“‘基皮驱逐非基皮’。就像格拉舍姆的劣币驱逐良币定律。那些空房间里头，没有活人在抵抗基皮。”</p></blockquote><p>—— P.K.Dick, Do Androids Dream of Electric Sheep?</p><p>就如房间一样，代码也要时常打理才能保持清洁，否则会被“基皮”占领，最终因‘基皮驱逐非基皮’而崩溃。基皮是小说里的概念，如果借助热力学定律里的“熵”的概念，对于代码这种既抽象又精确的事物来说，熵越低自然就越好。<br>那么如何能写出低熵的代码呢？很遗憾，这需要经验，非常考验程序员之功力。而《代码整洁之道》就是这样一本“低熵代码编写指南”，借助它可以<strong>快速入门</strong>编写低熵的代码。但是这也只是一本快速入门书而已，尽信书不如无书，具体还是要在遵循规则中突破规则。<br>这本书的核心观点就是要【清晰】，而要做到这一点的方法论就是【分层、短小】……</p><a id="more"></a><h1 id="0x00-童子军军规"><a href="#0x00-童子军军规" class="headerlink" title="0x00 童子军军规"></a>0x00 童子军军规</h1><blockquote><p>让营地比你来时更干净</p></blockquote><blockquote><p>努力，让世界比你来时干净些</p></blockquote><h1 id="0x01-命名"><a href="#0x01-命名" class="headerlink" title="0x01 命名"></a>0x01 命名</h1><h2 id="名副其实"><a href="#名副其实" class="headerlink" title="名副其实"></a>名副其实</h2><p>命名很重要，首先第一点要做到的就是命名要名副其实。<br>做到名副其实并不简单，选个好名字的确要花时间，但是省下来的时间绝对比花掉的多。<br>一旦发现有更好的命名，马上换掉旧的。<br>名字最好是自解释的，如果你需要注释来补充，那这就不算名副其实。</p><h2 id="避免误导"><a href="#避免误导" class="headerlink" title="避免误导"></a>避免误导</h2><ol><li><p>别用缩写。</p><blockquote><p>e.g. 不要用 xxList 来指代一组数据，除非这组数据真的是 List 类型的，否则就会误导。</p></blockquote></li><li><p>别用双关语<br>避免把同一单词用于不同目的</p><blockquote><p>e.g. 假设要写一个新类，该类中有一个方法，把单个参数放到 collection 中。应该把这额方法叫做 insert 或者 append 而不是 add 之类的。</p></blockquote></li><li><p>谨慎使用不同之处较小的名称</p><blockquote><p>e.g. 名字 ZXCVControllerForEfficientStorageOfString 和 ZXCVControllerForEfficientHandlingOfString。区分这两个名字要花多少时间呢？这两个名字的外形太相似了。</p></blockquote></li></ol><h2 id="命名要做有意义的区分"><a href="#命名要做有意义的区分" class="headerlink" title="命名要做有意义的区分"></a>命名要做有意义的区分</h2><p>不要只为了满足编译器或解释器来写代码，会制造麻烦。<br>如果名称必须相异，那么其意思也应该不同才对。<br>不要写废话。</p><blockquote><p>e.g. 假设你有个 Product 类，如果还有一个 ProductInfo 或者 ProductData 类，虽然它们名称不同，但是含义却无甚区别。那么这里的 Info 和 Data 就是废话了。</p></blockquote><p>冗余的都是废话</p><blockquote><p>e.g. Variable 一词永远不应该出现在变量名中。Table 永远不应该出现在表名中。NameString 会比 Name 更好吗？ 既然 Name 不可能是一个浮点数的话，就不要写冗余的 String 了。</p></blockquote><h2 id="使用读得出来的名称"><a href="#使用读得出来的名称" class="headerlink" title="使用读得出来的名称"></a>使用读得出来的名称</h2><p>嗯，可以想象，不然很难跟人沟通代码。</p><h2 id="使用易于搜索的名字"><a href="#使用易于搜索的名字" class="headerlink" title="使用易于搜索的名字"></a>使用易于搜索的名字</h2><p>就是说不要用单字母的名称和数字常量了，代码多了以后没办法搜索。<br>另外，长名称胜过短名称。名称长短应与其作用于大小相对应。</p><h2 id="不必用-m-成员前缀来标明成员变量。"><a href="#不必用-m-成员前缀来标明成员变量。" class="headerlink" title="不必用 m_ 成员前缀来标明成员变量。"></a>不必用 m_ 成员前缀来标明成员变量。</h2><p>因为类和函数应该足够小。而且现代编辑器和 IDE 都应该有代码高亮功能。</p><h2 id="避免思维映射"><a href="#避免思维映射" class="headerlink" title="避免思维映射"></a>避免思维映射</h2><p>不应该让读者在脑中把你的名称翻译为他们熟知的名称。这很难做到，因为每个人都有自己的经验，这就需要程序员打起十二分的精神了。</p><h2 id="类名和方法名"><a href="#类名和方法名" class="headerlink" title="类名和方法名"></a>类名和方法名</h2><p>类名<strong>不</strong>应该是动词<br>方法名应该是动词</p><h2 id="别扮可爱-🐶"><a href="#别扮可爱-🐶" class="headerlink" title="别扮可爱 🐶"></a>别扮可爱 🐶</h2><blockquote><p>e.g. DeleteItems 明显会比什么 HolyHandGrenade 好得多 🐶</p></blockquote><h2 id="每个概念对应一个词"><a href="#每个概念对应一个词" class="headerlink" title="每个概念对应一个词"></a>每个概念对应一个词</h2><blockquote><p>e.g. 如果在同一堆代码中既有 controller 又有 manager 就会使人困惑。</p></blockquote><h2 id="尽量不要使用问题领域内的名称"><a href="#尽量不要使用问题领域内的名称" class="headerlink" title="尽量不要使用问题领域内的名称"></a>尽量不要使用<strong>问题领域内的</strong>名称</h2><p>因为只有程序员才会读你的代码。如果使用领域名称的话，协作者可能需要再次解码，增加了工程难度。<br>实在不能用程序员熟悉的术语来命名，那就使用领域名称吧。这样协作者就只能去请教领域专家了，这是没办法的办法。</p><h2 id="添加有意义的语境-——-使用命名空间"><a href="#添加有意义的语境-——-使用命名空间" class="headerlink" title="添加有意义的语境 —— 使用命名空间"></a>添加有意义的语境 —— 使用命名空间</h2><h1 id="0x02-函数"><a href="#0x02-函数" class="headerlink" title="0x02 函数"></a>0x02 函数</h1><h2 id="短小"><a href="#短小" class="headerlink" title="短小"></a>短小</h2><p>函数的规则第一是短小，第二是更短小。</p><p>一个函数要做到<strong>只做一件事</strong>。</p><p>严格来说，来说这意味着 if、else、while 等语句中的代码块只有一行，最多两行代码。<br>同时这也意味着函数不应该打到足以容大嵌套结构，所以函数的锁进层级也不应该多于一层或两层。</p><blockquote><p>这正好反驳了那些认为 Python 缩进规则反人类的观点，毕竟你本身就不应该缩进太多层。</p></blockquote><p>如果函数只是做了该函数名下同一抽象层次上的步骤，则函数还是只做了一件事。毕竟，编写函数是为了把一个大的概念拆分为另一个抽象层次上的一系列步骤。<br>要判断函数是否不止做了一件事，还有一个办法，就是尝试着再拆分出一个函数。<br>如果函数可以被切分成很多区段，就是这个函数做了太多事的征兆，一个只做一件事的函数不应该能被切分成多个区段。</p><h2 id="每个函数一个抽象层级"><a href="#每个函数一个抽象层级" class="headerlink" title="每个函数一个抽象层级"></a>每个函数一个抽象层级</h2><p>要确保一个函数只做一件事，那么这个函数的所有语句都要在同一层级上。<br>千万注意<strong>不要在一个函数中混杂不同抽象层级！</strong></p><h2 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h2><p>我们想要这样读程序：程序就像是一系列 To 开头的段落，每一段描述当前抽象层级，并且引用下一层级的后续 To 起头的段落。这叫做<strong>向下规则</strong>。<br>而程序员往往很难遵守这条规则，写出只停留于一个抽象层级的函数。</p><h2 id="Switch-语句"><a href="#Switch-语句" class="headerlink" title="Switch 语句"></a>Switch 语句</h2><p>Switch 天生要做多件事，写出短小的 Switch 语句很难。<br>不过我们可以用 <code>多态</code> 来实现。</p><blockquote><p>将 switch 语句埋藏在抽象工厂地下，不让任何人看到。<br>对于 switch 语句，作者的规则是【如果只出现一次，用于创建多态对象，而且隐藏在某个继承关系中，那么还可以容忍。】</p></blockquote><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>最理想的参数数量是0⃣️，其次是1⃣️，再次是2⃣️，尽量避免3⃣️个参数。<br>如果函数使用三个或三个以上的参数时，就意味着其中一些参数该被封装成类了。<br>请千万谨慎使用 boolean 参数。</p><h2 id="无副作用"><a href="#无副作用" class="headerlink" title="无副作用"></a>无副作用</h2><p>【副作用是一种谎言】函数承诺只做一件事，但是它还是做了其他事。<br>编写无副作用的函数易于调试、易于重构使用多线程的能力。千万别小看副作用的威力，副作用可能引入各种时序问题，很多 Bug 就是由它引起的。<br>无副作用也是函数式编程所需要的最基本的理念。</p><h2 id="分隔指令类函数和询问类函数"><a href="#分隔指令类函数和询问类函数" class="headerlink" title="分隔指令类函数和询问类函数"></a>分隔指令类函数和询问类函数</h2><p>函数要么<strong>做</strong>什么事，要么<strong>回答</strong>什么问题，二者不可得兼。</p><h2 id="使用异常而不是返回错误码"><a href="#使用异常而不是返回错误码" class="headerlink" title="使用异常而不是返回错误码"></a>使用异常而不是返回错误码</h2><p>使用异常替代返回错误码，错误处理流程就能从主流程中分离出来，这很重要。</p><h2 id="抽离-Try-Catch"><a href="#抽离-Try-Catch" class="headerlink" title="抽离 Try/Catch"></a>抽离 Try/Catch</h2><p>Try/Catch 代码块丑陋不堪。把错误处理与正常流程混为一谈。最好把 try 和 catch 从中体部分抽离出来。</p><h2 id="D-R-Y"><a href="#D-R-Y" class="headerlink" title="D.R.Y."></a>D.R.Y.</h2><p>老生常谈了。【不要重复自己】，一旦你发现有重复的代码，就要停下来，分析一下是否可以再进行抽象。<br>永远不要在自己的代码库里使用 <code>Ctrl - C &amp; Ctrl - V</code> 这样做得不偿失。</p><h2 id="Dijkstra-的结构化编程规则"><a href="#Dijkstra-的结构化编程规则" class="headerlink" title="Dijkstra 的结构化编程规则"></a>Dijkstra 的结构化编程规则</h2><p>【每个函数、函数中的每个代码块都应该只有一个入口、一个出口。】遵循这个规则意味着，在每个函数中只应该有一个 return 语句，循环中不能有 break 或 continue 语句，而且永远不能有 goto 语句。<br>作者赞成结构化编程的目标和规范，但是对于小函数，这些规范没有什么帮助，只有在大函数中，这些规范才有明显的好处。所以又回到了开头，只要保持函数短小就没有问题。偶尔出现的 return、break 或者 continue 语句没有坏处，甚至更具有表达力。</p><h1 id="如何写出这样的函数"><a href="#如何写出这样的函数" class="headerlink" title="如何写出这样的函数"></a>如何写出这样的函数</h1><p>写代码和写文章很像。初稿也许粗陋无序，斟酌推敲，直至达到你心目中的样子。<br>作者写函数时，一开始都很冗长而复杂，名称甚至也是随意取的，也有重复的代码，不过会配上一套单元测试，覆盖每行丑陋的代码。然后开始打磨这些代码，分解函数、修改名称、消除重复、缩短并重新放置方法。最后遵循上述的规则，组装好这些函数。<br>作者也认为【不要一开始就按照规则写函数，没人做得到】</p><h2 id="书中的小结"><a href="#书中的小结" class="headerlink" title="书中的小结"></a>书中的小结</h2><ol><li>代码是演化出来的，没有人能一蹴而就写出完美的代码，所有人都是一边写代码一边重构，在重构的过程中是自己的思路更加清晰，而遵循这些要点可以避免初学者在重构时跑偏。</li><li>大师级的程序员把系统当做故事来讲，而不是当做程序来写。为了讲好那个故事，他们使用特定的编程语言构建一种更为丰富且更具表达力的语言。</li><li>真正的目标在于讲述系统的故事，而你编写的函数必须干净利落的拼装到一起，形成一种精确而清晰的语言，帮助你讲故事。</li></ol><h2 id="个人的小结"><a href="#个人的小结" class="headerlink" title="个人的小结"></a>个人的小结</h2><p>总体来看，上面部分内容的逻辑是：<br>为了遵守沃德原则，需要整洁的代码；为了有整洁的代码，需要取好的名字；为了更容易取好的名字，函数的功能就要越简单；为了让函数的功能更简单，函数就要越短。<br>上述逻辑就是前面提到的 <code>自顶向下</code> 原则，写代码的时候也要用这样的逻辑。</p><h3 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h3><ul><li>所谓沃德原则就是：【如果每个例程都让你感到深合己意，那就是整洁代码。】</li></ul><blockquote><p>本书后面还有关于注释、格式、对象和数据结构、错误处理、边界、单元测试、类、系统、迭代、并发编程、逐步改进、JUnit内幕、重构 SerialDate、代码的味道与启发相关的内容。<br>特别是“代码的味道”章节，个人认为这对于形成代码直觉很重要，不过大部分内容我这篇博文也算是覆盖了。感兴趣的童鞋们可以自行购书阅读。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;这座楼，除了我的房间以外，已经彻底基皮化了。”&lt;br&gt;“基皮化？”她莫名其妙。&lt;br&gt;“基皮就是没用的东西，垃圾邮件啊，空火柴盒啊，口香糖包装纸啊，昨天的报纸啊。周围没人的时候，基皮就会自我繁殖。比如，如果你睡前在房间里留了些基皮，第二天醒来就会发现基皮增加了一倍。基皮总是会越变越多。”&lt;br&gt;“我明白了。”女孩迟疑地盯着他，不知该不该相信他，一时无法确定他是不是在开玩笑。&lt;br&gt;“这就是基皮第一定律，”他说，“‘基皮驱逐非基皮’。就像格拉舍姆的劣币驱逐良币定律。那些空房间里头，没有活人在抵抗基皮。”&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;—— P.K.Dick, Do Androids Dream of Electric Sheep?&lt;/p&gt;&lt;p&gt;就如房间一样，代码也要时常打理才能保持清洁，否则会被“基皮”占领，最终因‘基皮驱逐非基皮’而崩溃。基皮是小说里的概念，如果借助热力学定律里的“熵”的概念，对于代码这种既抽象又精确的事物来说，熵越低自然就越好。&lt;br&gt;那么如何能写出低熵的代码呢？很遗憾，这需要经验，非常考验程序员之功力。而《代码整洁之道》就是这样一本“低熵代码编写指南”，借助它可以&lt;strong&gt;快速入门&lt;/strong&gt;编写低熵的代码。但是这也只是一本快速入门书而已，尽信书不如无书，具体还是要在遵循规则中突破规则。&lt;br&gt;这本书的核心观点就是要【清晰】，而要做到这一点的方法论就是【分层、短小】……&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="http://blog.superyoung.win/tags/Programming/"/>
    
      <category term="Clean Code" scheme="http://blog.superyoung.win/tags/Clean-Code/"/>
    
  </entry>
  
  <entry>
    <title>为什么 Python 的 Range 要设计成左开右闭区间？为什么数组下标要从零开始？</title>
    <link href="http://blog.superyoung.win/2018/04/03/notes/why_number_should_start_at_zero/"/>
    <id>http://blog.superyoung.win/2018/04/03/notes/why_number_should_start_at_zero/</id>
    <published>2018-04-03T15:24:16.124Z</published>
    <updated>2018-04-04T11:23:28.126Z</updated>
    
    <content type="html"><![CDATA[<p>除了 Python 的 Range，还有 Swift 语言的 <code>..&lt;</code> 运算符之类的也有这样的设计。而 Edsger W. Dijkstra 在1982年写过一篇短文章，分析了一下其中的原因，这里做摘录与翻译如下。</p><a id="more"></a><p>原文：<a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html" target="_blank" rel="noopener">Why numbering should start at zero</a></p><p>翻译：<br>为了表示 2,3,…,12 这样一个序列，有四种方法</p><ol><li>2 ≤ i &lt; 13（左闭右开区间）</li><li>1 &lt; i ≤ 12（左开右闭区间）</li><li>2 ≤ i ≤ 12（闭区间）</li><li>1 &lt; i &lt; 13（开区间）</li></ol><p>其中有没有哪一种是最好的表示法呢？有的。前两种表示法的两端数字的差刚好是序列的长度。而且在这两种的任何一种表示法中，两个相邻子序列的其中一个子序列的上界就是另一个子序列的下界。这只是让我们挑出了前两种，而不能让我们从前两种中选出最好的一种表示法来，让我们继续分析。</p><p>注意到自然数是有最小值的。当我们在下界取 <code>&lt;</code>（像第二和第四那样），如果我们想表示一个从最小的自然数开始的序列，那这种表示法的下界就会是非自然数（比如 0,1,…,5 会被表示成 -1 &lt; i ≤ 5），这种表示法显得太丑陋了，所以对于下界，我们喜欢 <code>≤</code>。</p><p>那我们再来看看上界，在下界使用 <code>≤</code> 时，如果我们对上界也使用<code>≤</code> 会发生什么呢？考虑一下当我们想要表示一个空集时，比如 0 ≤ i ≤ -1 上界会小于下界。显然，这也是很难令人接受的，太反直觉了。而如果上界使用 <code>&lt;</code>，就会方便很多，同样，表示空集：0 ≤ i &lt; 0。所以，对于上界，我们喜欢 <code>&lt;</code>。</p><blockquote><p>有疑问的话，注意一下，0 ≤ i &lt; 0 的含义是，i &lt; 0 &amp;&amp; i &gt;= 0，他们之间是逻辑与的关系，所以当上下界数字相等时可以表示空集。</p></blockquote><p>好的，我们通过这些分析发现，第一种表示法是最直观的。我们再来看看讨人烦的下标问题，到底我们应该给第一个元素什么值呢？ 0 还是 1 ？对于含有 N 个元素的序列，使用第一种表示法：</p><ol><li>当从 1 开始时，下标范围是 1 ≤ i &lt; N+1；</li><li>而如果从零开始，下标范围是 0 ≤ i &lt; N；<br>让我们的下标从零开始吧，这样，一个元素的下标就等于当前元素之前的元素的数量了。（an element’s subscript equals the number of elements preceding it in the sequence. ）</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>抛开冗长的分析过程，总结一下，选择第一种表示法（左闭右开区间）有以下几个原因</p><ol><li>上下界之差等于元素的数量</li><li>易于表示两个相邻子序列，一个子序列的上界就是另一个子序列的下界</li><li>序列从零（最小自然数）开始计数时，下界的下标不是 -1（非自然数）</li><li>表达空集时，不会使得上界小于下界</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cs.utexas.edu/users/EWD/ewd08xx/EWD831.PDF" target="_blank" rel="noopener">via Edsger W. Dijkstra</a><br><a href="https://plus.google.com/115212051037621986145/posts/YTUxbXYZyfi" target="_blank" rel="noopener">via Guido van Rossum</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;除了 Python 的 Range，还有 Swift 语言的 &lt;code&gt;..&amp;lt;&lt;/code&gt; 运算符之类的也有这样的设计。而 Edsger W. Dijkstra 在1982年写过一篇短文章，分析了一下其中的原因，这里做摘录与翻译如下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="http://blog.superyoung.win/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>PAT 1141 Python C++ 解题</title>
    <link href="http://blog.superyoung.win/2018/03/20/pat/advanced_level/1141/"/>
    <id>http://blog.superyoung.win/2018/03/20/pat/advanced_level/1141/</id>
    <published>2018-03-20T15:02:54.036Z</published>
    <updated>2018-04-19T08:01:32.586Z</updated>
    
    <content type="html"><![CDATA[<p>题源：<a href="https://www.patest.cn/contests/pat-a-practise/1141" target="_blank" rel="noopener">https://www.patest.cn/contests/pat-a-practise/1141</a></p><p>注意，对于最后两个测试点，使用 Python 语言会超时，从前三个测试点来看，同样的逻辑下 Python 的速度大概是 C++ 的 14%，嗯，太慢了……<br><a id="more"></a></p><p>OK，照例，</p><h2 id="先看题目："><a href="#先看题目：" class="headerlink" title="先看题目："></a>先看题目：</h2><blockquote><p>After each PAT, the PAT Center will announce the ranking of institutions based on their students’ performances. Now you are asked to generate the ranklist.<br><strong>Input Specification</strong>:<br>Each input file contains one test case. For each case, the first line gives a positive integer N (&lt;=10^5), which is the number of testees. Then N lines follow, each gives the information of a testee in the following format:<br><strong>ID Score School</strong><br>where “ID” is a string of 6 characters with the first one representing the test level: “B” stands for the basic level, “A” the advanced level and “T” the top level; “Score” is an integer in [0, 100]; and “School” is the institution code which is a string of no more than 6 English letters (case insensitive). Note: it is guaranteed that “ID” is unique for each testee.<br><strong>Output Specification</strong>:<br>For each case, first print in a line the total number of institutions. Then output the ranklist of institutions in nondecreasing order of their ranks in the following format:<br><strong>Rank School TWS Ns</strong><br>where “Rank” is the rank (start from 1) of the institution; “School” is the institution code (all in lower case); “TWS” is the total weighted score which is defined to be the integer part of <code>&quot;ScoreB/1.5 + ScoreA + ScoreT*1.5&quot;</code>, where “ScoreX” is the total score of the testees belong to this institution on level X; and “Ns” is the total number of testees who belong to this institution.<br>The institutions are ranked according to their TWS. If there is a tie, the institutions are supposed to have the same rank, and they shall be printed in ascending order of Ns. If there is still a tie, they shall be printed in alphabetical order of their codes.</p></blockquote><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><ul><li>时间限制：500ms</li><li>内存限制：65537kB</li></ul><h3 id="输入输出要求"><a href="#输入输出要求" class="headerlink" title="输入输出要求"></a>输入输出要求</h3><p>题目大概意思就是说，对于每次 PAT 考试，我们会对每个学校进行排名。</p><ul><li>输入格式是<code>N</code>，<code>ID Score School</code></li><li>输出格式是<code>N</code>，<code>Rank School TWS Ns</code><br>其中：</li><li>N 是队伍总数（N&lt;=100000）</li><li>M 是学校总数</li><li>ID 是一个定长 6 个字符的字符串，第一位取值范围：’T’, ‘A’, ‘B’</li><li>Score 是该 ID 队伍的成绩</li><li>School 就是学校名称了是一个不定长的字符串</li><li>Rank 是排名，注意题目要求：非递减——就是可以连续相同的 rank，数学上可以叫驻点</li><li>TWS 是学校的总成绩，计算公式：<code>ScoreB/1.5 + ScoreA + ScoreT*1.5</code>，这里的 Score[TAB] 对应上面 ID 的第一位 [TAB]</li><li>Ns 是学校参赛队伍数量</li></ul><h3 id="排序规则："><a href="#排序规则：" class="headerlink" title="排序规则："></a>排序规则：</h3><p>首先按照 TWS 递减排序。<br>如果 TWS 相同，按照 Ns 递增排序。<br>如果 Ns 相同，按照学校名称的字母表顺序排序</p><p>啊哈，看到这道题有什么思路吗？</p><ul><li>看到这道题应该有的大致思路：<ol><li>使用字典（哈希表）来保存<code>学校名</code>和<code>学校</code></li><li>读取数据到字典(Complexity: O(N));</li><li>对字典，按照要求，进行排序(Complexity: O(2NlogN) or worst: O(2N^2));</li><li>输出，这里要注意排名（rank）的显示要求——非递减;</li></ol></li></ul><ol><li>想说其实这道题思路并不难，但是这道题的确花了我不少时间，因为最后两个测试点（5 points）总是超时。就算使用 Cpp unoredered_map 的处理时间也接近了 490ms，好悬。10^5 的数据量不敢小觑。</li><li>一开始选择数据结构的时候，我使用了标准库的 map 结构，大概可以当做一个红黑树。所以不管什么插入删除操作大概都是 O(logN) 的复杂度，这个复杂度太高了。后来改用 unorderd_map 结构，也即是哈希表，嗯，插入的时间复杂度接近 O(1) 了，很好。这里要感谢一下 Cpp 标准库，从 map 迁移到 unordered_map 只改了两处类型签名而已，非常方便。</li><li>为了让代码结构清晰，我设立了两个类，一个是 School 一个是 Result。</li><li>Result 中只有一个成员变量，其类型是： unordered_map&lt;string, School*&gt;</li><li>在 School 中，存放了学校的名称、总成绩、队伍数。值得提一下的是：为了避免冗余的强制类型转换 (double) -&gt; (long) 我使用一个惰性计算的技巧，即增加一个成员变量 long sc，在调用 get_score() 的时候才计算出 sc 的值，而如果 sc 已经被计算过了，那就直接返回 sc 的值。也算是一点点优化吧。</li><li>其他的比如说 cin 缓慢的问题（cin 会判断输入类型是否匹配，会比 scanf 慢），就没时间改了，如果有兴趣自己改改吧，也不难。</li></ol><p>照例（好吧，这是我第一次有机会写 PAT 的解题过程，没有前例^_^）<br>Cpp 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#define DEBUG</span></span><br><span class="line"><span class="keyword">namespace</span> My &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="keyword">long</span> cntlog = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">log</span>(<span class="title">Tp</span> <span class="title">x</span>, <span class="title">string</span> <span class="title">lv</span> = "<span class="title">INFO</span>") &#123;</span></span><br><span class="line">My::cntlog++;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"--&gt; "</span> &lt;&lt; lv &lt;&lt; <span class="string">" "</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">School</span> &#123;</span> <span class="comment">// Class for saving status of each institution</span></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> counter;</span><br><span class="line"><span class="keyword">double</span> score;</span><br><span class="line"><span class="keyword">long</span> sc; <span class="comment">// save time, for the convertion from double to long is somehow expensive</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">School(<span class="built_in">string</span> &amp;name, <span class="keyword">double</span> score, <span class="keyword">char</span> level) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;score = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;sc = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;append(score, level);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">School* <span class="title">append</span><span class="params">(<span class="keyword">double</span> score, <span class="keyword">char</span> level)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;counter++;</span><br><span class="line"><span class="keyword">double</span> lv = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">if</span> (level == <span class="string">'B'</span>)</span><br><span class="line">lv = <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (level == <span class="string">'T'</span>)</span><br><span class="line">lv = <span class="number">1.5</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;score += score * lv;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_counter</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get_score</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>-&gt;sc == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;sc = <span class="keyword">long</span>(<span class="keyword">this</span>-&gt;score);<span class="comment">// In the test case as the `Sample Input`, this line will be hit 5 times</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;sc;<span class="comment">// and this line will be hit 49 times. So this `lazy initial tech` should save some time.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">get_name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span> &#123;</span> <span class="comment">// Class for saving the result, containing an unordered map of &lt;school name, School&gt;</span></span><br><span class="line"><span class="built_in">unordered_map</span> &lt;<span class="built_in">string</span>, School*&gt; d;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="built_in">string</span> school_name, <span class="keyword">int</span> score, <span class="keyword">char</span> level)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (d.find(school_name) == d.end())</span><br><span class="line">d.insert(pair &lt;<span class="built_in">string</span>, School*&gt; (school_name, <span class="keyword">new</span> School(school_name, score, level)));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">d[school_name]-&gt;append(score, level);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, School*&gt;&gt;&amp; sort() &#123; <span class="comment">// sort function. use a lambda to costumize, and return a sorted vector</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [&amp;](<span class="keyword">const</span> pair &lt;<span class="built_in">string</span>, School*&gt; &amp;lhs, <span class="keyword">const</span> pair &lt;<span class="built_in">string</span>, School*&gt; &amp;rhs) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (lhs.second-&gt;get_score() == rhs.second-&gt;get_score()) &#123;</span><br><span class="line"><span class="keyword">if</span> (lhs.second-&gt;get_counter() == rhs.second-&gt;get_counter())</span><br><span class="line"><span class="keyword">return</span> lhs.second-&gt;get_name() &lt; rhs.second-&gt;get_name();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> lhs.second-&gt;get_counter() &lt; rhs.second-&gt;get_counter();</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> lhs.second-&gt;get_score() &gt; rhs.second-&gt;get_score();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, School*&gt;&gt; *vec = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, School*&gt;&gt;(<span class="keyword">this</span>-&gt;d.begin(), <span class="keyword">this</span>-&gt;d.end());</span><br><span class="line"><span class="built_in">std</span>::sort(vec-&gt;begin(), vec-&gt;end(), cmp);</span><br><span class="line"><span class="keyword">return</span> *vec;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">Result* res = <span class="keyword">new</span> Result();</span><br><span class="line"><span class="keyword">while</span> (N--) &#123;</span><br><span class="line"><span class="keyword">char</span> level[<span class="number">7</span>];</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; level &gt;&gt; score &gt;&gt; name;</span><br><span class="line"><span class="keyword">char</span> lv = level[<span class="number">0</span>];</span><br><span class="line">transform(name.begin(), name.end(), name.begin(), ::<span class="built_in">tolower</span>); <span class="comment">// transform the school name to lower case</span></span><br><span class="line">res-&gt;append(name, score, lv);<span class="comment">// append to the result (as an unordered map)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, School*&gt;&gt; r = res-&gt;sort();<span class="comment">// sort the result and return a vector</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> n = r.size();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> cnt = <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = r.begin(); iter != r.end(); iter++) &#123;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (iter != r.begin() <span class="keyword">and</span> iter-&gt;second-&gt;get_score() != (iter - <span class="number">1</span>)-&gt;second-&gt;get_score()) &#123; <span class="comment">// calculate the rank of each institution (Complexity: O(1), so the outter for loop is O(N))</span></span><br><span class="line">cnt = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second-&gt;get_name() &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second-&gt;get_score() &lt;&lt; <span class="string">" "</span> &lt;&lt; iter-&gt;second-&gt;get_counter() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python 代码如下：(代码短，容易理解。逻辑和 C++ 代码一样，只是最后两个测试点超时)<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">School</span>:</span></span><br><span class="line">name = <span class="string">''</span></span><br><span class="line">score = <span class="number">0</span></span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, school_name, score, level)</span>:</span></span><br><span class="line">self.name = school_name</span><br><span class="line">self.append(score, level)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, score, level)</span>:</span></span><br><span class="line">self.counter += <span class="number">1</span></span><br><span class="line">lv = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> level == <span class="string">'B'</span>:</span><br><span class="line">lv = <span class="number">2</span>/<span class="number">3</span></span><br><span class="line"><span class="keyword">elif</span> level == <span class="string">'T'</span>:</span><br><span class="line">lv = <span class="number">1.5</span></span><br><span class="line">self.score += score * lv</span><br><span class="line"><span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_score_to_int</span><span class="params">(self)</span>:</span></span><br><span class="line">self.score = int(self.score)</span><br><span class="line"><span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">s = int(input())</span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(s):</span><br><span class="line">t = input().split(<span class="string">' '</span>)</span><br><span class="line">level = t[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">score = int(t[<span class="number">1</span>])</span><br><span class="line">school_name = t[<span class="number">2</span>].lower()</span><br><span class="line"><span class="keyword">if</span> school_name <span class="keyword">in</span> d.keys():</span><br><span class="line">d[school_name].append(score, level)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">d[school_name] = School(school_name, score, level)</span><br><span class="line">d = sorted(d.items(), key=<span class="keyword">lambda</span> x: [-x[<span class="number">1</span>].score, x[<span class="number">1</span>].counter, x[<span class="number">0</span>]])<span class="comment"># Could cost most of the time</span></span><br><span class="line">print(len(d))</span><br><span class="line">cnt = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(d)):</span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> int(d[i][<span class="number">1</span>].score) != int(d[i<span class="number">-1</span>][<span class="number">1</span>].score):</span><br><span class="line">cnt = i+<span class="number">1</span></span><br><span class="line">print(<span class="string">"&#123;0&#125; &#123;1&#125; &#123;2&#125; &#123;3&#125;"</span>.format(cnt, d[i][<span class="number">1</span>].name, int(d[i][<span class="number">1</span>].score), d[i][<span class="number">1</span>].counter))</span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题源：&lt;a href=&quot;https://www.patest.cn/contests/pat-a-practise/1141&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.patest.cn/contests/pat-a-practise/1141&lt;/a&gt;&lt;/p&gt;&lt;p&gt;注意，对于最后两个测试点，使用 Python 语言会超时，从前三个测试点来看，同样的逻辑下 Python 的速度大概是 C++ 的 14%，嗯，太慢了……&lt;br&gt;
    
    </summary>
    
    
      <category term="PAT" scheme="http://blog.superyoung.win/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>Instruction of Installing TensorFlow From Source</title>
    <link href="http://blog.superyoung.win/2018/01/25/notes/install_tensorflow_from_source_for_macos/"/>
    <id>http://blog.superyoung.win/2018/01/25/notes/install_tensorflow_from_source_for_macos/</id>
    <published>2018-01-24T16:07:40.115Z</published>
    <updated>2018-12-27T12:06:18.208Z</updated>
    
    <content type="html"><![CDATA[<p>Notice: This Paste &amp; Run code is only meant for <code>CPU Only</code> build and only for macOS. You will need brew and pip installed before you run it.</p><a id="more"></a><ol><li><p>Paste these in your terminal and run:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 1. prepare environment for macOS</span><br><span class="line">    # 1. install bazel with brew (recommended):</span><br><span class="line">      brew install bazel</span><br><span class="line">    # 2. install python dependencies</span><br><span class="line">      pip install six numpy wheel</span><br><span class="line"><span class="meta">#</span> 2. clone source code from github: </span><br><span class="line">    git clone https://github.com/tensorflow/tensorflow</span><br><span class="line"><span class="meta">#</span> 3. follow the configuration to configure</span><br><span class="line">    cd tensorflow; ./configure</span><br><span class="line"><span class="meta">#</span> 4. build the pip package (without consume too much memory. If you don't need to limit the memory consumption, just delete the --local_resources flag)</span><br><span class="line">    bazel build --config=opt --local_resources 2048,.5,1.0 //tensorflow/tools/pip_package:build_pip_package</span><br><span class="line"><span class="meta">#</span> 5. the command above will build the `build_pip_package` package, </span><br><span class="line"><span class="meta">#</span>    to build the `.whl` package, run the following command: </span><br><span class="line">    rm -rf tmp; mkdir tmp; bazel-bin/tensorflow/tools/pip_package/build_pip_package ./tmp/tensorflow_pkg</span><br><span class="line"><span class="meta">#</span> 6. install whl package with pip ([tab] means type tab, for auto completion to interact)</span><br><span class="line">    pip install /tmp/tensorflow_pkg/*;</span><br></pre></td></tr></table></figure><p>Alternatively, if you already have <code>gnu make</code> installed, it is easier for you to download the Makefile below and all you need to do is to run the shell code below:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/shengyang998/easy_install_tensorflow.git &amp;&amp; \ </span><br><span class="line">cd easy_install_tensorflow &amp;&amp; make all;</span><br></pre></td></tr></table></figure></li><li><p>validate the installation is completed:</p><ol><li><p>use text editor to open a python file like (using vi here):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi hello_world_tenserflow.py;</span><br></pre></td></tr></table></figure></li><li><p>and type in:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">hello = tf.constant(<span class="string">'Hello, TensorFlow!'</span>)</span><br><span class="line">sess = tf.Session()</span><br><span class="line">print(sess.run(hello))</span><br></pre></td></tr></table></figure></li><li><p>then run the python script in the terminal:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python hello_world_tensorflow.py;</span><br></pre></td></tr></table></figure></li></ol><p>The standard output should show up: <code>Hello, TensorFlow!</code> if your installation is completed sucessfully.</p></li><li><p>related link: <a href="https://www.tensorflow.org/versions/master/install/install_sources" target="_blank" rel="noopener">Installing TensorFlow from Sources</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notice: This Paste &amp;amp; Run code is only meant for &lt;code&gt;CPU Only&lt;/code&gt; build and only for macOS. You will need brew and pip installed before you run it.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Installation" scheme="http://blog.superyoung.win/tags/Installation/"/>
    
      <category term="TenserFlow" scheme="http://blog.superyoung.win/tags/TenserFlow/"/>
    
  </entry>
  
  <entry>
    <title>Setting Up Emacs Server to Speed Up Your Emacs</title>
    <link href="http://blog.superyoung.win/2017/10/28/learning_emacs/start_server/"/>
    <id>http://blog.superyoung.win/2017/10/28/learning_emacs/start_server/</id>
    <published>2017-10-28T04:58:57.510Z</published>
    <updated>2018-04-19T08:03:13.408Z</updated>
    
    <content type="html"><![CDATA[<p>This article describe how to start the Emacs Server for reducing file opening time cost in the future use.<br><a id="more"></a></p><h2 id="0x00-Introduction"><a href="#0x00-Introduction" class="headerlink" title="0x00 Introduction"></a>0x00 Introduction</h2><p>I have a lot of package installed so that when I start emacs, it will take about 10s to start over. And that is why I decide to use emacs’ server and client mode to speed up the startup procedure.</p><h2 id="0x01-Set-up-start-server-with-a-executable-shell-file"><a href="#0x01-Set-up-start-server-with-a-executable-shell-file" class="headerlink" title="0x01 Set up start server with a executable shell file"></a>0x01 Set up start server with a executable shell file</h2><p>in <code>start_emacs_server.sh</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Starting Emacs Server..."</span></span><br><span class="line">/Applications/Emacs.app/Contents/MacOS/Emacs-x86_64-10_9 --daemon</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Done."</span></span><br></pre></td></tr></table></figure><h2 id="0x02-set-up-env-variables"><a href="#0x02-set-up-env-variables" class="headerlink" title="0x02 set up env variables"></a>0x02 set up env variables</h2><p>in <code>~/.bash_profile</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> em=<span class="string">'$HOME/emacs.sh'</span></span><br><span class="line"><span class="built_in">alias</span> emacsclient=<span class="string">'/Applications/Emacs.app/Contents/MacOS/bin-x86_64-10_9/emacsclient'</span></span><br></pre></td></tr></table></figure><h2 id="0x03-set-up-emacsclient-command"><a href="#0x03-set-up-emacsclient-command" class="headerlink" title="0x03 set up emacsclient command"></a>0x03 set up emacsclient command</h2><p>in <code>emacs.sh</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">/Applications/Emacs.app/Contents/MacOS/bin-x86_64-10_9/emacsclient -n -c -a <span class="string">""</span> -- <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure><p>Now you can use<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em [filename]</span><br></pre></td></tr></table></figure><p></p><p>to use emacs to open a file with the current emacs server</p><h2 id="0x04-One-last-thing"><a href="#0x04-One-last-thing" class="headerlink" title="0x04 One last thing:"></a>0x04 One last thing:</h2><p>remember to set the server autostart at login</p><p><img src="/images/emacs/emacs_login_autostart.png" alt="p"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This article describe how to start the Emacs Server for reducing file opening time cost in the future use.&lt;br&gt;
    
    </summary>
    
    
      <category term="Emacs" scheme="http://blog.superyoung.win/tags/Emacs/"/>
    
  </entry>
  
  <entry>
    <title>用 Cython 把 Python 文件编译成可执行文件</title>
    <link href="http://blog.superyoung.win/2017/10/07/learning_python/compile_executable_with_cython/"/>
    <id>http://blog.superyoung.win/2017/10/07/learning_python/compile_executable_with_cython/</id>
    <published>2017-10-07T07:44:40.841Z</published>
    <updated>2018-10-16T07:32:28.592Z</updated>
    
    <content type="html"><![CDATA[<p>macOS 预装的 python 版本为 2.7，这里将会展示如何把 3.4 版本的 python 代码编译成可执行文件<br><a id="more"></a></p><h2 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h2><ol start="0"><li>安装 cython，一般可以使用 <code>sudo pip install -U cython</code> 来安装</li><li>写好 python 代码，保存成 main.py 文件</li><li><code>cython --embed main.py</code><br>这时会生成一个 .c 文件，也就是转换后的 c 代码</li><li><p>使用 which 命令找到当前使用的 python 的路径，比如说我的 python3 安装在</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MBA:~ ysy$ which python3</span><br><span class="line">/Library/Frameworks/Python.framework/Versions/3.4/bin/python3</span><br></pre></td></tr></table></figure><p>也就是说<code>头</code>和<code>动态链接库</code>分别在 <code>/Library/Frameworks/Python.framework/Versions/3.4/Headers</code> 和 <code>/Library/Frameworks/Python.framework/Versions/3.4/lib</code> 这里，记录下这两个路径。推荐使用环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PYTHON_LIB=/Library/Frameworks/Python.framework/Versions/3.4/lib</span><br><span class="line">export C_INCLUDE_PATH=/Library/Frameworks/Python.framework/Versions/3.4/Headers</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>gcc</code> 编译成可执行文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -I $C_INCLUDE_PATH -L $PYTHON_LIB -lpython3.4m -o a main.c</span><br></pre></td></tr></table></figure><p>解释一下， <code>-I</code> 是指定预编译头文件的位置；<code>-L</code> 是指定动态链接库的位置；<code>-l</code> 是指定动态链接库名。</p></li></ol><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><ol start="0"><li>注意三个参数标记 <code>-I</code> <code>-L</code> <code>-l</code>，他们和紧跟在后的参数之间是可以没有空格的。</li><li>库名和库的文件名之间的关系满足：<code>文件名 = &#39;lib&#39; + 库名 + &#39;.so&#39;</code>，可以自行 <code>ls -alh $PYTHON_LIB</code> 验证。</li><li>其实这个编译成可执行文件不太符合 cython 的初衷，cython 的初衷是为了把 python 代码编译成库，用来加速 python 代码调用的。当然，有时候因为自己不想写多个 py 文件，直接编译成可执行代码来用用也无妨。</li><li>其他问题可以参考 <a href="http://docs.cython.org" target="_blank" rel="noopener">Cython’s Documentation</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;macOS 预装的 python 版本为 2.7，这里将会展示如何把 3.4 版本的 python 代码编译成可执行文件&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.superyoung.win/tags/Python/"/>
    
      <category term="Cython" scheme="http://blog.superyoung.win/tags/Cython/"/>
    
  </entry>
  
  <entry>
    <title>升级 macOS High Sierra 失败怎么办？😰</title>
    <link href="http://blog.superyoung.win/2017/10/01/notes/update_high_sierra/"/>
    <id>http://blog.superyoung.win/2017/10/01/notes/update_high_sierra/</id>
    <published>2017-10-01T11:17:30.533Z</published>
    <updated>2017-10-01T12:25:17.372Z</updated>
    
    <content type="html"><![CDATA[<p>升级系统没遇到问题自然最好，遇到了问题，首先要淡定。搞清楚情况之前千万不要乱操作，以免发生不可逆转的事故。</p><a id="more"></a><h2 id="0x00-升级前请备份重要数据-请备份重要数据-备份重要数据"><a href="#0x00-升级前请备份重要数据-请备份重要数据-备份重要数据" class="headerlink" title="0x00 升级前请备份重要数据 请备份重要数据 备份重要数据"></a>0x00 升级前请备份重要数据 请备份重要数据 备份重要数据</h2><h2 id="0x01-首先介绍一下-macOS-High-Sierra-以及为什么要升级到这个版本"><a href="#0x01-首先介绍一下-macOS-High-Sierra-以及为什么要升级到这个版本" class="headerlink" title="0x01 首先介绍一下 macOS High Sierra 以及为什么要升级到这个版本"></a>0x01 首先介绍一下 macOS High Sierra 以及为什么要升级到这个版本</h2><p>私以为，这个版本的系统将会是至今最流畅的 macOS：</p><ol><li>High Sierra 中 Finder 启动速度比上一个版本的快了接近一倍</li><li>文件系统转换成了 APFS (Apple File System) —— 带来了包括 copy on write 技术的新文件系统，相信使用 iPhone 的用户早就体验到了其惊人效果： 6s 及以上的设备（升级到 iOS 10.3 以后）后台开 30+ 应用程序互相切换不需要重新载入 —— 其作用在 macOS 上体现为复制文件只需要一瞬间，和读写性能的提升</li><li>还有一些应用级别的升级<br><a href="http://help.apple.com/macOS/high-sierra/whats-new/" target="_blank" rel="noopener">What’s new</a></li></ol><h2 id="0x02-另外升级前，看看官方-Requirement-说明"><a href="#0x02-另外升级前，看看官方-Requirement-说明" class="headerlink" title="0x02 另外升级前，看看官方 Requirement 说明"></a>0x02 另外升级前，看看官方 Requirement 说明</h2><p><a href="https://support.apple.com/en-us/ht201475" target="_blank" rel="noopener">Requirements</a></p><h2 id="0x03-不幸遇到问题？如何自己解决？"><a href="#0x03-不幸遇到问题？如何自己解决？" class="headerlink" title="0x03 不幸遇到问题？如何自己解决？"></a>0x03 不幸遇到问题？如何自己解决？</h2><ol start="0"><li>首先说一下遇到升级问题是可以就近去任意一家 Apple 官方店找店员解决问题的。不过下面还是讲讲自己怎么解决吧，下面的解决方案基于你有一个高速稳定的网络，如果没有这个条件，还是找 Apple 店员吧，更方便快捷。那么，我们开始升级吧：</li><li>如果 App Store 下载失败，重启一下电脑，找个稳定的网络环境，多试几次。</li><li>如果安装过程最后提示出错，或者比如说【请重新运行安装程序】之类的，然后重启，发现根本无法进入系统！别急，现在的确应该是不能进入系统的，但是现在数据都还在，只是磁盘被锁住了而已。当然了现在可以进入恢复模式（这点比 PC 好太多）</li><li>现在你的数据都没丢失，都完整的躺在硬盘里，而硬盘，虽然不确定现在是 APFS 还是 HFS+ 格式，但是无所谓，先不用管它，我们一步步走。首先根据 Apple 官网的指引，在开机的时候一直按下 <code>command + R</code> （恢复到上一个稳定系统） 或者 <code>command + option + R</code> （升级并恢复到最新稳定的系统）键进入恢复系统。注意，此时最好有 WiFi 链接，因为等会的系统需要从 Internet 上下载</li><li>连接上 WiFi 以后就恢复系统吧。此时你的文件也还是安全的，放心。只要你不选择格式化之类的选项。另外注意，需要 WiFi 链接。</li><li>在恢复模式下安装可能还会卡住。我遇到的情况是下载失败，<code>InstallOSDDmg.pkg</code> 这个文件下载不下来，这个问题的解决办法是重试。过了一晚重试一下就可以了。如果你的进度条卡住了，看一下 log 信息，找找错误原因，再对症下药吧。</li><li>如果恢复完成，恭喜你，数据保住了，系统也更新完了！ 咦等等，但是，为什么进不去系统，开机提示输入磁盘密码 —— 而这个密码根本不是用户密码！淡定，淡定</li><li>其实上网随便搜一搜就解决了，需要输入磁盘密码是因为开启了磁盘加密功能，此时，解锁即可。怎么解锁呢？还是需要借助恢复模式，好的，我们重新进入恢复模式看看。</li><li>这次不要选择恢复系统了哈，毕竟系统已经装上去了。现在，在菜单栏找到终端，打开，输入命令 <code>diskutil apfs list</code> 并观察输出的文字内容，根据磁盘大小或者盘符找到你安装系统的磁盘号码，形如 <code>disk#s#</code> ，比如说我的磁盘盘符是 <code>Macintosh HD</code> 磁盘号是 <code>disk2s1</code>，同时，你会看到这个磁盘旁边写着 <code>Unmounted</code> 未挂载。好的，记录下磁盘号和磁盘盘符</li><li>继续在终端输入 <code>diskutil apfs unlockvolume #磁盘号#</code></li><li>在终端输入 <code>diskutil apfs updatePreboot #磁盘号#</code></li><li>如果输出 <code>error=0</code> 的话，恭喜你，已经成功了，重启电脑吧！ 如果输出不是 <code>error=0</code> 而是 <code>error=-69569</code> 之类的，也不用急，继续操作</li><li><p>在终端输入（注意下面的 <code>disk2s1</code> 和 <code>Macintosh\ HD</code>， 你需要改成你自己的磁盘盘符。另外在手敲终端命令的情况下，为了避免失误，你需要会使用 Tab 键来自动补全，试试吧，打出开头几个字母，那些反斜杠都会自动补全出来的）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diskutil apfs updatePreboot disk2s1 -od /Volumes/Macintosh\ HD/Recovered\ Items/private/var/db/dslocal/nodes/Default</span><br></pre></td></tr></table></figure></li><li><p>重启电脑，结束。<br><a href="https://www.zhihu.com/question/65908448" target="_blank" rel="noopener">感谢知乎的小伙伴们</a></p></li></ol><h2 id="最后如果不想那么刺激，升级前先备份数据吧，即使不小心格式化了硬盘，也随时可以通过恢复模式的-Time-Machine-恢复"><a href="#最后如果不想那么刺激，升级前先备份数据吧，即使不小心格式化了硬盘，也随时可以通过恢复模式的-Time-Machine-恢复" class="headerlink" title="最后如果不想那么刺激，升级前先备份数据吧，即使不小心格式化了硬盘，也随时可以通过恢复模式的 Time Machine 恢复"></a>最后如果不想那么刺激，升级前先备份数据吧，即使不小心格式化了硬盘，也随时可以通过恢复模式的 Time Machine 恢复</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;升级系统没遇到问题自然最好，遇到了问题，首先要淡定。搞清楚情况之前千万不要乱操作，以免发生不可逆转的事故。&lt;/p&gt;
    
    </summary>
    
    
      <category term="macOS" scheme="http://blog.superyoung.win/tags/macOS/"/>
    
      <category term="OS X" scheme="http://blog.superyoung.win/tags/OS-X/"/>
    
      <category term="Sierra" scheme="http://blog.superyoung.win/tags/Sierra/"/>
    
      <category term="High Sierra" scheme="http://blog.superyoung.win/tags/High-Sierra/"/>
    
  </entry>
  
  <entry>
    <title>Python 中的数据挖掘库 Pandas 的常用操作和容易出现误解的地方</title>
    <link href="http://blog.superyoung.win/2017/05/09/learning_data_analysis_with_python/about_pandas/"/>
    <id>http://blog.superyoung.win/2017/05/09/learning_data_analysis_with_python/about_pandas/</id>
    <published>2017-05-09T03:15:56.000Z</published>
    <updated>2018-04-19T08:03:09.433Z</updated>
    
    <content type="html"><![CDATA[<p>本文将主要总结 Python 库 Pandas 的一些常用操作和一些坑<br><a id="more"></a></p><h2 id="Pandas-简介"><a href="#Pandas-简介" class="headerlink" title="Pandas 简介"></a>Pandas 简介</h2><p>Pandas 是一个开源的，基于 numpy 的数据挖掘库，因为基于 numpy ，一般来说其效率也不低。</p><blockquote><p><a href="http://pandas.pydata.org/" target="_blank" rel="noopener">Pandas官网</a></p></blockquote><h2 id="Pandas-中主要数据结构"><a href="#Pandas-中主要数据结构" class="headerlink" title="Pandas 中主要数据结构"></a>Pandas 中主要数据结构</h2><p><code>DataFrame</code>：可以看做是一张表，有列名(<code>key</code>)，有行号(<code>index</code>)，每列有一个numpy的数据类型(<code>dtype</code>)。<br><code>Series</code>：可以看做是表的一列，有行号(<code>index</code>)和数据类型(<code>dtype</code>)。<br>可以把 <code>DataFrame</code> 看做是 <code>Series</code> 的集合，而 <code>Series</code> 是 numpy 中某类型的集合。</p><h2 id="Pandas-的一些常用操作"><a href="#Pandas-的一些常用操作" class="headerlink" title="Pandas 的一些常用操作"></a>Pandas 的一些常用操作</h2><ul><li><p>获取列名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.keys()</span><br></pre></td></tr></table></figure></li><li><p>删除列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其中参数 inplace 可以控制是否在原 DataFrame 中进行操作</span></span><br><span class="line">new_df = df.drop(<span class="string">"time"</span>, inplace=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure></li><li><p>删除行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下代码应该删除第 11 行和第 13 行</span></span><br><span class="line">new_df = df.drop([<span class="number">11</span>, <span class="number">13</span>], inplace=<span class="keyword">False</span>)</span><br><span class="line"><span class="comment"># 以下代码删除的是第 11 行到第 13 行</span></span><br><span class="line">new_df = df.drop(range(<span class="number">11</span>, <span class="number">13</span>), inplace=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure></li><li><p>行切片</p><ol><li><p>loc</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[df.index[[<span class="number">0</span>, <span class="number">2</span>]], <span class="string">'A'</span>]</span><br></pre></td></tr></table></figure></li><li><p>iloc</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.iloc[[<span class="number">0</span>, <span class="number">2</span>], df.columns.get_loc[<span class="string">'A'</span>]]</span><br></pre></td></tr></table></figure></li><li><p>选择多列进行行切片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.iloc[[<span class="number">0</span>, <span class="number">2</span>], df.columns.get_indexer([<span class="string">'A'</span>, <span class="string">'B'</span>])]</span><br></pre></td></tr></table></figure></li><li><p>已废弃：<del>df.ix[[0,1,3,5]]</del></p></li></ol></li><li><p>将日期转换成时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  使用 to_datetime 方法</span></span><br><span class="line">pandas.to_datetime(df[<span class="string">'datetimestring'</span>], format=<span class="keyword">None</span>)</span><br><span class="line"><span class="comment"># 或者直接改变某列的 dtype</span></span><br><span class="line">df[<span class="string">'datetimestring'</span>].dtpye = datetime64</span><br><span class="line"><span class="comment"># 对 datetime64 类型的数据可以进行 .date() .time() .timestamp() 等操作</span></span><br><span class="line">df[<span class="string">'date'</span>] = df[<span class="string">'datetimestring'</span>].date()</span><br><span class="line">df[<span class="string">'time'</span>] = df[<span class="string">'datetimestring'</span>].time()</span><br><span class="line">df[<span class="string">'timestamp'</span>] = df[<span class="string">'datetimestring'</span>].timestamp()</span><br></pre></td></tr></table></figure></li></ul><h2 id="Pandas-使用上的一些坑"><a href="#Pandas-使用上的一些坑" class="headerlink" title="Pandas 使用上的一些坑"></a>Pandas 使用上的一些坑</h2><ol><li>关于 <code>index</code>，每次 drop 行以后最好都 df.reset_index()，不然下次按照 index 遍历的时候你就等着哭吧/微笑</li><li><code>dateutil.parser.parse(&#39;10/04/2016 10:20&#39;)</code> 可以直接将标格式的日期字符串转换成日期格式，而且 pandas 可以识别，不过因为必对每一个元素进行操作，效率可能会低，如果要转换一整列，使用上面提的 pd.to_datetime(df[‘key’])。</li><li>pandas 的列操作最好不要使用 map filter 等高阶函数，pandas 有提供 apply() 函数，参考<a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.apply.html" target="_blank" rel="noopener">这里</a>。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将主要总结 Python 库 Pandas 的一些常用操作和一些坑&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.superyoung.win/tags/Python/"/>
    
      <category term="Pandas" scheme="http://blog.superyoung.win/tags/Pandas/"/>
    
      <category term="DataFrame" scheme="http://blog.superyoung.win/tags/DataFrame/"/>
    
      <category term="Series" scheme="http://blog.superyoung.win/tags/Series/"/>
    
  </entry>
  
  <entry>
    <title>人工神经网络</title>
    <link href="http://blog.superyoung.win/2017/04/26/learning_data_analysis_with_python/about_ann/"/>
    <id>http://blog.superyoung.win/2017/04/26/learning_data_analysis_with_python/about_ann/</id>
    <published>2017-04-26T14:09:27.000Z</published>
    <updated>2018-09-02T13:20:41.244Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>So the LORD God formed the man from the dust of the ground, breathed life into his lungs, and the man became a living being.</p></blockquote><p>本文主要介绍笔者在进行数学建模时使用的神经网络和机器学习的部分内容。</p><a id="more"></a><h1 id="0x00-关于人工神经网络和人工神经元"><a href="#0x00-关于人工神经网络和人工神经元" class="headerlink" title="0x00 关于人工神经网络和人工神经元"></a>0x00 关于人工神经网络和人工神经元</h1><p>在机器学习和认知科学领域，人工神经网络（英文：artificial neural network，缩写ANN），简称神经网络（英文：neural network，缩写NN）或类神经网络，是一种模仿生物神经网络（动物的中枢神经系统，特别是大脑）的结构和功能的数学模型或计算模型，可以用于对函数进行估计或近似。神经网络由大量的人工神经元联结进行计算。大多数情况下人工神经网络能在外界信息的基础上改变内部结构，是一种自适应系统。现代神经网络是一种非线性统计性数据建模工具。</p><p><img src="/images/data_analysis/Ncell.png" alt="人工神经元示意图"></p><p>上图是一个人工神经元的示意图，而一个人工神经网络就是许多人工神经元进行分层地互相连接，像这样：<br><img src="/images/data_analysis/ann.png" alt="人工神经网络示意图"></p><p>人工神经元的数学表示可以是这样：<br><img src="/images/data_analysis/math_expression.png" alt="人工神经元的数学表达式"></p><blockquote><p>其中 <code>W&#39;</code> 是权重向量，<code>A</code> 是输入向量，<code>b</code> 是偏置值，<code>f</code> 是激活函数</p></blockquote><p>可以看到，一个神经元的功能是求得输入向量与权向量的内积后，经一个非线性激活函数得到一个标量结果。从理论上一个三层的神经网络可以拟合任意函数。</p><p>还可以这样看神经元的作用：把一个n维的向量空间用一个超平面分成两部分（称之为判断边界），给定一个输入向量，神经元可以判断出这个向量位于超平面的哪一边。<br>那么它的数学表达式就可以写成这样：<br><img src="/images/data_analysis/math_expression_hyperplane.png" alt="人工神经元的超平面表示"></p><blockquote><p>其中，<code>W</code> 是权重向量的转置，<code>b</code> 是偏置值，<code>p</code> 是超平面向量</p></blockquote><p>既可以从数学的角度看待人工神经网络，也可以从仿生学的角度看待人工神经网络。从数学角度看，人工神经网络就是一个很好用的非线性拟合工具，除了结构上的特点以外没有什么更特别的地方，而从仿生学角度看待的话，人工神经网络是一种能让计算机逼近人类智能的工具。本文可能将会将两者结合着来看待人工神经网络，看看能不能有一些新的感悟或者发现。</p><h1 id="0x01-典型的神经网络具有以下三个主要组成部分"><a href="#0x01-典型的神经网络具有以下三个主要组成部分" class="headerlink" title="0x01 典型的神经网络具有以下三个主要组成部分"></a>0x01 典型的神经网络具有以下三个主要组成部分</h1><ul><li><strong>结构（Architecture）</strong> 结构指定了网络中的变量和它们的拓扑关系。例如，神经网络中的变量可以是神经元连接的权重（weights）和神经元的激励值（activities of the neurons）。</li><li><strong>激活函数（Activity Rule）</strong> 大部分神经网络模型具有一个短时间尺度的动力学规则，来定义神经元如何根据其他神经元的活动来改变自己的激励值。一般激活函数依赖于网络中的权重（即该网络的参数）。</li><li><strong>学习规则（Learning Rule）</strong> 学习规则指定了网络中的权重如何随着时间推进而调整。这一般被看做是一种长时间的动力学规则。一般情况下，学习规则依赖于神经元的激励值。它也可能依赖于监督者提供的目标值和当前权重的值。现在较常用的就是误差反向传播方法。而误差的计算里面，损失函数的确定又是必不可少的。</li></ul><p>接下来就每一个部分进行详细介绍</p><h1 id="0x02-关于结构"><a href="#0x02-关于结构" class="headerlink" title="0x02 关于结构"></a>0x02 关于结构</h1><p>一种常见的结构：多层前馈网络（Multilayer Feedforward Network）由三部分组成，</p><ul><li><strong>输入层（Input layer）</strong> ，输入层的神经元（Neuron）接受输入值，称为输入向量。</li><li><strong>输出层（Output layer）</strong> ，输入向量在神经网络中传输、分析、权衡，形成输出结果。输出的消息称为输出向量。</li><li><strong>隐藏层（Hidden layer）</strong> ，或者称为“隐含层”，是输入层和输出层之间多个神经元组成的层次。隐层可以有很多层。隐层的节点（神经元）数目不定，但数目越多神经网络的非线性越显著，从而神经网络的鲁棒性（robustness）（控制系统在一定结构、大小等的参数摄动下，维持某些性能的特性。）更显著。<br>神经网络的类型已经演变出很多种，这种分层的结构也并不是对所有的神经网络都适用。<br>结构方面主要注意层数和各层节点数即可，数值的确定有一些经验法则可以用，但是往往效果并不是很好，具体数值还是要依靠多次的试验来确定。</li></ul><h1 id="0x03-关于激活函数"><a href="#0x03-关于激活函数" class="headerlink" title="0x03 关于激活函数"></a>0x03 关于激活函数</h1><p>激活函数可以理解为就是在每个人工神经元外包裹的那层函数。为什么要有激活函数存在呢？因为 <code>W*x + b</code> 仍然是线性的，再用一个线性或者非线性的函数做一次变换往往可以更好地拟合非线性的目标函数。激活函数在需要的时候可以自定义，当然常用的激活函数也有很多，这里主要介绍一下最近用过的几个常用激活函数：</p><ol><li><p>logisitic sigmoid function<br><img src="/images/data_analysis/sigmoid_function.png" alt="logisitic sigmoid function"><br>其定义域在(0,1)之间。</p></li><li><p>softmax function<br>是 sigmoid 函数的一般形式，它能将一个含任意实数的K维的向量 <strong>Z</strong> “压缩”到另一个K维实向量 <strong>σ(Z)</strong> ，使得每一个元素的范围都在(0, 1)之间，并且所有元素的和为1。</p></li><li><p>tanh function<br>tanh 全称双曲正切函数 hyperbolic tangent，可以看做是 logisitic sigmoid 函数在 y 取值为 (-1, 1) 上的版本<br>其函数表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tanh(x)=2⋅σ(2x)−1</span><br><span class="line">其中</span><br><span class="line">σ(x)=ex/(1+ex)</span><br></pre></td></tr></table></figure></li><li><p>Softplus &amp; ReLU function<br>Softplus 是 sigmoid 函数的原函数，是由 Charles Dugas 等人在2001年提出来的，其函数数学表达式：Softplus(x)=log(1+e^x)<br>而 ReLU 的全称是线性整流函数 Rectified Linear Unit (ReLU)，是一个定义在(0, 1)之间的函数，其在 <code>x&lt;0</code> 部分取值为0，而 <code>x&gt;0</code> 的部分为线性函数，他们的图像如下所示：<br><img src="/images/data_analysis/Rectifier_and_softplus_functions.png" alt="Softplus_ReLU"></p></li></ol><p>这里主要讲讲 ReLU 函数，ReLU 函数对于训练深层神经网络很有优势，它相比于 tanh 和 logisitic sigmoid 等的优点在于：</p><ol><li>单侧激活性：当 <code>x&lt;0</code> 时神经元不会被激活，这和真实的神经元表现相近，也因为这个，使用了 ReLU 做激活函数的神经网络的神经元激活率比较低，相比于 sigmoid 系的激活函数 ReLU 和真实的神经元更相似。</li><li>更有效的梯度传递：不会有梯度爆炸和梯度消失的问题</li><li>计算效率高：激活部分是线性函数</li></ol><p>ReLU 函数还有一些优化版本：</p><ol><li>一种是 leaky ReLU：就是当 <code>x&lt;0</code> 时 y 不是取 0，而是取一个负的线性函数的值。</li><li>另一种是 random leaky ReLU：当 <code>x&lt;0</code> 时 y 不是取 0，和上面的一样取一个负的线性函数的值，再加上一个满足正态分布的随机项。</li></ol><p>以上两种优化版的 ReLU 函数在 <code>x&gt;0</code> 时和普通的 ReLU 一样都是线性函数，只是避免了在 <code>x&lt;0</code> 时信息丢失的问题。</p><h1 id="0x04-关于学习规则"><a href="#0x04-关于学习规则" class="headerlink" title="0x04 关于学习规则"></a>0x04 关于学习规则</h1><p>学习规则就是告诉神经网络需要以什么规则来进行学习。学习规则可以被认为由损失函数和优化算法来组成。<br>首先介绍一下损失函数，所谓损失函数也被称为误差函数，是一种表示预测值和实际值误差的函数，通常可以用交叉熵（常用于分类）或者均方差（常用于回归）来表示。<br>还有优化算法，是用来寻找最优解的方法，通常有梯度下降法等。<br>接下来最主要的就是误差反向传播算法，关于什么是误差反向传播可以参考这篇文章：<a href="http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop.html" target="_blank" rel="noopener">用误差反向传播方法训练神经网络</a><br>一句话概括来说，误差的反向传播是一种可以通过优化各层权重值和偏置值从而求出损失函数最优解的方法。</p><p>OK，上面只是简简单单的介绍了一下一些最重要的知识点，关于这些知识点的更详细的介绍可以看看 Andrew Ng 在 StandFord 大学的公开课，讲得很清楚。Andrew Ng 公开课的实践部分主要是使用 Matlab 或者 Octave，而接下来的本文呢，将介绍一下 Python 上的机器学习库：Keras 和 TensorFlow。</p><h1 id="0x05-使用-Keras-训练一个人工神经网络"><a href="#0x05-使用-Keras-训练一个人工神经网络" class="headerlink" title="0x05 使用 Keras 训练一个人工神经网络"></a>0x05 使用 Keras 训练一个人工神经网络</h1><p>首先简单介绍一下 Keras。 Keras 是一个经过高层次抽象的人工神经网络框架，使用 python 编写，可以使用 TensorFlow 作为后端。它封装了一些方法来供用户调用，对于初学者来说构建网络十分方便快捷，构建网络的代码如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> Nadam</span><br><span class="line"><span class="keyword">import</span> keras.backend <span class="keyword">as</span> K</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 定义网络类型，此处为全连接型</span></span><br><span class="line">model = Sequential()</span><br><span class="line"></span><br><span class="line">filename = <span class="string">'my_model'</span></span><br><span class="line">activation_name = <span class="string">'ReLU'</span></span><br><span class="line">model.add(Dense(units=<span class="number">36</span>, input_dim=x_train.shape[<span class="number">1</span>], activation=activation_name))</span><br><span class="line">model.add(Dense(units=<span class="number">18</span>, activation = activation_name))</span><br><span class="line">model.add(Dense(units=<span class="number">1</span>, activation = <span class="string">'softmax'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 模型编译，指定 loss 就是上面提到的损失函数，而优化算法为 Nadam</span></span><br><span class="line">model.compile(loss=<span class="string">'mean_squared_error'</span>, optimizer=Nadam())</span><br><span class="line"><span class="comment"># # 模型训练，指定输入和输出、训练次数、以及分批训练时每批的数据量大小</span></span><br><span class="line">model.fit(x_train, y_train, epochs=<span class="number">618</span>, batch_size=<span class="number">61940</span>)</span><br><span class="line"><span class="comment"># # 保存模型</span></span><br><span class="line">model.save(filename+<span class="string">".h5"</span>)</span><br><span class="line"><span class="comment"># # 如果后端是 tf 的话，也可以保存神经网络的 TF 计算图</span></span><br><span class="line">tf.train.write_graph(K.get_session().graph_def, path, filename+<span class="string">".pb"</span>, <span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><p></p><p>只需要上面这几行代码，我们就训练出了一个神经网络，而网络的训练的具体效果，可以通过下面的函数来查看：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># # 指定测试集，使用上面定义的损失函数来评估网络的效果</span></span><br><span class="line">score = model.evaluate(x_test, y_test, batch_size=<span class="number">10000</span>)</span><br></pre></td></tr></table></figure><p></p><p>看看，核心代码只是 model.add 和 model.compile 和 model.fit 三步而已。<br>训练后的网络，通过 model.predict 就可以获取它的输出，而再用一个函数封装一下，就可以作为一个函数来使用。同时，因为一个训练好的网络已经自动提取了特征，我们可以通过输出它的权重值来分析输入和输出之间的关系，而不需要像以前一样自己多次地猜测和实验。<br>构建一个网络本来就不应该是难事，现在有 Keras 和 TensorFlow 这类工具，构建网络就更简单了。现在的难题是：数据获取和特诊提取。</p><h1 id="0x06-Python-常用的训练数据预处理工具"><a href="#0x06-Python-常用的训练数据预处理工具" class="headerlink" title="0x06 Python 常用的训练数据预处理工具"></a>0x06 Python 常用的训练数据预处理工具</h1><p><code>scikit-learn</code> 是一个基于 Numpy、Scipy 和 matplotlib 的机器学习库。其中包含了常用的数据预处理库 <code>Preprocessing</code>，例子如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing <span class="keyword">as</span> preproc</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 使用 preprocessing.train_test_spilt 来产生一组训练集和测试集</span></span><br><span class="line"><span class="comment"># 其中 data 是一个 numpy 数组</span></span><br><span class="line">X_train, X_test, y_train, y_test = preproc.train_test_split(data, labels, test_size=<span class="number">0.3</span>, random_state=<span class="number">47</span>)</span><br><span class="line">np.save(np_save + <span class="string">"X_train.npy"</span>, X_train)</span><br><span class="line">np.save(np_save + <span class="string">"X_test.npy"</span>, X_test)</span><br><span class="line">np.save(np_save + <span class="string">"y_train.npy"</span>, y_train)</span><br><span class="line">np.save(np_save + <span class="string">"y_test.npy"</span>, y_test)</span><br><span class="line">np.save(np_save + <span class="string">"X_total.npy"</span>, data)</span><br><span class="line">np.save(np_save + <span class="string">"y_total.npy"</span>, labels)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：此时数据不会被标准化，所以后期在使用数据的时候需要调用标准化方法</span></span><br><span class="line">x_train = np.load(np_save + <span class="string">"X_train.npy"</span>)</span><br><span class="line">y_train = np.load(np_save + <span class="string">"y_train.npy"</span>)</span><br><span class="line">x_test = np.load(np_save + <span class="string">"X_test.npy"</span>)</span><br><span class="line">y_test = np.load(np_save + <span class="string">"y_test.npy"</span>)</span><br><span class="line">x_total = np.load(np_save + <span class="string">"X_total.npy"</span>)</span><br><span class="line">y_total = np.load(np_save + <span class="string">"y_total.npy"</span>)</span><br><span class="line">scaler_x = preproc.MinMaxScaler().fit(x_total)</span><br><span class="line">x_train = scaler_x.transform(x_train)</span><br><span class="line">x_test = scaler_x.transform(x_test)</span><br><span class="line">scaler_y = preproc.MinMaxScaler().fit(y_total)</span><br><span class="line">y_train = scaler_y.transform(y_train)</span><br><span class="line">y_test = scaler_y.transform(y_test)</span><br></pre></td></tr></table></figure><p></p><p>神经网络并不是万能的，通常说来有一些和问题相关性很强的技术难点，这些需要自己克服。<br>好了，本期的介绍大致到这里，去 Kaggle 或者随便哪里找个数据集练练手吧，试一下你就知道难点在哪里了。</p><h1 id="0x07-一些强烈推荐的相关资料"><a href="#0x07-一些强烈推荐的相关资料" class="headerlink" title="0x07 一些强烈推荐的相关资料"></a>0x07 一些强烈推荐的相关资料</h1><p><a href="http://ufldl.stanford.edu/wiki/index.php/Main_Page" target="_blank" rel="noopener">Ufldl</a><br><a href="https://hit-scir.gitbooks.io/neural-networks-and-deep-learning-zh_cn/" target="_blank" rel="noopener">神经网络和深度学习</a><br><a href="http://open.163.com/special/opencourse/machinelearning.html" target="_blank" rel="noopener">斯坦福大学公开课：机器学习课程</a><br><a href="https://keras.io/" target="_blank" rel="noopener">Keras Documentation</a><br><a href="http://scikit-learn.org/" target="_blank" rel="noopener">scikit-learn</a><br><a href="https://www.tensorflow.org/" target="_blank" rel="noopener">TensorFlow</a><br><a href="https://blog.keras.io/keras-as-a-simplified-interface-to-tensorflow-tutorial.html" target="_blank" rel="noopener">Keras as a simplified interface to TensorFlow</a><br><a href="http://playground.tensorflow.org" target="_blank" rel="noopener">A Neural Network Playground for Visually Understanding ANN</a></p><h2 id="关于卷积神经网络的简单介绍"><a href="#关于卷积神经网络的简单介绍" class="headerlink" title="关于卷积神经网络的简单介绍"></a>关于卷积神经网络的简单介绍</h2><p><a href="https://www.zhihu.com/question/39022858" target="_blank" rel="noopener">知乎上的讨论</a><br><a href="http://scs.ryerson.ca/~aharley/vis/conv/" target="_blank" rel="noopener">卷积神经网络对于 MNIST 数据集的分层可视化</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;So the LORD God formed the man from the dust of the ground, breathed life into his lungs, and the man became a living being.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;本文主要介绍笔者在进行数学建模时使用的神经网络和机器学习的部分内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.superyoung.win/tags/Python/"/>
    
      <category term="神经网络" scheme="http://blog.superyoung.win/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="机器学习" scheme="http://blog.superyoung.win/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="优化" scheme="http://blog.superyoung.win/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="ReLU" scheme="http://blog.superyoung.win/tags/ReLU/"/>
    
  </entry>
  
  <entry>
    <title>数据分析——数据预处理</title>
    <link href="http://blog.superyoung.win/2017/04/09/learning_data_analysis_with_python/about_data_preprocessing/"/>
    <id>http://blog.superyoung.win/2017/04/09/learning_data_analysis_with_python/about_data_preprocessing/</id>
    <published>2017-04-09T01:40:53.000Z</published>
    <updated>2018-09-02T13:21:57.484Z</updated>
    
    <content type="html"><![CDATA[<p>本文的主要内容是笔者在进行数学建模分析数据时遇到的预处理问题以及解决方案。</p><p>本文预先假定读者熟悉 python 和其中的 pandas 框架，如果不熟悉看看官方文档就好。</p><a id="more"></a><h1 id="0x00-总览"><a href="#0x00-总览" class="headerlink" title="0x00 总览"></a>0x00 总览</h1><p>拿到一堆数据，显而易见，首先要对数据进行一些观察，比如说查看分布情况、查看是否有缺失或异常值、是否有噪声等等；以及处理，比如说处理异常值和缺失值、对数据进行降噪等等……</p><p>观察到需要处理的值后，就要确定处理的方法</p><ul><li>缺失值的处理一般有拟合、回归算法（可以参考图像处理中的插值以及核回归算法）。</li><li>异常值的处理一般分成大类有：物理判别法和统计判别法，物理判别法就是指人为按照经验划定一条线，超过这条线的则认定为异常值，所以物理判别法这里不讲，主要讲讲统计判别法。</li><li>噪声的处理可以用：傅里叶变换（空间域-&gt;频率域）、小波变换（空间域-&gt;时频域）后滤波来实现，一般以小波滤波为优先。</li></ul><p>而笔者因为在写这篇文章的时候，面对的情况是不需要处理缺失值的，所以还没有具体尝试过处理缺失值的情况。因此这篇文章主要介绍的是：处理异常值和降噪。</p><h1 id="0x01-异常值的统计判别法"><a href="#0x01-异常值的统计判别法" class="headerlink" title="0x01 异常值的统计判别法"></a>0x01 异常值的统计判别法</h1><p>使用统计判别法的时候有两个要注意的点：</p><ol><li>去真：将本来属于该总体的、出现的概率小的、第二种情况的异常值判断出来舍去，就会犯错误。</li><li>存伪：不属于该总体但数值又和该总体平均值接近的数据被抽样抽出来，统计检验方法判断不出它是异常值，就会犯另一种错误。</li></ol><p>常用的统计判别法：</p><ul><li>拉依达准则</li><li>肖维勒准则</li><li>狄克逊准则</li><li>t检验(罗马诺夫斯基准则)</li><li>格拉布斯准则</li></ul><p>接下来分别进行详细介绍：</p><h3 id="拉依达准则"><a href="#拉依达准则" class="headerlink" title="拉依达准则"></a>拉依达准则</h3><p>其依据是，总体分布为正态分布的数据，其数据 <code>P( |x-u| &gt; 3𝝈 ) &lt; 0.003</code><br>u 为期望，𝝈 为标准差</p><p>所以，拉依达准则只需要计算当前值和期望的差是否大于3倍的标准差即可，非常简单。但是这个方法对数据为正态分布的要求比较高，而且不能检验样本量较小的情 况。所以后来使用较少。</p><ul><li>肖维勒准则 <code>|vi| = |x - u| &gt; Zc 𝝈</code><br>Zc是一个与测量次数相关的系数，可以查表获取。<br>改善了拉依达准则，但是因为没有固定的概率意义，后来使用得也比较少。</li></ul><p>对了这里介绍一下，关于异常值和是否需要剔除的常用标准（具体标准 的还是要按照数据来）</p><blockquote><p>与平均值的偏差超过三倍标准差的测定值，称为高度异常的异常值。在处理数据时，应剔除高度异常的异常值。异常值是否剔除，视具体情况而定。在统计检验时，指定为检出异常值的显著性水平α=0.05，称为检出水平；指定为检出高度异常的异常值的显著性水平α=0.01，称为舍弃水平，又称剔除水平(reject level)。</p></blockquote><h3 id="狄克逊准则"><a href="#狄克逊准则" class="headerlink" title="狄克逊准则"></a>狄克逊准则</h3><p>狄克逊准则是通过极差比判定和剔除异常数据。又称为 Q 检验法。<br>该准则认为异常数据应该是最大数据和最小数据，因此该其基本方法是将数据排序，检验最大数据和最小数据是否异常数据。</p><ul><li>其操作步骤是：<ol><li>排序</li><li>计算 f = (x(n)-x(n-1)) / (x(n)-x(1)) 或者 (x(2)-x(1)) / (x(n)-x(1))</li><li>根据狄克逊系数表，将 f 和 f(n, α)比较，若 f &gt; f(n, α) 则判定为异常数据<br>思路可以，但是如果离群值点有多个并且相近的话，比较难用这个方法处理。</li></ol></li></ul><h1 id="t-检验"><a href="#t-检验" class="headerlink" title="t 检验"></a>t 检验</h1><p>t检验准则与狄克逊准则相似，也是检验最大数据和最小数据。</p><ul><li>步骤：<ol><li>排序</li><li>对最大数据和最小数据分别计算 |x-u| ，如果 &gt; K(n, α)𝝈 则。判定为异常数据</li><li>注意其中的 u 和 𝝈 是不包括最大和最小值的均值和标准差，K(n, α) 也通过查表得到。</li></ol></li></ul><h3 id="格拉布斯准则"><a href="#格拉布斯准则" class="headerlink" title="格拉布斯准则"></a>格拉布斯准则</h3><p>格拉布斯准则是在未知总体标准差情况下，对正态样本或接近正态样本异常值的一种判别方法。<br>格拉布斯准则理论较严密，概率意义明确，可用于严格要求的场合，特别的，当n=20-100时，判别效果较好。</p><ul><li>其原理是：<br>某个测量值的残余误差 <code>|vi|= | x - u | &gt; T 𝝈</code> ，则判断此值中含有较大误差, 应予剔除。<br>T 值与重复测量次数 n 和置信概率 α 均有关，因此格拉布斯准则是比较好的判定准则。T 值可通过查表得到</li><li>采用格拉布斯方法判定异常数据的过程如下:<ol><li>选定危险率α<br>α是一个较小的百分数，例如1%，2.5%，5%，它 是采用格拉布斯方法判定异常数据出现误判的几率。</li><li>计算T值<br>如果x是可疑数据，则令 T = (x-u)/𝝈<br>格拉布斯准则有开源的 python 库，已经实现了其算法，我们可以直接用<br>首先安装该库：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install outliers_util</span><br></pre></td></tr></table></figure></li></ol></li></ul><p>然后在 Python 代码中做如下操作<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> outliers <span class="keyword">import</span> smirnov_grubbs <span class="keyword">as</span> grubbs</span><br><span class="line"><span class="comment"># 1. 处理并且返回剔除后的结果集合</span></span><br><span class="line">result = grubbs.test(data_list, alpha=<span class="number">0.998</span>)</span><br><span class="line"><span class="comment"># 2. 处理并且返回异常值的 index 集合</span></span><br><span class="line">result_index = []</span><br><span class="line">result_index.append(grubbs.two_sided_test_indices(data_list, alpha=<span class="number">0.998</span>))</span><br><span class="line"><span class="comment">#    使用 append() 的时候，返回值将是一个嵌套列表，故将其压平</span></span><br><span class="line">result_index = sum(result_index, [])</span><br></pre></td></tr></table></figure><p></p><h1 id="0x02-噪声的处理"><a href="#0x02-噪声的处理" class="headerlink" title="0x02 噪声的处理"></a>0x02 噪声的处理</h1><p>一般情况小波降噪即可达到需要的程度，而且可以通过参数进行细致的调节。python 小波变换一般使用 pywt 库：</p><ul><li><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install PyWavelets</span><br></pre></td></tr></table></figure></li><li><p>import</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pywt</span><br><span class="line"><span class="comment"># 单层分解的话，可以使用官方文档 tutorial 中提到的函数：</span></span><br><span class="line">pywt.dwt()</span><br><span class="line"><span class="comment"># 而进行多层分解的话，使用下面的函数</span></span><br><span class="line">coeff = pywt.wavedec()</span><br><span class="line"><span class="comment"># 重构使用waverec()</span></span><br><span class="line">result = pywt.waverec()</span><br></pre></td></tr></table></figure></li></ul><p>以上函数具体的自己上官方手册查咯，这里不赘述了。</p><h3 id="小波降噪的步骤："><a href="#小波降噪的步骤：" class="headerlink" title="小波降噪的步骤："></a>小波降噪的步骤：</h3><ol><li><p>小波函数的选择</p><ol><li><p>正交性：</p><p>保持小波系数间的不相关性，提高除噪性能</p></li><li><p>紧支撑性：</p><p>紧支撑宽度越小，小波的局部分辨能力越好，除噪越精细</p></li><li><p>消失矩：</p><p>消失矩的特性使小波展开时消去信号的高阶平滑部分，因而小波变换只反映函数的高阶变换部分，从而反映信号奇异性的能力强。</p></li><li><p>对称性：</p><p>越对称的小波，在经过小波变换后，其偏差可能越小，因而有利于除噪后信号的恢复和重建。</p><p>因此，dbN(即Daubechies系列小波)、symN(Symlets系列小波)、coifN(Coiflet系列小波)这些系列的小波都可多做考量。</p></li></ol></li><li><p>阈值的确定</p><p>阈值的确定主要有以下几条准则：</p><ol><li><p>无偏风险估计准则(rigrsure)</p><p>基于Stein的无偏似然估计原理的自适应阈值选择方法。对每个阈值求出对应的风险值，选取风险最小的阈值。</p></li><li><p>固定阈值准则(sqtwolog)</p><p>设n为小波系数向量长度，则对应的阈值为：<code>Tr = sqrt(2*log(n))</code></p></li><li><p>混合准则(heursure)</p><p>它是rigrsure和sqtwolog准则的混合，当信噪比很低时，rigrsure准则估计有很大噪声，这时采用固定阈值。其阈值计算方法为：首先判断两个变量 Eta 和 Crit 的大小</p></li><li><p>极大极小准则(minimaxi)</p></li></ol></li><li><p>分解层次的确定</p><ul><li>根据多分辨率分析理论，高层分解的小波系数对应的是低频部分，而低频部分主要由信号构成。因此分解层次越高，去掉的低频成分越多，去噪效果越明显，但失真度也增大。为保守起见，分解层次不宜太高，最大不超过5层。对波动性更强的序列如收益序列，一般不超过3层。</li></ul></li></ol><h3 id="小波降噪实例（Python-实现）"><a href="#小波降噪实例（Python-实现）" class="headerlink" title="小波降噪实例（Python 实现）"></a>小波降噪实例（Python 实现）</h3><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wt</span><span class="params">(data, keyname, wavefunc, level, m, n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    小波降噪函数</span></span><br><span class="line"><span class="string">    - level: 分解层数；</span></span><br><span class="line"><span class="string">    - data: 保存列表类型的字典；</span></span><br><span class="line"><span class="string">    - keyname: 键名；</span></span><br><span class="line"><span class="string">    - index_list: 待处理序列；</span></span><br><span class="line"><span class="string">    - wavefunc: 选取的小波函数；</span></span><br><span class="line"><span class="string">    - m,n 选择进行阈值处理的小波系数层数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 分解</span></span><br><span class="line">    coeff = pywt.wavedec(data[keyname], wavefunc, mode=<span class="string">'sym'</span>, level=level)</span><br><span class="line">    <span class="comment"># 设置 sgn 函数</span></span><br><span class="line">    sgn = <span class="keyword">lambda</span> x: <span class="number">1</span> <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">-1</span> <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 降噪过程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m, n + <span class="number">1</span>):  <span class="comment"># 选取小波系数层数为 m~n 层</span></span><br><span class="line">        cD = coeff[i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(cD)):</span><br><span class="line">            Tr = np.sqrt(<span class="number">2</span> * np.log(len(cD)))  <span class="comment"># 计算阈值</span></span><br><span class="line">            <span class="keyword">if</span> cD[j] &gt;= Tr:</span><br><span class="line">                coeff[i][j] = sgn(cD[j]) - Tr  <span class="comment"># 使用 sgn 函数向零收缩</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                coeff[i][j] = <span class="number">0</span>  <span class="comment"># 低于阈值置零</span></span><br><span class="line">    <span class="comment"># 重新构建</span></span><br><span class="line">    denoised_data_list = my_wave_rec(coeff, wavefunc, data[keyname])</span><br><span class="line">    <span class="comment"># 为了避免出现负值的情况，取绝对值</span></span><br><span class="line">    abs_denoised_list = list(map(<span class="keyword">lambda</span> x: abs(x), denoised_data_list))</span><br><span class="line">    <span class="comment"># 返回降噪结果</span></span><br><span class="line">    <span class="keyword">return</span> abs_denoised_list</span><br></pre></td></tr></table></figure></code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>中国科学技术大学统计与金融系 - 金百锁副教授的课件： <a href="http://staff.ustc.edu.cn/~jbs/chapt3.pdf" target="_blank" rel="noopener">第三章统计数据的预处理</a></li><li>优矿 - fyiqi： <a href="https://uqer.io/community/share/57175736228e5b82757f53e2" target="_blank" rel="noopener">时间序列的小波去噪</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文的主要内容是笔者在进行数学建模分析数据时遇到的预处理问题以及解决方案。&lt;/p&gt;&lt;p&gt;本文预先假定读者熟悉 python 和其中的 pandas 框架，如果不熟悉看看官方文档就好。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.superyoung.win/tags/Python/"/>
    
      <category term="异常值" scheme="http://blog.superyoung.win/tags/%E5%BC%82%E5%B8%B8%E5%80%BC/"/>
    
      <category term="缺失值" scheme="http://blog.superyoung.win/tags/%E7%BC%BA%E5%A4%B1%E5%80%BC/"/>
    
      <category term="噪声" scheme="http://blog.superyoung.win/tags/%E5%99%AA%E5%A3%B0/"/>
    
      <category term="小波" scheme="http://blog.superyoung.win/tags/%E5%B0%8F%E6%B3%A2/"/>
    
      <category term="降噪" scheme="http://blog.superyoung.win/tags/%E9%99%8D%E5%99%AA/"/>
    
  </entry>
  
  <entry>
    <title>关闭 macOS 的 Spotlight 功能</title>
    <link href="http://blog.superyoung.win/2017/03/27/learning_macos_command/disable_spotlight_in_macos/"/>
    <id>http://blog.superyoung.win/2017/03/27/learning_macos_command/disable_spotlight_in_macos/</id>
    <published>2017-03-27T07:17:44.000Z</published>
    <updated>2018-10-16T07:52:36.031Z</updated>
    
    <content type="html"><![CDATA[<p>有时候 macOS 的 Spotlight 索引功能会占用太多系统资源，特别是在对磁盘频繁操作的时候，这种情况下，关闭 Spotlight 索引功能是个不错的选择。有两个办法可以关闭 Spotlight 索引功能，一个是使用系统偏好设置，将整个磁盘或者文件夹添加到不检查列表中。另外一个是使用命令行关闭索引功能… 第一种方法请参考Apple的帮助手册，下面主要介绍命令行的方法。</p><a id="more"></a><h2 id="Turn-off-indexing："><a href="#Turn-off-indexing：" class="headerlink" title="Turn off indexing："></a>Turn off indexing：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> turn off for all volumes:</span><br><span class="line">sudo mdutil -a -i off</span><br><span class="line"><span class="meta">#</span> turn off for specific volumes:</span><br><span class="line">sudo mdutil -i off "/Volumes/Machintosh\ HD" # change it to whatever you need</span><br><span class="line"><span class="meta">#</span> turn on for all volumes:</span><br><span class="line">sudo mdutil -a -i on</span><br></pre></td></tr></table></figure><blockquote><p>FYI: In macOS High Sierra, it will not be able to unload metadata, the use of <code>mdutil</code> command only should be enough. But I’ll just leave it here for a future demand.</p></blockquote><h3 id="unload-metadata"><a href="#unload-metadata" class="headerlink" title="unload metadata:"></a>unload metadata:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> unload</span><br><span class="line">sudo launchctl unload -w /System/Library/LaunchDaemons/com.apple.metadata.mds.plist</span><br><span class="line"><span class="meta">#</span> load</span><br><span class="line">sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.metadata.mds.plist</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候 macOS 的 Spotlight 索引功能会占用太多系统资源，特别是在对磁盘频繁操作的时候，这种情况下，关闭 Spotlight 索引功能是个不错的选择。有两个办法可以关闭 Spotlight 索引功能，一个是使用系统偏好设置，将整个磁盘或者文件夹添加到不检查列表中。另外一个是使用命令行关闭索引功能… 第一种方法请参考Apple的帮助手册，下面主要介绍命令行的方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="macOS" scheme="http://blog.superyoung.win/tags/macOS/"/>
    
      <category term="Spotlight" scheme="http://blog.superyoung.win/tags/Spotlight/"/>
    
      <category term="OS X" scheme="http://blog.superyoung.win/tags/OS-X/"/>
    
  </entry>
  
  <entry>
    <title>在 Shell 中把错误信息重定向输出到文件</title>
    <link href="http://blog.superyoung.win/2017/03/23/learning_bash/redirect_gcc_error_output_to_file/"/>
    <id>http://blog.superyoung.win/2017/03/23/learning_bash/redirect_gcc_error_output_to_file/</id>
    <published>2017-03-23T05:19:34.000Z</published>
    <updated>2018-10-16T07:38:23.796Z</updated>
    
    <content type="html"><![CDATA[<p>在 shell 中把错误信息重定向输出到文件，使用 <code>2&gt;</code><br><a id="more"></a></p><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> compile and output error messages to log file:</span><br><span class="line">    g++ -o a *.cpp &gt; build.log 2&gt; build.log</span><br></pre></td></tr></table></figure><ul><li>所有使用了错误输出流（而不是标准输出流）来输出错误信息的控制台程序都需要使用 <code>2&gt;</code> 来重定向。直接使用 <code>&gt;</code> 会重定向标准输出流，一般来说标准输出流不会包含任何错误信息。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 shell 中把错误信息重定向输出到文件，使用 &lt;code&gt;2&amp;gt;&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.superyoung.win/tags/Linux/"/>
    
      <category term="Shell" scheme="http://blog.superyoung.win/tags/Shell/"/>
    
      <category term="GNU" scheme="http://blog.superyoung.win/tags/GNU/"/>
    
      <category term="GCC" scheme="http://blog.superyoung.win/tags/GCC/"/>
    
      <category term="G++" scheme="http://blog.superyoung.win/tags/G/"/>
    
      <category term="Redirect" scheme="http://blog.superyoung.win/tags/Redirect/"/>
    
      <category term="log" scheme="http://blog.superyoung.win/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 5.5 中 DATE, DATETIME 和 TIMESTAMP 的异同</title>
    <link href="http://blog.superyoung.win/2017/03/20/learning_mysql/difference_date_datetime_timestamp/"/>
    <id>http://blog.superyoung.win/2017/03/20/learning_mysql/difference_date_datetime_timestamp/</id>
    <published>2017-03-20T03:10:15.000Z</published>
    <updated>2018-03-21T02:31:50.215Z</updated>
    
    <content type="html"><![CDATA[<p>都是用来表示日期和时间的，这三者究竟有什么不同呢？<br>这篇文章介绍了 MySQL 中<code>DATE</code>, <code>DATETIME</code> 和 <code>TIMESTAMP</code> 的相似点和不同点。</p><a id="more"></a><h2 id="三者简介"><a href="#三者简介" class="headerlink" title="三者简介"></a>三者简介</h2><p><code>DATE</code> 类型被用作表示日期，而不包括时间部分。 MySQL 用’YYYY-MM-DD’格式检索和展示 DATE 值。支持范围从’1000-01-01’到’9999-12-31’</p><p><code>DATETIME</code> 类型用来保存日期和时间。MySQL 以’YYYY-MM-DD HH:MM:SS’ 格式处理DATETIME 类型。范围从’1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’</p><p><code>TIMESTAMP</code> 类型也用来表示时间和日期。 TIMESTAMP 表示范围是：‘1970-01-01 00:00:01’ 到 ‘2038-01-19 03:14:07’ UTC。</p><h2 id="TIMESTAMP"><a href="#TIMESTAMP" class="headerlink" title="TIMESTAMP"></a>TIMESTAMP</h2><h3 id="自动进行时区转换"><a href="#自动进行时区转换" class="headerlink" title="自动进行时区转换"></a>自动进行时区转换</h3><p>MySQL 在存储 TIMESTAMP 格式的值的时候，会把它从当前时区转换成 UTC 时区，然后在处理的时候把它从 UTC 时区转换回当前时区。而其他类型（比如 DATETIME）不会发生这样的转换。默认情况下，每个链接的当前时区是服务器所在的时区。但是每个链接可以自定义自己的时区。只要时区设置是同一个常数，你就可以获取到你存入的准确时间。注意：如果你在存入 TIMESTAMP 值后更改了时区，再取回数据，这些被取回的数据将会和你存入的不同。详情参见 <a href="https://dev.mysql.com/doc/refman/5.5/en/time-zone-support.html" target="_blank" rel="noopener">Section 10.6, “MySQL Server Time Zone Support”</a></p><h3 id="自动初始化和更新"><a href="#自动初始化和更新" class="headerlink" title="自动初始化和更新"></a>自动初始化和更新</h3><p><code>TIMESTAMP</code> 可以自动初始化和更新当前日期和时间。具体来说，在建表时通过 <code>DEFAULT CURRENT_TIMESTAMP</code>、<code>ON UPDATE CURRENT_TIMESTAMP</code> 来控制是否自动初始和自动更新。详情参见 <a href="https://dev.mysql.com/doc/refman/5.5/en/timestamp-initialization.html" target="_blank" rel="noopener">Section 11.3.5, “Automatic Initialization and Updating for TIMESTAMP”</a></p><h3 id="精确度：DATETIME-和-TIMESTAMP-一致，小数点后六位"><a href="#精确度：DATETIME-和-TIMESTAMP-一致，小数点后六位" class="headerlink" title="精确度：DATETIME 和 TIMESTAMP 一致，小数点后六位"></a>精确度：DATETIME 和 TIMESTAMP 一致，小数点后六位</h3><p><code>DATETIME</code> 或者 <code>TIMESTAMP</code> 值可以在尾部包含小数形式的秒，精确到毫秒级（6位）。虽然这些小数部分可以被识别，但是在存储入 DATETIME 或者 TIMESTAMP 的字段中的时候会被丢弃。</p><h2 id="无效值处理：三者一致"><a href="#无效值处理：三者一致" class="headerlink" title="无效值处理：三者一致"></a>无效值处理：三者一致</h2><p>无效的 DATE，DATETIME 或者 TIMESTAMP 值将会被转换成对应类型的 “零” （’0000-00-00’ or ‘0000-00-00 00:00:00’）。</p><h2 id="注意这些特殊情况："><a href="#注意这些特殊情况：" class="headerlink" title="注意这些特殊情况："></a>注意这些特殊情况：</h2><ul><li><p>MySQL 支持一些 “便利格式”。利用分隔符，即使类型不匹配，在一些情况下这种便利语法也可以被接受。比如，一个 <code>&#39;10:11:12</code> 可能因为 <code>:</code> 看起来像时间，但是如果被存入一个日期字段，它会被转换成对应的日期 <code>2010-11-12</code> 。而如果把值 <code>&#39;10:45:15&#39;</code> 存入<code>日期</code>字段，它将会被转换成 <code>&#39;0000-00-00&#39;</code> 再存入，因为 ‘45’ 不是一个有效的月份值。</p></li><li><p>服务器验证月份和日期的有效性的时候，不会仅仅验证1-12和1-31。在关闭严格模式（strict mode）的时候，不正确的值（’2004-04-31’）将会被转换成’0000-00-00’存入数据库，并伴随着一个警告。而当打开严格模式的时候，将不会存入，并产生一个错误。而如果你要让服务器接受这样不正确的值，你需要打开 <code>ALLOW_INVALID_DATES</code>。</p></li><li><p>MySQL 不接受包含 0 的或者无效的 TIMESTAMP 值。唯一的例外是 ‘0000-00-00 00:00:00’</p></li><li><p><code>CAST()</code> 会把 TIMESTAMP 转换成字符串。详情参见 <a href="https://dev.mysql.com/doc/refman/5.7/en/cast-functions.html" target="_blank" rel="noopener">Section 12.10, “Cast Functions and Operators”</a></p></li><li><p>当不指定年份的前两位的时候，为了避免二义性，MySQL 将会这样做：</p><ol><li>00-69 将会被转化为 2000-2069</li><li>70-99 将会被转化为 1970-1999</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;都是用来表示日期和时间的，这三者究竟有什么不同呢？&lt;br&gt;这篇文章介绍了 MySQL 中&lt;code&gt;DATE&lt;/code&gt;, &lt;code&gt;DATETIME&lt;/code&gt; 和 &lt;code&gt;TIMESTAMP&lt;/code&gt; 的相似点和不同点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://blog.superyoung.win/tags/MySQL/"/>
    
      <category term="DATE" scheme="http://blog.superyoung.win/tags/DATE/"/>
    
      <category term="DATETIME" scheme="http://blog.superyoung.win/tags/DATETIME/"/>
    
      <category term="TIMESTAMP" scheme="http://blog.superyoung.win/tags/TIMESTAMP/"/>
    
      <category term="Difference" scheme="http://blog.superyoung.win/tags/Difference/"/>
    
  </entry>
  
  <entry>
    <title>使用 Which 命令查看当前执行的命令所在路径</title>
    <link href="http://blog.superyoung.win/2017/03/20/learning_bash/determined_which_command_your_are_running/"/>
    <id>http://blog.superyoung.win/2017/03/20/learning_bash/determined_which_command_your_are_running/</id>
    <published>2017-03-20T02:43:01.000Z</published>
    <updated>2018-10-16T07:44:35.769Z</updated>
    
    <content type="html"><![CDATA[<p>有时候可能需要知道某个命令执行的程序所在的具体路径，特别是当你的程序有多个版本的时候，接下来要介绍的这个命令就非常重要了。<br>这个命令就是 which 命令，简单来说，其用法为： <code>which [-as] program</code></p><a id="more"></a><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> man which</span><br><span class="line"></span><br><span class="line">WHICH(1)             BSD General Commands Manual             WHICH(1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">     which -- locate a program file in the user\'s path</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">     which [-as] program ...</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">     which 工具接收一个或几个命令名字，然后搜索每个可执行文件的路径</span><br><span class="line"></span><br><span class="line">     The following options are available:</span><br><span class="line"></span><br><span class="line">     -a      列出所有可执行文件，而不是只列出第一个可执行文件（可以用来查看已安装的某个应用的所有版本）</span><br><span class="line"></span><br><span class="line">     -s      无输出，当可执行文件存在的时候返回 `0`，不存在的时候返回 `1`。</span><br></pre></td></tr></table></figure><p>通常可以与 <code>ls -ahGl</code> 整合使用，比如：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -ahGl $(which python)</span><br></pre></td></tr></table></figure><p></p><p>如果把 <code>ls -ahGl</code> 使用 alias 替换的话，将会更简洁<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias l="ls -ahGl"</span><br><span class="line">l $(which python)</span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候可能需要知道某个命令执行的程序所在的具体路径，特别是当你的程序有多个版本的时候，接下来要介绍的这个命令就非常重要了。&lt;br&gt;这个命令就是 which 命令，简单来说，其用法为： &lt;code&gt;which [-as] program&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.superyoung.win/tags/Linux/"/>
    
      <category term="Shell" scheme="http://blog.superyoung.win/tags/Shell/"/>
    
      <category term="Command" scheme="http://blog.superyoung.win/tags/Command/"/>
    
      <category term="Path" scheme="http://blog.superyoung.win/tags/Path/"/>
    
      <category term="which" scheme="http://blog.superyoung.win/tags/which/"/>
    
  </entry>
  
  <entry>
    <title>使用 Matlab Parfor 高效计算位平面图</title>
    <link href="http://blog.superyoung.win/2017/03/11/learning_matlab/caculate_bit_plane_picture/"/>
    <id>http://blog.superyoung.win/2017/03/11/learning_matlab/caculate_bit_plane_picture/</id>
    <published>2017-03-11T02:05:57.000Z</published>
    <updated>2018-04-19T08:01:35.966Z</updated>
    
    <content type="html"><![CDATA[<p>bit-plane，就是将一张图按照各个比特位来切分以后的图，每一张位面图都是二值图。<br>为了避免与游戏中的名词<code>位面图</code>混淆，可以把bit-plane翻译成<code>位平面图</code>，而且这样更好理解。</p><p>本文章记录了使用 Matlab2016a 计算一张图的位平面图过程，以及并行功能使用过程中的一些要点。<br>Matlab 的并行工具使用起来还算简单，效率也高，按照本人<code>1.3 GHz Intel Core i5</code>测试的结果加速比大概有 1.5。</p><a id="more"></a><h2 id="废话不多说，直接上代码和注释"><a href="#废话不多说，直接上代码和注释" class="headerlink" title="废话不多说，直接上代码和注释"></a>废话不多说，直接上代码和注释</h2><ol><li><p>首先初始化 Matlab 并行池：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% parallel pool initialization</span></span><br><span class="line">CoreNum = <span class="number">2</span>; <span class="comment">% core number of you computer</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isempty</span>(gcp(<span class="string">'nocreate'</span>))</span><br><span class="line">    parpool(<span class="string">'local'</span>, CoreNum);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">'parallel pool is already initialized'</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>读取图像，并初始化用于保存结果的变量：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% read the image by path</span></span><br><span class="line">im = imread(<span class="string">'/Users/yjm/Desktop/_MG_0403.jpg'</span>);</span><br><span class="line"><span class="comment">% show the original image</span></span><br><span class="line">figure, subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>), imshow(im);</span><br><span class="line">im = double(im);</span><br><span class="line"><span class="comment">% get the size</span></span><br><span class="line">[height, width, dropped] = <span class="built_in">size</span>(im);</span><br><span class="line"><span class="comment">% initialize the result matrix</span></span><br><span class="line">onesbitmap = <span class="built_in">ones</span>(height, width);</span><br><span class="line">result = [];</span><br></pre></td></tr></table></figure></li><li><p>开始计算：</p><blockquote><p>这里用的是 parfor 并行计算工具，用来代替原本的普通 for 循环：</p></blockquote></li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% start caculation</span></span><br><span class="line">tic <span class="comment">% 计时开始</span></span><br><span class="line"><span class="keyword">parfor</span> v = <span class="number">1</span> : <span class="number">8</span></span><br><span class="line">    tic</span><br><span class="line">    bitmap = <span class="built_in">ones</span>(height, width);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : height</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span> : width</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">mod</span>(<span class="built_in">floor</span>(im(<span class="built_in">i</span>,<span class="built_in">j</span>)/(<span class="number">2</span>^(v<span class="number">-1</span>))), <span class="number">2</span>) == <span class="number">0</span></span><br><span class="line">                bitmap(<span class="built_in">i</span>, <span class="built_in">j</span>) = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                bitmap(<span class="built_in">i</span>, <span class="built_in">j</span>) = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    result = [result bitmap]; <span class="comment">% append bitmap to result</span></span><br><span class="line">    toc</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">toc <span class="comment">% 计时结束</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的代码中有三大要点：</p><ol start="0"><li>注意 parfor 循环中使用的变量只有两种情况：要么是局部变量，要么需要在 parfor 外分配好内存空间。并且尽量避免使用全局变量，可能会导致并行过程中的信息交换拖慢运行速度。</li><li>最内层循环的判断句 <code>if mod(floor(im(i,j)/(2^(v-1))), 2) == 0</code>，这是计算位平面图的核心算法。 自己改写成数学公式以后会很容易理解的。</li><li>其次是 <code>result = [result bitmap];</code>，这句话是把本次循环后计算出来的值增加到结果变量的最后面。</li></ol></blockquote><ol start="3"><li>展示结果：<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% show the result</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="number">8</span></span><br><span class="line">    <span class="comment">% show the bit-plane images, from  column  (i-1)*width+1 to i*width</span></span><br><span class="line">    subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="built_in">i</span>+<span class="number">1</span>), imshow(result(<span class="number">1</span>: height, (<span class="built_in">i</span><span class="number">-1</span>)*width+<span class="number">1</span> : <span class="built_in">i</span>*width))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意这里要自己计算出结果变量中的各个图像的边界，Matlab 不会自动把那些图像分开。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;bit-plane，就是将一张图按照各个比特位来切分以后的图，每一张位面图都是二值图。&lt;br&gt;为了避免与游戏中的名词&lt;code&gt;位面图&lt;/code&gt;混淆，可以把bit-plane翻译成&lt;code&gt;位平面图&lt;/code&gt;，而且这样更好理解。&lt;/p&gt;&lt;p&gt;本文章记录了使用 Matlab2016a 计算一张图的位平面图过程，以及并行功能使用过程中的一些要点。&lt;br&gt;Matlab 的并行工具使用起来还算简单，效率也高，按照本人&lt;code&gt;1.3 GHz Intel Core i5&lt;/code&gt;测试的结果加速比大概有 1.5。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Matlab" scheme="http://blog.superyoung.win/tags/Matlab/"/>
    
      <category term="Bit-plane" scheme="http://blog.superyoung.win/tags/Bit-plane/"/>
    
      <category term="Digital" scheme="http://blog.superyoung.win/tags/Digital/"/>
    
      <category term="Image" scheme="http://blog.superyoung.win/tags/Image/"/>
    
      <category term="Processing" scheme="http://blog.superyoung.win/tags/Processing/"/>
    
      <category term="Parallel" scheme="http://blog.superyoung.win/tags/Parallel/"/>
    
      <category term="parfor" scheme="http://blog.superyoung.win/tags/parfor/"/>
    
  </entry>
  
  <entry>
    <title>搭建你自己的 SVN 服务器</title>
    <link href="http://blog.superyoung.win/2017/03/03/version_controller/setup_svn_server/"/>
    <id>http://blog.superyoung.win/2017/03/03/version_controller/setup_svn_server/</id>
    <published>2017-03-03T15:00:39.000Z</published>
    <updated>2017-03-11T02:05:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>SVN 全称：<a href="https://subversion.apache.org" target="_blank" rel="noopener">Apache™ Subversion®</a> ，是一个开源的 <code>Enterprise-class centralized version control for the masses</code> 企业级中心化版本控制器。区分于 Git，它不是分布式的而是中心化的，在过去十年中也挺成功。但是在 Git 出现之后，它的光环就有点暗淡了。</p><p>好，闲话不多说，本教程将会教你如何搭建自己的 SVN 服务器</p><a id="more"></a><p>可以看看<a href="/images/set_up_svn_server/index.html">简洁版</a></p><h2 id="0x00-准备"><a href="#0x00-准备" class="headerlink" title="0x00 准备"></a>0x00 准备</h2><ol><li>你需要一台运行 Linux 或者 Unix 系列系统的计算机，并且你有其管理员权限</li><li>你需要有一个正常的网络连接</li><li>macOS 系统中请先安装 brew 包管理器</li></ol><p>本教程将以 macOS 为示例。</p><h2 id="0x01-安装-SVN"><a href="#0x01-安装-SVN" class="headerlink" title="0x01 安装 SVN"></a>0x01 安装 SVN</h2><ol><li>执行下述命令：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> CentOS</span></span><br><span class="line">sudo yum install svn</span><br><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu</span></span><br><span class="line">sudo apt-get install svn</span><br><span class="line"><span class="meta">#</span><span class="bash"> macOS</span></span><br><span class="line">brew install svn</span><br></pre></td></tr></table></figure></li></ol><p>结果如下图：<br><img src="/images/setup_svn_server/01.png" alt="图1"></p><h2 id="0x02-建立-Repository"><a href="#0x02-建立-Repository" class="headerlink" title="0x02 建立 Repository"></a>0x02 建立 Repository</h2><p>执行下述命令：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这条命令进入一个目录</span></span><br><span class="line">cd ~/testsvn/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这条命令将会在当前目录下新建一个 Repository</span></span><br><span class="line">svnadmin create test</span><br></pre></td></tr></table></figure><p></p><p>结果如下图：<br><img src="/images/setup_svn_server/02.png" alt="图2"></p><h1 id="0x03-配置-Repository"><a href="#0x03-配置-Repository" class="headerlink" title="0x03 配置 Repository"></a>0x03 配置 Repository</h1><p>键入以下命令：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改 conf 路径下的 svnserve.conf 文件</span></span><br><span class="line">vi conf/svnserve.conf</span><br></pre></td></tr></table></figure><p></p><p>此时就通过 vi 打开你的<code>svnserve.conf</code>配置文件了，找到 [general] 块，你将会看到整个 general 都被注释掉了，<code>###</code> 的是介绍，<code>#</code>的是被注释掉的配置项，可以作为例子。</p><p>这里用中文翻译一下介绍吧：<br>|字段|解释|可选值|<br>|—|—|—|<br>|anon-access|控制未授权用户的权限|write、read、none|<br>|auth-access|控制已授权用户的权限|write、read、none|<br>|password-db|控制密码数据库的位置（以<code>/</code>开头为绝对路径，否则是相对路径）；<br>如果 SASL 被启用，这个文件将不会被使用。|passwd 代表默认数据库|<br>|authz-db|控制“基于路径的访问控制”数据库的位置；<br>指定的路径可能是一个与 repository 相对路径 URL <code>^/</code> 或者是一个绝对路径 URL <code>file://</code> 指向一个在 Subversion Repository 中的文本文件；<br>如果不指定，则不会有基于路径的访问控制。|authz 代表默认数据库|<br>|groups-db|控制“群组定义和每个群组的权限”文件的位置；<br>groups-db 文件和 authz-db 文件格式相同，并且groups-db应该包含一个[groups]块；<br>不过如果开启了这个选项，authzdb 文件中奖不能包含 [groups] 块。|<br>|realm|指定存储库的认证领域，他们应该有同一个密码数据库，反之亦然；<br>默认的 realm 是 repository 的 uuid|<br>|force-username-case|控制SVNServer在按照authz-db指定的规则比较用户名之前转换大小写。|upper、lower、none|<br>|hooks-env|指定一个路径到 hood script 环境配置文件，这个选项会覆盖 per-repository 的默认值，并且可以用来在单个文件中配置有多个 repositories 情况下的 hood script 环境|</p><p>介绍完以后，我们这样修改一下svnserve.conf：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[general]</span><br><span class="line">anon-access = none</span><br><span class="line">auth-access = write</span><br><span class="line">password-db = passwd</span><br><span class="line">authz-db = authz</span><br></pre></td></tr></table></figure><p></p><p>接下来修改 conf 下的 passwd 文件，添加两个用户名和密码，在[users] 块中加入以下内容：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root = root@Svnserver</span><br><span class="line">ysy = userysy</span><br></pre></td></tr></table></figure><p></p><p>然后修改 conf 下的 authz 文件：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[groups]</span><br><span class="line">admin = root # 注意这里的</span><br><span class="line">user = ysy</span><br><span class="line">[/]</span><br><span class="line">@admin = rw</span><br><span class="line">@user = r</span><br><span class="line">[test: /]</span><br><span class="line">@admin = rw</span><br><span class="line">@user = r</span><br></pre></td></tr></table></figure><p></p><p>这里首先定义了两个用户组，一个是 root，另一个是 user。</p><p>admin 中有 root 这个用户；user 中有 ysy 这个用户。然后分别给他们配置路径权限。</p><p>值得注意的是<code>[/]</code>指 testsvn 目录，而<code>[test: /]</code>指 test 目录。</p><p>基本的配置到这里已经完成，理论上我们可以启动我们的 SVN 服务器了。</p><p>但是为了安全起见，还有些事情可以做，比如说使用 <code>chown -R</code> / <code>chmod -R</code> 命令控制一下 svntest 目录的所有者和权限之类的，</p><h2 id="0x04-启动服务器"><a href="#0x04-启动服务器" class="headerlink" title="0x04 启动服务器"></a>0x04 启动服务器</h2><p>执行以下命令：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 注意：下面的 --<span class="built_in">log</span>-file=不能使用`~`来指定当前用户的 home 目录</span></span><br><span class="line">sudo svnserve -d -r ~/testsvn --log-file=./log/svn.log</span><br></pre></td></tr></table></figure><p></p><p>SVN 默认使用的端口是3690，如果没冲突，这样 SVN 服务器就成功启动了。</p><p>可以用 less 命令查看上面命令指定的 log 文件，也可以像这样测试是否启动成功：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 使用 ps 命令查看进程</span></span><br><span class="line">ps aux | grep svnserve</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 使用 Telnet 测试连接</span></span><br><span class="line">telnet localhost 3690</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 使用 svn 客户端测试连接</span></span><br></pre></td></tr></table></figure><p></p><h2 id="0x05-创建目录结构并导入到-SVN-Repository-中"><a href="#0x05-创建目录结构并导入到-SVN-Repository-中" class="headerlink" title="0x05 创建目录结构并导入到 SVN Repository 中"></a>0x05 创建目录结构并导入到 SVN Repository 中</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/tmp/svntmp/;</span><br><span class="line">cd ~/tmp/svntmp/;</span><br><span class="line">mkdir master dev ysy;</span><br><span class="line">cd ../../;</span><br><span class="line">svn import --username root -m 'init repo' ~/tmp/svntmp/ svn://localhost/test</span><br></pre></td></tr></table></figure><p>输入用户名密码，大功告成！<br><img src="/images/setup_svn_server/03.png" alt="图3"></p><blockquote><p>如果有任何问题，可以通过 <code>--help</code> 参数来查看：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 svn 的帮助信息</span></span><br><span class="line">svn --help</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 svn import 的帮助信息</span></span><br><span class="line">svn import --help</span><br></pre></td></tr></table></figure><p></p></blockquote><h2 id="0x06-最后推荐几款-GUI-的-SVN-客户端"><a href="#0x06-最后推荐几款-GUI-的-SVN-客户端" class="headerlink" title="0x06 最后推荐几款 GUI 的 SVN 客户端"></a>0x06 最后推荐几款 GUI 的 SVN 客户端</h2><ol><li>首先肯定是是跨平台的开源的 TortoiseSVN</li><li>如果在 macOS 下想有更好的体验，特别是在处理冲突或者合并源码的时候，强烈推荐 Cornerstone。</li></ol><blockquote><p>macOS 为了安全起见，默认是不允许运行苹果白名单以外签名的 app 的，运行则会报告此安装包已损坏。所以如果在 macOS 中需要运行未知来源的 app，需要输入以下命令解锁：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo xattr -rd com.apple.quarantine /Applications/theApplication.app</span><br></pre></td></tr></table></figure><p></p></blockquote><p>下图是 Cornerstone 的运行结果：<br><img src="/images/setup_svn_server/04.png" alt="图4"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SVN 全称：&lt;a href=&quot;https://subversion.apache.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Apache™ Subversion®&lt;/a&gt; ，是一个开源的 &lt;code&gt;Enterprise-class centralized version control for the masses&lt;/code&gt; 企业级中心化版本控制器。区分于 Git，它不是分布式的而是中心化的，在过去十年中也挺成功。但是在 Git 出现之后，它的光环就有点暗淡了。&lt;/p&gt;&lt;p&gt;好，闲话不多说，本教程将会教你如何搭建自己的 SVN 服务器&lt;/p&gt;
    
    </summary>
    
    
      <category term="Server" scheme="http://blog.superyoung.win/tags/Server/"/>
    
      <category term="Tutorial" scheme="http://blog.superyoung.win/tags/Tutorial/"/>
    
      <category term="Guide" scheme="http://blog.superyoung.win/tags/Guide/"/>
    
      <category term="服务器" scheme="http://blog.superyoung.win/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="教程" scheme="http://blog.superyoung.win/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="配置" scheme="http://blog.superyoung.win/tags/%E9%85%8D%E7%BD%AE/"/>
    
      <category term="SVN" scheme="http://blog.superyoung.win/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>建立你自己的 Matlab 远程计算服务器</title>
    <link href="http://blog.superyoung.win/2017/03/02/learning_matlab/setup_yourself_a_remote_matlab_computation_server/"/>
    <id>http://blog.superyoung.win/2017/03/02/learning_matlab/setup_yourself_a_remote_matlab_computation_server/</id>
    <published>2017-03-02T01:44:40.000Z</published>
    <updated>2018-01-16T04:01:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实原理很简单，借助 ssh 服务和 Matlab 应用的二进制可执行文件即可。<br>缺点也有，不能直接显示图像处理或者绘图结果，但是可以在服务器上通过保存图片，再下载来查看。</p><a id="more"></a><h2 id="0x00-Requirement"><a href="#0x00-Requirement" class="headerlink" title="0x00 Requirement"></a>0x00 Requirement</h2><ol><li>你需要一台能够直接访问互联网的服务器或者个人电脑</li><li>这台电脑上必须安装有 Matlab 应用和 ssh 服务。</li></ol><h2 id="0x01-Add-Matlab-Binary-to-your-PATH"><a href="#0x01-Add-Matlab-Binary-to-your-PATH" class="headerlink" title="0x01 Add Matlab Binary to your PATH"></a>0x01 Add Matlab Binary to your PATH</h2><p>本文以 macOS 为例子，Windows 或者 Linux 环境下请自行替换为对应目录</p><ol><li>找到你 Matlab 的安装路径，比如我这里是 <code>/Applications/MATLAB_R2016a.app</code></li><li>找到其中的 <code>bin</code> 文件夹，记录下其路劲，比如我的是 <code>/Applications/MATLAB_R2016a.app/bin</code></li><li><p>将路径加入系统环境变量的 <code>PATH</code> 中</p><ol><li><p>Unix 下可以编辑 <code>~/.bash_profile</code> 或者 <code>~/.bashrc</code> 或者 <code>~/.zshrc</code> 文件（请自行替换为终端启动时加载的文件），加入以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Setup Matlab2016a Environment</span></span><br><span class="line">export PATH="$PATH:/Applications/MATLAB_R2016a.app/bin"</span><br><span class="line">alias matlab='matlab -nodisplay -nosplash'</span><br></pre></td></tr></table></figure><p>然后 <code>source ~/.bash_profile</code> 即可。</p></li><li>Windows 下请自行搜索关键字 <code>系统环境变量</code>，找到 PATH 变量并 <code>加入</code> 上面的路径，用分号隔开不同路径。</li></ol></li></ol><h2 id="0x02-ALL-Done-login-to-your-ssh-server-and-run-matlab"><a href="#0x02-ALL-Done-login-to-your-ssh-server-and-run-matlab" class="headerlink" title="0x02 ALL Done, login to your ssh server and run matlab"></a>0x02 ALL Done, login to your ssh server and run <code>matlab</code></h2><p>完成了。登录你的 ssh 服务器即可远程使用 <code>matlab</code> 命令执行科学计算。</p><p>关于如何配置 ssh 服务器，本文不再赘述，这里引用 IBM 的一篇文章：<br><a href="https://www.ibm.com/developerworks/cn/aix/library/au-sshsecurity/index.html" target="_blank" rel="noopener">SSH 安全性和配置入门</a><br>和阮一峰的博文：<br><a href="http://www.ruanyifeng.com/blog/2014/03/server_setup.html" target="_blank" rel="noopener">Linux服务器的初步配置流程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实原理很简单，借助 ssh 服务和 Matlab 应用的二进制可执行文件即可。&lt;br&gt;缺点也有，不能直接显示图像处理或者绘图结果，但是可以在服务器上通过保存图片，再下载来查看。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Matlab" scheme="http://blog.superyoung.win/tags/Matlab/"/>
    
      <category term="Server" scheme="http://blog.superyoung.win/tags/Server/"/>
    
      <category term="Science" scheme="http://blog.superyoung.win/tags/Science/"/>
    
      <category term="Computation" scheme="http://blog.superyoung.win/tags/Computation/"/>
    
  </entry>
  
  <entry>
    <title>搭建自己的 Git 服务器教程</title>
    <link href="http://blog.superyoung.win/2017/02/28/version_controller/setup_git_server/"/>
    <id>http://blog.superyoung.win/2017/02/28/version_controller/setup_git_server/</id>
    <published>2017-02-28T10:37:41.000Z</published>
    <updated>2017-03-03T15:01:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>本教程关于如何搭建自己的 Git 服务器，使用 Keynote 制作<br><a id="more"></a></p><p>废话不多说，教程在此：<a href="/images/set_up_git_server/index.html">传送门</a></p><p><img src="/images/setup_git_server/00.png" alt="图1"><br><img src="/images/setup_git_server/01.png" alt="图2"><br><img src="/images/setup_git_server/02.png" alt="图3"><br><img src="/images/setup_git_server/03.png" alt="图4"><br><img src="/images/setup_git_server/04.png" alt="图5"><br><img src="/images/setup_git_server/05.png" alt="图6"><br><img src="/images/setup_git_server/06.png" alt="图7"><br><img src="/images/setup_git_server/07.png" alt="图8"><br><img src="/images/setup_git_server/08.png" alt="图9"><br><img src="/images/setup_git_server/09.png" alt="图10"><br><img src="/images/setup_git_server/10.png" alt="图10"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本教程关于如何搭建自己的 Git 服务器，使用 Keynote 制作&lt;br&gt;
    
    </summary>
    
    
      <category term="Server" scheme="http://blog.superyoung.win/tags/Server/"/>
    
      <category term="Git" scheme="http://blog.superyoung.win/tags/Git/"/>
    
      <category term="Tutorial" scheme="http://blog.superyoung.win/tags/Tutorial/"/>
    
      <category term="Guide" scheme="http://blog.superyoung.win/tags/Guide/"/>
    
      <category term="服务器" scheme="http://blog.superyoung.win/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="教程" scheme="http://blog.superyoung.win/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="配置" scheme="http://blog.superyoung.win/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
</feed>
