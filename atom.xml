<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tech. Design. Life.</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.superyoung.win/"/>
  <updated>2017-01-29T03:04:18.000Z</updated>
  <id>http://blog.superyoung.win/</id>
  
  <author>
    <name>Yu Shengyang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ARC Rules</title>
    <link href="http://blog.superyoung.win/2017/01/29/learning_iOS/ARC_Rules/"/>
    <id>http://blog.superyoung.win/2017/01/29/learning_iOS/ARC_Rules/</id>
    <published>2017-01-29T02:19:41.000Z</published>
    <updated>2017-01-29T03:04:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>ARC is summarized in Apple’s own words:</p><blockquote><p>ARC in Objective-C makes memory management the job of the compiler. By enabling ARC with the new Apple LLVM compiler, you will never need to type retain or release again, dramatically simplifying the development process, while reducing craches and memory leaks. The compiler has a complete understanding of your objects, and releases each object the instant it is no longer used, so apps run as fast as ever, with predictable, smooth performance.</p></blockquote><a id="more"></a><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Actually, reference counting is still used as the basis of ARC. But ARC helps the reference counting mechanism work automatically when you follow its rules.</p><h2 id="The-rules-of-Reference-Counting"><a href="#The-rules-of-Reference-Counting" class="headerlink" title="The rules of Reference Counting"></a>The rules of Reference Counting</h2><ul><li>You have ownership of any objects you create.</li><li>You can take ownership of an object using retain.</li><li>When you no longer need it, you must relinquish ownership of an object of which you have ownership.</li><li>You must not relinquish ownership of an object of which you don’t have ownership.</li></ul><h2 id="Newly-introduced-for-ARC-Ownership-Qualifier"><a href="#Newly-introduced-for-ARC-Ownership-Qualifier" class="headerlink" title="Newly introduced for ARC: Ownership Qualifier"></a>Newly introduced for ARC: Ownership Qualifier</h2><p>In Objective-C, ‘id’ or each object type is used for object variable types.</p><p>Object types are pointer types of Objective-C classes, such as NSObject <em>.’id’ type is used to hide its class name. ‘id’ is equivalent to void</em> in the C language.</p><p>With ARC, ‘id’ and object type variables must have one of the following four ownership qualifiers:<br></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> __<span class="keyword">strong</span></div><div class="line"><span class="number">2.</span> __<span class="keyword">weak</span></div><div class="line"><span class="number">3.</span> __<span class="keyword">unsafe_unretained</span></div><div class="line"><span class="number">4.</span> __autoreleasing</div></pre></td></tr></table></figure><p></p><p>You should decide which ownership qualifier is to be used for all the ‘id’ and object type variables in your source code. In this chapter, I explain hwo you should choos each qualifier one by one.</p><h3 id="strong-ownership-qualifier"><a href="#strong-ownership-qualifier" class="headerlink" title="__strong ownership qualifier"></a>__strong ownership qualifier</h3><p>The <strong>strong ownership qualifier is used as the default for ‘id’ and object types. It means that the variable obj in the following source code is </strong>strong qualified implicitly.<br></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>Without being explicitly qualified, ‘id’ or objects are treated as __strong. The above code is the same as:<br></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>The following is the same source code for a non-ARC environment.<br></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* non-ARC */</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">    [obj release];</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>This means the “release” method is automatically added on an ARC environment to release the created object with ownership.</p><p>We add comments on the ownership status:<br></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">    <span class="comment">/**</span></div><div class="line">    * The variable obj is qualified with __strong.</div><div class="line">    * Which means, it has the ownership of the object.</div><div class="line">    **/</div><div class="line">&#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">    * Leaving the scope of variable obj, its strong reference disappears.</div><div class="line">    * The object is release automatically,</div><div class="line">    * because no one has ownership, the objec is dispoed of.</div><div class="line">    */</div></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ARC is summarized in Apple’s own words:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;ARC in Objective-C makes memory management the job of the compiler. By enabling ARC with the new Apple LLVM compiler, you will never need to type retain or release again, dramatically simplifying the development process, while reducing craches and memory leaks. The compiler has a complete understanding of your objects, and releases each object the instant it is no longer used, so apps run as fast as ever, with predictable, smooth performance.&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://blog.superyoung.win/tags/iOS/"/>
    
      <category term="Programming" scheme="http://blog.superyoung.win/tags/Programming/"/>
    
      <category term="ARC" scheme="http://blog.superyoung.win/tags/ARC/"/>
    
      <category term="Rules" scheme="http://blog.superyoung.win/tags/Rules/"/>
    
      <category term="Objective C" scheme="http://blog.superyoung.win/tags/Objective-C/"/>
    
      <category term="Coming soon..." scheme="http://blog.superyoung.win/tags/Coming-soon/"/>
    
  </entry>
  
  <entry>
    <title>使用 GitHub Pages 搭建博客指南</title>
    <link href="http://blog.superyoung.win/2017/01/28/how_to_build_a_blog/blog_with_github_pages/"/>
    <id>http://blog.superyoung.win/2017/01/28/how_to_build_a_blog/blog_with_github_pages/</id>
    <published>2017-01-28T05:18:35.000Z</published>
    <updated>2017-01-28T16:19:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>个人使用 GitHub Pages 结合 Hexo 搭建静态网页博客的一点总结<br><a id="more"></a></p><p>为什么用 GitHub Pages 和 Hexo 等工具来搭建博客呢？为什么不用 WordPress？</p><ul><li><p>首先，仅仅为了一个博客，很多人可能并不想花资金到服务器上。一台服务器应该用来做些更有趣的事情 （不差钱的土豪请略过 ┑(￣Д ￣)┍。</p></li><li><p>其次很多人也不想花精力去维护一个博客系统。 WordPress 等框架虽然说成熟但是偶尔还是会爆出一些漏洞，如果说你不及时跟进，修复漏洞的话，可能会对在你博客下留言的人造成不好的影响。</p></li></ul><p>于是，静态网页生成器 ➕ 免费的静态网页展示工具就成了搭建博客的不二之选。</p><h2 id="借用-GitHub-Pages-搭建博客的原理"><a href="#借用-GitHub-Pages-搭建博客的原理" class="headerlink" title="借用 GitHub Pages 搭建博客的原理"></a>借用 GitHub Pages 搭建博客的原理</h2><p>GitHub Pages 是 GitHub 提供的一个静态网页展示器，可以将静态的文本按照网页的形式来展示，静态文本内容将会存储在你指定的 repo 中。</p><p>在这个指南中，我将会展示如何通过静态网页生成器 Hexo 将 <code>.md</code> 文件转换成网页。</p><h2 id="开启-Pages"><a href="#开启-Pages" class="headerlink" title="开启 Pages"></a>开启 Pages</h2><p>新建一个 repo （也可以使用旧的），在 setting 中找到 GitHub Pages 设置项，开启 GitHub Pages。按照指引一步步走完，你的静态展示页面就搭建完成了。</p><p>GitHub 一般会建议使用 jkeyll 来做 .md 文件到 .html 文件的转换，但是我这里使用的是 Hexo，因为首先它的作者是中国台湾人，社区比较本土化，资料也比较容易找。</p><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>要安装 Hexo 的话，首先要安装 Node.js 和 Git<br>Node.js 的安装很简单：<br>macOS：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install node</div></pre></td></tr></table></figure><p></p><p><em>详情请见：<a href="https://nodejs.org/en/download/package-manager/" target="_blank" rel="external">Installing Node.js via package manager</a></em></p><p>Git 的安装，额，如果看文章的您还没装 Git 的话 <del>（该面壁了）</del> 。 Git 的安装过程和node.js类似，不再赘述。</p><p>然后使用 <code>npm</code> 包管理器来 在本机安装 Hexo<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-cli -g</div></pre></td></tr></table></figure><p></p><p>接下来你的电脑应该可以使用 Hexo 这个命令了，好，那么找到一个适合的目录，执行<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo init blog;</div><div class="line"><span class="built_in">cd</span> blog;</div><div class="line">npm install;</div></pre></td></tr></table></figure><p></p><p>这几条命令将会在当前目录下新建一个名为 blog 的目录，再将 hexo 需要的初始化文件放 clone 到这个目录中。</p><p>如果你想直接看效果的话，执行以下命令启动服务器<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo s</div></pre></td></tr></table></figure><p></p><p>此时在 localhost:4000 中应该可以看到 Hello World 了。</p><h2 id="关于配置文件-config-yml"><a href="#关于配置文件-config-yml" class="headerlink" title="关于配置文件 _config.yml"></a>关于配置文件 _config.yml</h2><p>分别有 Site, URl, Directory, Writting, Category &amp; tag, Date format, Pagination, Extensions, Atom/RSS conf, Deployment 的配置信息。大部分自行配置即可。</p><p>这里需要注意一下时区，不是填写 “+8” / “+08:00” 之类的时区，而是填写<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" target="_blank" rel="external">时区列表</a>中的一项，中国是蒙古时区，故应该填写 <code>MN</code>。</p><p><em>详情请参见：<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">Hexo 配置</a></em></p><h2 id="如何写文章？"><a href="#如何写文章？" class="headerlink" title="如何写文章？"></a>如何写文章？</h2><p>很简单，在 <code>source/_post/</code> 中新建 .md 文件就可以了，如果不想自己手动新建的话，可以执行<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new filename</div></pre></td></tr></table></figure><p></p><p>执行上述操作后再生成静态网页，执行：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo g</div></pre></td></tr></table></figure><p></p><blockquote><p>建议文件名使用英文，因为文件名将作为博客文章链接的一部分，如果使用中文可能导致不便。</p></blockquote><h2 id="关于-Front-matter"><a href="#关于-Front-matter" class="headerlink" title="关于 Front-matter"></a>关于 Front-matter</h2><p>参数都很容易理解，这里要说的是，tags 的分词，使用的是一下这两种语法，而不是空格或者什么<br></p><figure class="highlight md"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tags:</div><div class="line"><span class="bullet">- </span>myTag0</div><div class="line"><span class="bullet">- </span>myTag1</div></pre></td></tr></table></figure><p></p><p>OR<br></p><figure class="highlight md"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tags:[myTag0, myTag1]</div></pre></td></tr></table></figure><p></p><p><em>详情请参见：<a href="https://hexo.io/zh-cn/docs/front-matter.html" target="_blank" rel="external">Front-matter</a></em></p><h2 id="关于图片"><a href="#关于图片" class="headerlink" title="关于图片"></a>关于图片</h2><p>官方的关于 Asset 文件夹，无法成功应用，原因未知。反而是按照 md 语法的 <code>![ title ]( href )</code> 起了作用。</p><p>在 <code>source/</code> 目录下新建 <code>iamges/</code> 目录用来保存图片，然后在文章中这样引用<br></p><figure class="highlight md"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![<span class="string">example</span>](<span class="link">/images/example.jpg</span>)</div></pre></td></tr></table></figure><p></p><p>注意，如果使用这个办法，不能 _config.yml 中的 <code>relative_link</code> 必须为 <code>false</code></p><p><em>详情请参见：<a href="https://hexo.io/zh-cn/docs/asset-folders.html" target="_blank" rel="external">资源文件夹</a></em></p><h2 id="关于主题"><a href="#关于主题" class="headerlink" title="关于主题"></a>关于主题</h2><p>主题文件保存在 themes 中，在这个目录下 clone 他人提供的 hexo 主题项目下来，或者自己根据模板自行更改。</p><p>然后在 <code>_config.yml</code> 的 <code>theme:</code> 中输入主题文件夹名字</p><p>详情请参见：<br><em><a href="https://hexo.io/zh-cn/docs/themes.html" target="_blank" rel="external">Hexo 主题</a></em><br><em><a href="https://hexo.io/zh-cn/docs/templates.html" target="_blank" rel="external">Hexo 模板</a></em></p><h2 id="关于个人域名"><a href="#关于个人域名" class="headerlink" title="关于个人域名"></a>关于个人域名</h2><p>设置个人域名的时候，需要首先在域名服务商那里设置 CNAME （别名）记录，将 CNAME 设置成 <em>用户名.github.io</em></p><p>然后在 repo 的 setting 中填写自己的域名。</p><h2 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h2><p>上面的操作都是在本机上的，怎么发布呢？</p><p>官方给的答案是执行命令： <code>hexo g; hexo d</code>，而我比较喜欢原生态一点的东西，使用 shell 命令结合 git 也可以完美解决发布问题。</p><p>原理如下：<code>hexo g</code> 生成的的文件都在 <code>public/</code> 目录下，所以，如果要发布，只需要将 public 目录提交到正确的 GitHub repo 上去就可以了。</p><p>我的办法是：</p><ol><li>首先在 GitHub 中 clone 那个 repo 到一个新建的 deploy 目录下</li><li>然后使用如下 shell 命令来提交（保存成.sh文件方便下次执行）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 设置shell可以识别感叹号（为了设置 rm 命令的白名单）</span></div><div class="line">    <span class="built_in">shopt</span> <span class="_">-s</span> extglob</div><div class="line"><span class="comment"># 进入工作目录（改成自己的目录）</span></div><div class="line">    <span class="built_in">cd</span> ~/blog;</div><div class="line"><span class="comment"># 清除，重建</span></div><div class="line">    hexo clean; hexo g;</div><div class="line"><span class="comment"># 清理目录，保留 .git, README.md 和 CNAME 文件</span></div><div class="line">    <span class="built_in">cd</span> deploy/;</div><div class="line">    rm -rf ./!(.git|README.md|CNAME);</div><div class="line"><span class="comment"># 移动需要部署的文件</span></div><div class="line">    mv ../public/* ./;</div><div class="line"><span class="comment"># 部署</span></div><div class="line">    git add .; git commit -m <span class="string">"update"</span>; git push; <span class="built_in">exit</span>;</div></pre></td></tr></table></figure></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><em><a href="https://pages.github.com" target="_blank" rel="external">GitHub Pages</a></em><br><em><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">Hexo</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人使用 GitHub Pages 结合 Hexo 搭建静态网页博客的一点总结&lt;br&gt;
    
    </summary>
    
    
      <category term="GitHub" scheme="http://blog.superyoung.win/tags/GitHub/"/>
    
      <category term="Pages" scheme="http://blog.superyoung.win/tags/Pages/"/>
    
      <category term="blog" scheme="http://blog.superyoung.win/tags/blog/"/>
    
      <category term="hexo" scheme="http://blog.superyoung.win/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>中性灰磨皮以及细节增强</title>
    <link href="http://blog.superyoung.win/2017/01/27/PictureProcessing/50gray_buffing/"/>
    <id>http://blog.superyoung.win/2017/01/27/PictureProcessing/50gray_buffing/</id>
    <published>2017-01-27T14:32:36.000Z</published>
    <updated>2017-01-28T16:22:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>中性灰磨皮的基本步骤，其思路，还是 <code>D&amp;B</code><br><a id="more"></a></p><ol><li>使用图章等工具进行斑点的消除</li><li>新建一个颜色填充图层，填充50%灰色，设置图层混合模式为柔光</li><li>新建一个颜色填充图层，填充黑色，设置图层混合模式为颜色</li><li>新建一个颜色填充图层，填充黑色，设置图层混合模式为柔光</li><li>使用笔刷在中性灰图层更改高光和阴影，重绘所有需要重绘的地方</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中性灰磨皮的基本步骤，其思路，还是 &lt;code&gt;D&amp;amp;B&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Photoshop" scheme="http://blog.superyoung.win/tags/Photoshop/"/>
    
      <category term="修图" scheme="http://blog.superyoung.win/tags/%E4%BF%AE%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你Rx响应式开发 - 响应式应用开发极简入门教程</title>
    <link href="http://blog.superyoung.win/2017/01/25/learning_iOS/Reactive-Programming/"/>
    <id>http://blog.superyoung.win/2017/01/25/learning_iOS/Reactive-Programming/</id>
    <published>2017-01-25T07:47:23.000Z</published>
    <updated>2017-01-29T02:27:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>很多面向对象的开发人员都遇到过这样的问题：软件开发过程中，需要开发人员主动地告诉系统什么东西改变了，以此来触发响应。</p><p>那有人就会想，如果有一个办法可以让系统自动发现状态的改变，是不是更好呢？</p><p>这就引出了响应式开发最基本的概念……<br><a id="more"></a></p><p><em>原文在此：[Getting Started With RxSwift and RxCocoa </em>by Ellen Shapiro on October 17, 2016<em>](<a href="https://www.raywenderlich.com/138547/getting-started-with-rxswift-and-rxcocoa" target="_blank" rel="external">https://www.raywenderlich.com/138547/getting-started-with-rxswift-and-rxcocoa</a>)</em></p><p><img src="/images/Programming/rx_logo.png" alt="ReactiveX Logo"></p><h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><p>很多面向对象的开发人员都遇到过这样的问题：软件开发过程中，需要开发人员主动地告诉系统什么东西改变了，以此来触发响应。</p><p>那有人就会想，如果有一个办法可以让系统自动发现状态的改变，是不是更好呢？</p><p>这就引出了响应式开发最基本的概念：你的应用可以对状态直接进行响应而不需要开发人员参与。这种开发方式可以让开发人员更加专注于逻辑的表达而不是如何对状态进行保存。</p><p>在 iOS 中可以使用 Objc 和 Swift 的 KVO 和 didSet 等方法，但是有时候啊这些方法可能就显得太笨重了，Objc 和 Swift 均有不同的响应式框架来解决这个问题。这里主要介绍的是 swift 的 RxSwift 框架。</p><p><a href="https://www.raywenderlich.com/126522/reactivecocoa-vs-rxswift" target="_blank" rel="external">如果你想知道更多的背景信息，关于各大主流框架的区别， <em>Rui Peres</em> 写了一篇文章</a></p><h2 id="0x01-什么是-RxSwift-和-RxCocoa"><a href="#0x01-什么是-RxSwift-和-RxCocoa" class="headerlink" title="0x01 什么是 RxSwift 和 RxCocoa"></a>0x01 什么是 RxSwift 和 RxCocoa</h2><p>ReactiveX 是一个支持很多编程语言和平台语言工具库 项目。而 RxSwift 和 RxCocoa 是 ReactiveX 套装的一部分。</p><p>RxSwift 是一个和 Swift 语言进行交互的框架，而 RxCocoa 则使得 Cocoa 的 APIs 更容易被 Reactive 技术调用。</p><p>RxSwift 和 RxCocoa 可以通过 pod 来安装，具体方法自行查看其 github 项目主页。</p><h2 id="0x02-基本概念：Observable可观察的-和-Observer-观察者"><a href="#0x02-基本概念：Observable可观察的-和-Observer-观察者" class="headerlink" title="0x02 基本概念：Observable可观察的 和 Observer 观察者"></a>0x02 基本概念：<code>Observable</code><em>可观察的</em> 和 <code>Observer</code> <em>观察者</em></h2><p>我曾经被这些概念混淆了很久，在不同的文章中有不同的称呼，特别是在中文博客中，什么“流”与“信号”齐飞，却少有人按照英文字面的翻译<br>Observable =&gt; 可观察的，Observer =&gt; 观察者，在这篇文章中我将使用这个字面翻译，原因等你看完文章会体会到的。</p><p>其实，这个英文名字起的很有意思，Observable 是一个形容词，其实将形容词作为一个类名非常贴切，其在牛津词典中的解释是：<em>Able to be noticed or perceived</em>，而 Observer 是一个名词，在牛津词典中的解释是：<em>A person who watches or notices something</em>。</p><p>而这两个词在 Rx 中的含义是：</p><ul><li>一个<code>可观察的</code>是一个能够提交通知的东西。</li><li>一个<code>观察者</code>可以订阅一个<code>可观察的</code>对象，可以接收对象改变的通知，同时进行一些自定义操作。</li></ul><h2 id="0x03-基本概念：DisposeBag-销毁包"><a href="#0x03-基本概念：DisposeBag-销毁包" class="headerlink" title="0x03 基本概念：DisposeBag 销毁包"></a>0x03 基本概念：<code>DisposeBag</code> <em>销毁包</em></h2><p>是 RxSwift 和 RxCocoa 的工具，用来帮助和 ARC 内存管理进行交互的工具。这是一个给<code>观察者</code>对象的虚拟的 “包”，当其父对象被 deallocate 后，观察者对象的内存也会被释放。</p><p>假设某个观察者对象的一个属性是 DisposeBag ，那么当它的 <code>deinit()</code> 方法被调用的时候，这个 “bag” 被清空，并且每个被销毁的观察者都自动的解除订阅，这就允许 ARC 系统去正常地回收内存了。</p><p>没有 <code>DisposeBag</code> 的话，将会有两种结果：</p><ol><li>要么观察者会创造保留环，造成内存泄漏</li><li>要么它会在对象的外面被释放掉，造成程序崩溃</li></ol><p>所以，一定要记得在设置观察者对象的时候增加 DisposeBag。</p><hr><h2 id="0x04-接下来举个例子：购买巧克力"><a href="#0x04-接下来举个例子：购买巧克力" class="headerlink" title="0x04 接下来举个例子：购买巧克力"></a>0x04 接下来举个例子：购买巧克力</h2><p><em>项目文件：<a href="https://github.com/shengyang998/Chocolates-starter" target="_blank" rel="external">传送门</a></em></p><p>Build 并且运行项目，现在这个 demo 还是没有使用响应式的，接下来的教程中，将会展示如何使用响应式来完成这个 demo。</p><h2 id="0x05-响应式操作购物车数量"><a href="#0x05-响应式操作购物车数量" class="headerlink" title="0x05 响应式操作购物车数量"></a>0x05 响应式操作购物车数量</h2><p>打开 <code>ShoppingCart.swift</code>，找到购物车内数组的声明<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> chocolates = [<span class="type">Chocolate</span>]()</div></pre></td></tr></table></figure><p></p><p>现在还不是响应式的，要想响应式，将其改成<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> chocolates: <span class="type">Variable</span>&lt;[<span class="type">Chocolate</span>]&gt; = <span class="type">Variable</span>([])</div></pre></td></tr></table></figure><p></p><p>上面语句的作用详述如下：</p><ol><li>你定义了一个 RxSwift 的 Variable，这个 Variable 是 Swift 数组类型的，数组用了 Chocolate 类型来定义。</li><li><code>Variable</code> 是一个类，所以它是引用类型。也就是 chocolates 是 Variable 的一个实例。</li><li><code>Variable</code> 有一个属性叫 <code>value</code>。这里是你的 Chocolate 数组存放的地方。</li><li><code>Variable</code> 的膜法来自于一个叫 <code>asObservable()</code> 的方法。你可以增加一个观察者来代替每次去手动 check the value。</li><li>另外以后访问那个数组的时候，都要通过 <code>value</code> 来访问了。</li></ol><p>修复 Xcode 当前提示的所有错误，然后继续下面的操作：</p><ol><li>在文件 <code>ChocolatesOfTheWorldViewController.swift</code> 中增加</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</div></pre></td></tr></table></figure><ol><li>在 // MARK: Rx Setup 下面增加</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupCartObserver</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="type">ShoppingCart</span>.sharedCart.chocolates.asObservable()</div><div class="line">    .subscribe(onNext:&#123;</div><div class="line">        (chocolates) <span class="keyword">in</span></div><div class="line">        <span class="keyword">self</span>.cartButton.title = <span class="string">"\(chocolates.count) \u&#123;1f36b&#125;"</span></div><div class="line">        &#125;)</div><div class="line">    .addDisposableTo(disposeBag)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这将会设置一个响应式的观察者去自动更新购物车。</p><p>上面的代码具体做了什么？详述如下：</p><ol><li>首先，获取购物车的 chocolates as an Observable</li><li>每次 Observable 中的值更新后都会调用其观察者的 <code>subscribe(onNext:)</code> ，其中传入的参数就是被改变的值。</li><li>记得每次 subscribe 后都要 addDisposableTo。</li></ol><p>接下来，在 <code>viewDidLoad()</code> 方法中调用 <code>setupCartObserver()</code>，并且删除那个非私有的 <code>updateCartButton()</code> 方法，修复错误。</p><h2 id="0x06-响应式操作-TableView"><a href="#0x06-响应式操作-TableView" class="headerlink" title="0x06 响应式操作 TableView"></a>0x06 响应式操作 TableView</h2><p>现在你已经让购物车响应式了，接下来你将会看到如何使用 RxCocoa 来让 UITableView 响应式。</p><p>RxCocoa 包含一些 UI 控件的响应式的 API，这使得你可以控制像 UITableView 等控件而不需要 override 代理和数据源方法</p><p>为了演示怎么做，删除整个 UITableViewDataSource 和 UITableViewDelegate 扩展，然后删除 viewDidLoad 方法里注册 dataSource 和 delegate 的语句。</p><p>编译并且运行一下，你将会发现整个 TableView 都空了，那么好，接下来你需要使 TableView 中的一些东西响应化，首先，在文件 <code>ChocolatesOfTheWorldViewController.swift</code> 中，把属性<code>europeanChocolates</code>改成一个可观察的：<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> europeanChocolates = <span class="type">Observable</span>.just(<span class="type">Chocolate</span>.ofEurope)</div></pre></td></tr></table></figure><p></p><p><code>可观察的值</code>不会有任何改变，但是当你仍然想要像一个可观察的值一样访问它的时候，使用<code>just(_:)</code>方法。<br><em>Sometimes, calling <code>just(_:)</code> is an indication that using Reactive Programming might be overkill—after all, if a value never changes, why use a Programming technique designed to react to changes? In this example, you’re using it to set up reactions of table view cells which will change, but it’s always a good idea to look carefully at how you’re using Rx. Just because you have a hammer doesn’t mean every problem is a nail.</em></p><p>现在你已经让 europeanChocolates 变成可观察的了，那么接下来增加下面的函数：<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupCellConfig</span><span class="params">()</span></span>&#123;</div><div class="line">    europeanChocolates.bindTo(tableView</div><div class="line">        .rx.items(cellIdentifier: <span class="type">ChocolateCell</span>.<span class="type">Identifier</span>, cellType: <span class="type">ChocolateCell</span>.<span class="keyword">self</span>))&#123;</div><div class="line">            (row, chocolate, cell) <span class="keyword">in</span></div><div class="line">            cell.configureWithChocolate(chocolate: chocolate)</div><div class="line">        &#125;.addDisposableTo(disposeBag)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>这里做的事是：</p><ol><li>你调用了<code>bindTo(_:)</code>去关联可观察的 europeanChocolates，上面的代码应该每行都调用一次</li><li>通过 <code>rx.</code> 可以访问 RxCocoa 对于 UI 控件的扩展，在这里是 UITableView</li><li>调用 Rx 方法，<code>items(cellIdentifier: cellType:)</code>，传入 cell identifier 和 cell 的类型。这将允许 Rx 调用离队方法（dequeuing method）</li><li>也可以传入一个 block ，每一个新 item 都会执行这个 block。你会获得关于这一行的返回信息，和 cell，这使得它配置 cell 超级简单。</li><li>加入 disposeBag</li></ol><p>通常情况下经过<code>tableView(_:numberOfRowsInSection:)</code>和<code>numberOfSection(in:)</code>计算的值现在自动根据被观察的值来自动计算。而<code>tableView(_: cellForRowAt:)</code>代理方法已经被闭包代替。</p><p>现在，去<code>viewDidLoad()</code>方法中添加下面这行代码，调用你的新设置方法：<br><code>setupCellConfig()</code></p><p>现在，如果你点击 tableView 的任何一行，都不会有反应。因为当你删除<code>tableView(_: didSelectRowAt:)</code>的时候，tableView 已经不能识别点击动作了。</p><p>为了解决点击问题，RxCocoa 有一个<code>modelSelected(_:)</code>方法，这个方法会返回一个 Observable，你可以使用它去观察关于被选择对象的信息。增加如下方法：<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupCellTapHandling</span><span class="params">()</span></span>&#123;</div><div class="line">    tableView.rx.modelSelected(<span class="type">Chocolate</span>.<span class="keyword">self</span>) <span class="comment">//1</span></div><div class="line">    .subscribe(onNext:&#123; <span class="comment">//2</span></div><div class="line">        chocolate <span class="keyword">in</span></div><div class="line">        <span class="type">ShoppingCart</span>.sharedCart.chocolates.value.append(chocolate)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> selectedRowIndexPath = <span class="keyword">self</span>.tableView.indexPathForSelectedRow&#123;</div><div class="line">            <span class="keyword">self</span>.tableView.deselectRow(at: selectedRowIndexPath, animated:<span class="literal">true</span>)</div><div class="line">        &#125; <span class="comment">//3</span></div><div class="line">        &#125;).addDisposableTo(disposeBag) <span class="comment">//4</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>一步一步来解释：</p><ol><li>给 table view 的扩展方法<code>modelSelected(_:)</code>传入一个<code>Chocolate model</code>来获取返回值的正确类型。这个方法返回一个 Observable。</li><li>获取那个 Observable，调用<code>subscribe(onNext:)</code>方法，传入一个尾随闭包，这个闭包将会在每次 model 被选中的时候执行。</li><li>当<code>self.tableView.indexPathForSelectedRow</code>有值的时候，也就是被选中的时候，取消选择它。</li><li>记得加入 DisposeBag</li></ol><p>最后记得在 viewDidLoad 中加入对上面函数的调用。</p><h2 id="0x07-文本响应式输入"><a href="#0x07-文本响应式输入" class="headerlink" title="0x07 文本响应式输入"></a>0x07 文本响应式输入</h2><p>在一般应用中，文字输入的处理一般都交给<code>UITextFieldDelegate</code>来做，通常其方法里会包含很多的 if/else 来决定哪个操作和逻辑应该被执行。Reactive 则不同。体会一下：</p><p>在<code>BillingInfoViewController.swift</code>中增加 DisposeBag<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</div></pre></td></tr></table></figure><p></p><p>下面的代码展示了如何根据用户的输入展示信用卡的图标：<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupCardImageDisplay</span><span class="params">()</span></span>&#123;</div><div class="line">    cardType.asObservable()</div><div class="line">    .subscribe(onNext:&#123;</div><div class="line">        cardType <span class="keyword">in</span></div><div class="line">        <span class="keyword">self</span>.careditCardImageView.image = cardType.image</div><div class="line">        &#125;).addDisposableTo(disposeBag)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p>接下来处理一些有趣的事，如果用户打字很快，你可能不想立即处理输入的字符，否则可能会导致应用执行缓慢。解决办法很简单，使用<code>throttle</code>，按照间隔时间来执行逻辑而不是每次改变都执行。</p><p>废话不多说，直接上代码：</p><p>首先，在<code>BillingInfoViewController</code>中增加如下代码：<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">let</span> throttleInterVal = <span class="number">0.1</span></div></pre></td></tr></table></figure><p></p><p>这里以秒为单位定义了 throttle length 的常数。</p><p>然后再增加如下代码：<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupTextChangeHandling</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">let</span> creditCardValid = creditCardNumberTextField</div><div class="line">    .rx.text.throttle(throttleInterVal, scheduler: <span class="type">MainScheduler</span>.instance) <span class="comment">//1</span></div><div class="line">    .<span class="built_in">map</span>&#123; <span class="keyword">self</span>.validate(cardText: $<span class="number">0</span>) &#125; <span class="comment">//2</span></div><div class="line"></div><div class="line">    creditCardValid.subscribe(onNext:&#123;</div><div class="line">        <span class="keyword">self</span>.creditCardNumberTextField.valid = $<span class="number">0</span> <span class="comment">//3</span></div><div class="line">        &#125;).addDisposableTo(disposeBag) <span class="comment">//4</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><p><strong>Note:如果你在设置 creditCardValid 的时候得到一个“<em>Generic parameter R could not be inferred</em>”错误，你可以显式地指明 creditCardValid 的类型：<code>let creditCardValid: Observable</code>。理论上编译器应该能够自动推断出这个类型，但是有时候它可能需要一点动力🙂</strong></p><p>好，那么这些代码做了什么呢？我们继续一步步分析：</p><ol><li>你对输入进行了 <code>throttle</code> 操作，所以验证逻辑只会根据你在上面设置的时间来执行。<code>scheduler</code>参数是一个更高级的概念，简单来说它是用来绑定一个线程的，如果你要使用主线程的话，则设置为<code>MainScheduler</code>（UI 操作都需要主线程）</li><li>通过调用<code>validate(cardText)</code>来把 throttle 输入流 map 成一个 Boolean 类型的流。</li><li>获取并且订阅 creditCardValid ，基于输入来改变 text field 的验证状态。</li><li>加入 DisposeBag ，不费话了</li></ol><p>接下来响应式操作 Expiration date 和 CVV Code在<code>setupTextChangeHandling()</code>底部继续增加如下代码：<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> expirationValid = expirationDateTextField</div><div class="line">.rx.text.throttle(throttleInterval, scheduler: <span class="type">MainScheduler</span>.instance)</div><div class="line">  .<span class="built_in">map</span> &#123; <span class="keyword">self</span>.validate(expirationDateText: $<span class="number">0</span>) &#125;</div><div class="line"></div><div class="line">expirationValid.subscribe(onNext: &#123;</div><div class="line">    <span class="keyword">self</span>.expirationDateTextField.valid = $<span class="number">0</span></div><div class="line">    &#125;).addDisposableTo(disposeBag)</div><div class="line"></div><div class="line"><span class="keyword">let</span> cvvValid = cvvTextField</div><div class="line">  .rx.text.<span class="built_in">map</span> &#123; <span class="keyword">self</span>.validate(cvvText: $<span class="number">0</span>) &#125;</div><div class="line"></div><div class="line">cvvValid</div><div class="line">  .subscribe(onNext: &#123; <span class="keyword">self</span>.cvvTextField.valid = $<span class="number">0</span> &#125;)</div><div class="line">  .addDisposableTo(disposeBag)</div></pre></td></tr></table></figure><p></p><p>现在，你获取了三个文本框的所有可观察的值，那么增加下面的代码：<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> everythingValid = <span class="type">Observable</span></div><div class="line">    .combineLatest(creditCardValid, expirationValid, cvvValid)&#123;</div><div class="line">    $<span class="number">0</span> &amp;&amp; $<span class="number">1</span> &amp;&amp; $<span class="number">2</span> <span class="comment">//all must be true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">everythingValid.bindTo(purchaseButton.rx.enable)</div><div class="line">    .addDisposableTo(disposeBag)</div></pre></td></tr></table></figure><p></p><p>这里用到了 Observable 的类方法：<code>combineLatest()</code>，好好体会一下。</p><p><code>everythingValid</code>然后和 UIButton 在 rx 扩展内的<code>enabled</code>属性绑定了，所以按钮的状态被 <code>everythingValid</code> 的值来控制。如果所有三个文本域都为真，按钮才能被按下</p><p>好的，现在你已经写好设置方法了，在<code>viewDidLoad()</code>中调用它吧：<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">setupCardImageDisplay()</div><div class="line">setupTextChangeHandling()</div></pre></td></tr></table></figure><p></p><p>接下来运行一下看看效果，好好体会，如果有什么问题，尽管提交 issue。</p><h2 id="0x08-尾声"><a href="#0x08-尾声" class="headerlink" title="0x08 尾声"></a>0x08 尾声</h2><p>如果你想多尝试一下，试试看：</p><ol><li>让 <code>CartViewController</code> 使用一个响应式的 TableView 来展示购物车的数据，而不是一个 Label。</li><li>允许用户直接在购物车页面增加或者移除巧克力，自动更新总价。</li></ol><p>好了，这只是一个开始，如果你想了解更多关于响应式编程的内容的话，下面的内容你绝对不会错过：</p><ol><li><a href="http://slack.rxswift.org/" target="_blank" rel="external">RxSwift Slack</a></li><li><a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md" target="_blank" rel="external">RxSwift’s Getting Started guide</a></li><li><a href="https://realm.io/news/slug-max-alexander-functional-reactive-rxswift/" target="_blank" rel="external">Max Alexander’s talk on Rx at Realm</a></li><li><a href="http://rx-marin.com" target="_blank" rel="external">rx-marin</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多面向对象的开发人员都遇到过这样的问题：软件开发过程中，需要开发人员主动地告诉系统什么东西改变了，以此来触发响应。&lt;/p&gt;&lt;p&gt;那有人就会想，如果有一个办法可以让系统自动发现状态的改变，是不是更好呢？&lt;/p&gt;&lt;p&gt;这就引出了响应式开发最基本的概念……&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://blog.superyoung.win/tags/iOS/"/>
    
      <category term="Programming" scheme="http://blog.superyoung.win/tags/Programming/"/>
    
      <category term="Swift" scheme="http://blog.superyoung.win/tags/Swift/"/>
    
      <category term="RxSwift" scheme="http://blog.superyoung.win/tags/RxSwift/"/>
    
      <category term="响应式" scheme="http://blog.superyoung.win/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
      <category term="开发" scheme="http://blog.superyoung.win/tags/%E5%BC%80%E5%8F%91/"/>
    
      <category term="入门" scheme="http://blog.superyoung.win/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>关于 SequenceType</title>
    <link href="http://blog.superyoung.win/2017/01/25/learning_iOS/SequenceType/"/>
    <id>http://blog.superyoung.win/2017/01/25/learning_iOS/SequenceType/</id>
    <published>2017-01-25T07:47:23.000Z</published>
    <updated>2017-01-29T02:27:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>Coming soon…<br><a id="more"></a></p><h2 id="从-Array-开始"><a href="#从-Array-开始" class="headerlink" title="从 Array 开始"></a>从 Array 开始</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Coming soon…&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://blog.superyoung.win/tags/iOS/"/>
    
      <category term="Programming" scheme="http://blog.superyoung.win/tags/Programming/"/>
    
      <category term="Coming soon..." scheme="http://blog.superyoung.win/tags/Coming-soon/"/>
    
      <category term="Sequence" scheme="http://blog.superyoung.win/tags/Sequence/"/>
    
      <category term="type" scheme="http://blog.superyoung.win/tags/type/"/>
    
  </entry>
  
  <entry>
    <title>Debug Print in iOS Programming</title>
    <link href="http://blog.superyoung.win/2017/01/15/learning_iOS/debugPrint/"/>
    <id>http://blog.superyoung.win/2017/01/15/learning_iOS/debugPrint/</id>
    <published>2017-01-15T02:29:44.000Z</published>
    <updated>2017-01-29T02:27:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>自定义 print 输出<br><a id="more"></a></p><p><em>请先参考<a href="http://swifter.tips/print/" target="_blank" rel="external">王魏的博客 Swifter</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自定义 print 输出&lt;br&gt;
    
    </summary>
    
    
      <category term="Coming soon..." scheme="http://blog.superyoung.win/tags/Coming-soon/"/>
    
  </entry>
  
  <entry>
    <title>Swift 中如何获取实例类型</title>
    <link href="http://blog.superyoung.win/2017/01/15/learning_iOS/get-type-of-instance/"/>
    <id>http://blog.superyoung.win/2017/01/15/learning_iOS/get-type-of-instance/</id>
    <published>2017-01-15T02:17:03.000Z</published>
    <updated>2017-01-29T02:27:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>一门编程语言的动态特性，最基础的就是获取一个实例的类型。<br><a id="more"></a></p><h2 id="在-ObjC-中我们怎么做？"><a href="#在-ObjC-中我们怎么做？" class="headerlink" title="在 ObjC 中我们怎么做？"></a>在 ObjC 中我们怎么做？</h2><p>在 ObjC 中我们可以通过一个实例的 class 方法来获取其类型名<br></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDate</span> *date = [<span class="built_in">NSDate</span> date];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="built_in">NSStringFromClass</span>([date <span class="keyword">class</span>]));</div></pre></td></tr></table></figure><p></p><h2 id="在-Swift-中没有实例的-class-方法"><a href="#在-Swift-中没有实例的-class-方法" class="headerlink" title="在 Swift 中没有实例的 class 方法"></a>在 Swift 中没有实例的 class 方法</h2><p>可以求助于 ObjC 运行时，调用 <code>object_getClass(AnyTypeInstance)</code>。例子如下：<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> date = <span class="type">NSDate</span>()</div><div class="line"><span class="built_in">print</span>(object_getClass(date))</div></pre></td></tr></table></figure><p></p><h2 id="object-getClass-方法返回类型是？"><a href="#object-getClass-方法返回类型是？" class="headerlink" title="object_getClass() 方法返回类型是？"></a><code>object_getClass()</code> 方法返回类型是？</h2><p>是 AnyClass! 可以通过 <code>debugPrint</code> 来验证，关于 <code>debugPrint</code>，参见<a href="../debugPrint/README.md">debugPrint()</a></p><h2 id="更加符合-Swift-风格的做法"><a href="#更加符合-Swift-风格的做法" class="headerlink" title="更加符合 Swift 风格的做法"></a>更加符合 Swift 风格的做法</h2><p>Swift 2 以前的方法，已抛弃<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> date = <span class="type">NSDate</span>()</div><div class="line"><span class="built_in">print</span>(date.<span class="keyword">dynamicType</span>)</div></pre></td></tr></table></figure><p></p><p>Swift 3.0 以后使用 <code>type(of:AnyTypeInstance)</code>方法<br></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> date = <span class="type">NSDate</span>()</div><div class="line"><span class="built_in">print</span>(type(of:date))</div></pre></td></tr></table></figure><p></p><p><em>参考:</em></p><ol><li><em><a href="http://swifter.tips/instance-type/" target="_blank" rel="external">王魏的博客 Swifter</a></em></li><li><em><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html" target="_blank" rel="external">Apple 官方文档关于 Metatype Type 的内容</a></em></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一门编程语言的动态特性，最基础的就是获取一个实例的类型。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://blog.superyoung.win/tags/iOS/"/>
    
      <category term="Programming" scheme="http://blog.superyoung.win/tags/Programming/"/>
    
      <category term="Swift" scheme="http://blog.superyoung.win/tags/Swift/"/>
    
      <category term="type" scheme="http://blog.superyoung.win/tags/type/"/>
    
      <category term="language" scheme="http://blog.superyoung.win/tags/language/"/>
    
      <category term="instance" scheme="http://blog.superyoung.win/tags/instance/"/>
    
  </entry>
  
  <entry>
    <title>Block 简介</title>
    <link href="http://blog.superyoung.win/2017/01/04/learning_iOS/Block-in-Objc/"/>
    <id>http://blog.superyoung.win/2017/01/04/learning_iOS/Block-in-Objc/</id>
    <published>2017-01-03T17:13:54.000Z</published>
    <updated>2017-01-29T02:27:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>什么是 Block？Block 可以实现闭包。Block 与函数类似，只不过是直接定义在另一个函数里。Block 也可以访问、捕获它被声明的区域内的所有变量。而且 Block 因为有返回类型，它其实也可以作为个值来对待。<br><a id="more"></a></p><h2 id="定义-Block-的语法结构如下"><a href="#定义-Block-的语法结构如下" class="headerlink" title="定义 Block 的语法结构如下"></a>定义 Block 的语法结构如下</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return_type (^block_name)(parameters)&#123;&#125;</div></pre></td></tr></table></figure><h2 id="Block-捕获的变量是不可以在-Block-中修改的"><a href="#Block-捕获的变量是不可以在-Block-中修改的" class="headerlink" title="Block 捕获的变量是不可以在 Block 中修改的"></a>Block 捕获的变量是不可以在 Block 中修改的</h2><p>若要修改，该变量需要在声明的时候加上 <code>__block</code> 修饰符。</p><h2 id="Block-和-Grand-Central-Dispatch"><a href="#Block-和-Grand-Central-Dispatch" class="headerlink" title="Block 和 Grand Central Dispatch"></a>Block 和 Grand Central Dispatch</h2><p><code>Grand Central Dispatch</code> 是一种与 <code>Block</code> 有关的技术，它提供了对线程的抽象，这种抽象基于派发队列<code>dispatch queue</code>，开发者可以将 <code>Block</code> 排入队列中，由 <code>GCD</code> 负责调度。</p><h2 id="小心保留环"><a href="#小心保留环" class="headerlink" title="小心保留环"></a>小心保留环</h2><p>若在类的实例方法中定义一个块，那么块会捕获 <code>self</code> 变量，如果 <code>self</code> 所指代的那个对象同时也保留了块，则会导致“保留环”。</p><h2 id="解决保留环问题"><a href="#解决保留环问题" class="headerlink" title="解决保留环问题"></a>解决保留环问题</h2><p>一般来说，只要适时清理掉环中的某个引用，就不会有问题。对于块来说的话，在块的最后令 <code>Handler = nil;</code> 即可解决保留环问题。</p><h2 id="全局快、栈块、堆块"><a href="#全局快、栈块、堆块" class="headerlink" title="全局快、栈块、堆块"></a>全局快、栈块、堆块</h2><p>栈块所占据的内存空间可能会被自动覆写，若被覆写，则运行时将会出错。解决此问题可以给块对象发送 <code>copy</code> 消息，示例如下：<br></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">block = [^&#123;codeInBlock&#125; <span class="keyword">copy</span>];</div></pre></td></tr></table></figure><p></p><h2 id="为常用块创建-typedef"><a href="#为常用块创建-typedef" class="headerlink" title="为常用块创建 typedef"></a>为常用块创建 typedef</h2><p>创建的语法规则：<br></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>(^block_name)(parameters);</div></pre></td></tr></table></figure><p></p><p>调用的语法规则：<br></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">block_name block = ^(parameters)&#123;&#125;</div></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是 Block？Block 可以实现闭包。Block 与函数类似，只不过是直接定义在另一个函数里。Block 也可以访问、捕获它被声明的区域内的所有变量。而且 Block 因为有返回类型，它其实也可以作为个值来对待。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://blog.superyoung.win/tags/iOS/"/>
    
      <category term="Programming" scheme="http://blog.superyoung.win/tags/Programming/"/>
    
      <category term="Objective C" scheme="http://blog.superyoung.win/tags/Objective-C/"/>
    
      <category term="Block" scheme="http://blog.superyoung.win/tags/Block/"/>
    
  </entry>
  
  <entry>
    <title>Coordinate System</title>
    <link href="http://blog.superyoung.win/2017/01/04/learning_iOS/coordinate-system/"/>
    <id>http://blog.superyoung.win/2017/01/04/learning_iOS/coordinate-system/</id>
    <published>2017-01-03T17:12:31.000Z</published>
    <updated>2017-01-29T02:27:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 的坐标系统<br><a id="more"></a><br>每一个 view 都有它的 coordinate system。 原点在（0，0）， 拥有宽度和高度属性。<br>在 iOS 中使用 <code>bounds</code> 来描述 coordinate system。<br>iOS 中的 <code>frame</code> 的 <code>origin</code> 属性会含有相对于 superview 的 coordinate system 坐标。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 的坐标系统&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://blog.superyoung.win/tags/iOS/"/>
    
      <category term="Programming" scheme="http://blog.superyoung.win/tags/Programming/"/>
    
      <category term="Coordinate" scheme="http://blog.superyoung.win/tags/Coordinate/"/>
    
      <category term="System" scheme="http://blog.superyoung.win/tags/System/"/>
    
      <category term="坐标系统" scheme="http://blog.superyoung.win/tags/%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>关于UIAlertController</title>
    <link href="http://blog.superyoung.win/2017/01/04/learning_iOS/UIAlertController/"/>
    <id>http://blog.superyoung.win/2017/01/04/learning_iOS/UIAlertController/</id>
    <published>2017-01-03T17:09:49.000Z</published>
    <updated>2017-01-29T02:27:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>个人学习使用 UIAlertController 的时候的总结<br><a id="more"></a><br>在 iOS8 以后，苹果推出了一个新的 Alert 类：<code>UIAlertController</code>。原有的<code>UIAlertView</code>已经不推荐使用。故本文主要介绍<code>UIAlertController</code></p><h2 id="如何使用UIAlertController"><a href="#如何使用UIAlertController" class="headerlink" title="如何使用UIAlertController"></a>如何使用UIAlertController</h2><ol><li>实例化方法：<code>UIAlertController *alert = [UIAlertController alertControllerWithTitle:(NSString*)title message:(NSString*)msg preferredStyle:(UIAlertControllerStyle)style];</code></li><li>显示方法：<code>[self presentViewController:(UIAlertController*)con animation:... completion:(^)block];</code><h2 id="关于UIAlertAction"><a href="#关于UIAlertAction" class="headerlink" title="关于UIAlertAction"></a>关于UIAlertAction</h2></li><li>实例化方法：<code>[UIAlertAction *action = [UIAlertActionWithTitle:(NSString*)title style:... handler:(^)block]];</code></li><li>为了在一个 Alert 中添加选项按钮，可以将一个<code>UIAlertAction</code>对象添加到一个<code>UIAlertController</code>对象。发送如下消息即可：<br><code>[alert addAction:(UIAlertAction*)action];</code><h2 id="如何自定义-UIAlertController"><a href="#如何自定义-UIAlertController" class="headerlink" title="如何自定义 UIAlertController"></a>如何自定义 UIAlertController</h2><h3 id="先定一个小目标，比如说，添加一个-UITextField："><a href="#先定一个小目标，比如说，添加一个-UITextField：" class="headerlink" title="先定一个小目标，比如说，添加一个 UITextField："></a>先定一个小目标，比如说，添加一个 UITextField：</h3></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人学习使用 UIAlertController 的时候的总结&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://blog.superyoung.win/tags/iOS/"/>
    
      <category term="Programming" scheme="http://blog.superyoung.win/tags/Programming/"/>
    
      <category term="Objective C" scheme="http://blog.superyoung.win/tags/Objective-C/"/>
    
      <category term="UIAlertController" scheme="http://blog.superyoung.win/tags/UIAlertController/"/>
    
  </entry>
  
  <entry>
    <title>UITableView</title>
    <link href="http://blog.superyoung.win/2017/01/04/learning_iOS/UITableView/"/>
    <id>http://blog.superyoung.win/2017/01/04/learning_iOS/UITableView/</id>
    <published>2017-01-03T17:07:32.000Z</published>
    <updated>2017-01-29T02:27:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>个人学习使用 UITableView 的时候的总结<br><a id="more"></a></p><h2 id="设置数据源-（UITableViewDataSource）"><a href="#设置数据源-（UITableViewDataSource）" class="headerlink" title="设置数据源 （UITableViewDataSource）"></a>设置数据源 （UITableViewDataSource）</h2><p>需要<code>数据源</code>来展示数据，dataSource。会向数据源查询一共多少行数据以及每一行显示什么数据</p><p>不论什么对象，只要其遵循 <code>UITableViewDataSource</code> 协议即可。</p><p>UITableViewDataSource协议中有三个需要实现的函数</p><ol><li><p>tableview 有几组（section）？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSInteger</span>) numberOfSectionInTableView: (<span class="built_in">UITableView</span>*) tableView;</div></pre></td></tr></table></figure></li><li><p>每组（section）几行？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSInteger</span>) tableView:(<span class="built_in">UITableView</span>*)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section;</div></pre></td></tr></table></figure></li><li><p>每组每行分别显示什么内容（cell）？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UITableViewCell</span>*) tableView:(<span class="built_in">UITableView</span>*)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span>*)indexPath;</div></pre></td></tr></table></figure></li><li><p>每组的 titleForHeader 和 titleForFooter。这两个字体不可更改，如果有需要，使用自定义的 UILabel。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span>*)tableView:(<span class="built_in">UITableView</span>*)tableView titleForHeaderInSection:(<span class="built_in">NSInteger</span>)section;</div><div class="line">- (<span class="built_in">NSString</span>*)tableView:(<span class="built_in">UITableView</span>*)tableView titleForFooterInSection:(<span class="built_in">NSInteger</span>)section;</div></pre></td></tr></table></figure></li></ol><h3 id="怎么判断是哪一组哪一行呢？"><a href="#怎么判断是哪一组哪一行呢？" class="headerlink" title="怎么判断是哪一组哪一行呢？"></a>怎么判断是哪一组哪一行呢？</h3><p>看到上面的参数indexPath了吗？这样判断组：</p><ul><li><code>if(0 == indexPath.section){}</code></li></ul><p>这样判断行：</p><ul><li><code>if(0 == indexPath.row){}</code></li></ul><h3 id="关于UITableViewCell"><a href="#关于UITableViewCell" class="headerlink" title="关于UITableViewCell"></a>关于UITableViewCell</h3><p>初始化方法：<br><code>UITableViewCell* cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:nil];</code></p><h4 id="contentView是什么？"><a href="#contentView是什么？" class="headerlink" title="contentView是什么？"></a>contentView是什么？</h4><p><code>UITableViewCell</code>中有个默认的子视图<code>contentView</code>， <code>contentView</code>是所有其他内容的父视图。<br>可以通过其下的<code>accessoryType</code>来显示辅助指示视图。</p><h4 id="UITableViewCellStyle-类型"><a href="#UITableViewCellStyle-类型" class="headerlink" title="UITableViewCellStyle 类型"></a>UITableViewCellStyle 类型</h4><ul><li>UITableViewCellStyleDefault</li><li>UITableViewCellStyleSubtitle</li><li>UITableViewCellStyleValue1</li><li>UITableViewCellStyleValue2</li></ul><h3 id="UITableViewCell-的结构"><a href="#UITableViewCell-的结构" class="headerlink" title="UITableViewCell 的结构"></a>UITableViewCell 的结构</h3><ul><li><code>UITableViewCell</code></li><li>-&gt;<code>.imageView</code></li><li>-&gt;<code>.textLabel</code></li><li>-&gt;<code>.detailTextLabel</code></li><li>-&gt;<code>.contentView</code></li></ul><p>cell 里面包含默认一些子控件，不过也可以自己用 xib 定义。</p><h2 id="设置代理-delegate"><a href="#设置代理-delegate" class="headerlink" title="设置代理(delegate)"></a>设置代理(delegate)</h2><h3 id="为什么要设置代理？"><a href="#为什么要设置代理？" class="headerlink" title="为什么要设置代理？"></a>为什么要设置代理？</h3><ul><li><code>对象A</code>内部发生了一些事情，想要通知<code>对象B</code></li><li><code>对象B</code>想监听<code>对象A</code>内部发生的事情</li><li><code>对象A</code>想在自己内部调用<code>对象B</code>的一些方法，而又不想有互相的耦合依赖</li></ul><p>以上情况下，<code>对象B</code>都是<code>对象A</code>的代理。</p><h3 id="如何设置代理对象"><a href="#如何设置代理对象" class="headerlink" title="如何设置代理对象"></a>如何设置代理对象</h3><ol><li>在<code>Stroyboard</code>的<code>UIScrollView</code>上右键单击，拖<code>delegate</code>到<code>UIViewController</code>上。</li><li>在方法<code>viewDidLoad</code>中添加<code>self.tableView.delegate = self;</code><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><code>类名+Delegate</code><br><em>例如<code>UITableViewDelegate</code>就是<code>UITableView</code>+<code>Delegate</code></em></li></ol><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>如果是为一个类特别定义的协议，可以直接写在<code>.h</code>文件里，如果多个类使用同一个协议，建议建立一个<code>protocol</code>文件。</p><ul><li>关于定义格式，举个例子：</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UITableView</span>&lt;<span class="title">NSObject</span>, <span class="title">UIScrollView</span>&gt;</span></div><div class="line"><span class="keyword">@required</span></div><div class="line">- (ReturnType) MethodName;</div><div class="line"><span class="keyword">@optional</span></div><div class="line">- (ReturnType) MethodName;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure><p>默认是<code>@required</code>，但是这只能作为编译器检查的标准，使用时需要自己验证是否实现了具体的方法，验证方法如下：<br></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>([<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(MethodName)])&#123;</div><div class="line">    MethodName</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><h4 id="首先定义一个-protocol"><a href="#首先定义一个-protocol" class="headerlink" title="首先定义一个@protocol"></a>首先定义一个<code>@protocol</code></h4><p>声明协议方法</p><h4 id="定义一个委托-interface"><a href="#定义一个委托-interface" class="headerlink" title="定义一个委托@interface"></a>定义一个委托<code>@interface</code></h4><p>引入<code>protocol.h</code></p><h4 id="定义一个代理-interface"><a href="#定义一个代理-interface" class="headerlink" title="定义一个代理@interface"></a>定义一个代理<code>@interface</code></h4><p>在<code>@interface</code>声明中声明遵守<code>@protocol</code>协议。例如：<br></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">viewController</span> () &lt;<span class="title">protocolName</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p>然后在<code>@implementation</code>中实现具体的协议方法</p><h2 id="单组数据和多组数据"><a href="#单组数据和多组数据" class="headerlink" title="单组数据和多组数据"></a>单组数据和多组数据</h2><p>其本质都是 <code>UITableVIew</code> ，具体的差别其实就是UITableView的属性 <code>UITableViewStylePlain</code> 和 <code>UITableViewStyleGrouped</code>的设置。</p><h2 id="好，那么接下来梳理一下一个-UITableView-从初始化到展示的流程："><a href="#好，那么接下来梳理一下一个-UITableView-从初始化到展示的流程：" class="headerlink" title="好，那么接下来梳理一下一个 UITableView 从初始化到展示的流程："></a>好，那么接下来梳理一下一个 <code>UITableView</code> 从初始化到展示的流程：</h2><ol><li>初始化一个 <code>UITableView</code> 对象</li></ol><ul><li>设置数据源，数据源需要遵循协议至少实现如下三个方法 <code>numberOfSectionInTableView</code> <code>numberOfRowsInSection</code> <code>cellForRowAtIndexPath</code></li><li>如有需要自行构造一个 <code>UITableViewCell</code> 并使用上面的第三个方法（<code>cellForRowAtIndexPath</code>）返回。</li></ul><h2 id="自定义cell"><a href="#自定义cell" class="headerlink" title="自定义cell"></a>自定义cell</h2><p>Coming soon…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人学习使用 UITableView 的时候的总结&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://blog.superyoung.win/tags/iOS/"/>
    
      <category term="Programming" scheme="http://blog.superyoung.win/tags/Programming/"/>
    
      <category term="UITableView" scheme="http://blog.superyoung.win/tags/UITableView/"/>
    
      <category term="ObjC" scheme="http://blog.superyoung.win/tags/ObjC/"/>
    
      <category term="Delegate" scheme="http://blog.superyoung.win/tags/Delegate/"/>
    
      <category term="DataSource" scheme="http://blog.superyoung.win/tags/DataSource/"/>
    
  </entry>
  
  <entry>
    <title>iOS 关闭键盘方式的小结</title>
    <link href="http://blog.superyoung.win/2017/01/04/learning_iOS/keyboard-dissmissing/"/>
    <id>http://blog.superyoung.win/2017/01/04/learning_iOS/keyboard-dissmissing/</id>
    <published>2017-01-03T17:04:40.000Z</published>
    <updated>2017-01-29T02:27:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>如何优雅的关闭 iOS 键盘，Objective C 语言。<br><a id="more"></a></p><h2 id="收起键盘方法"><a href="#收起键盘方法" class="headerlink" title="收起键盘方法"></a>收起键盘方法</h2><ol><li>点击<code>return</code>键收起，使用<code>UITextFieldDelegate</code>中的方法<br><code>- (BOOL)textFieldShouldReturn:(UITextField *)textField{return [textField resignFirstResponder]; return YES;}</code></li></ol><ul><li>点击<code>done</code>键收起，先将<code>UITextField</code>对象的<code>Return Key</code>属性修改为<code>done</code>，再自定义一个方法并将其和 <code>done</code> 的 <code>Did End On Exit</code> 连接起来：</li><li><p>(IBAction) textFieldDoneEditing:(id)sender{[sender resignFirstResponder];}</p></li><li><p>在键盘外点击关闭键盘<br>在<code>UITextField</code>对象外的视图控制器类的<code>viewDidLoad</code>方法中定义一个<code>UIGestureRecofnizer</code>对象（使用<code>[[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(dismissKb)]</code>方法初始化，并且使用<code>[self.view addGestureRecognizer:tap];</code>加入视图。</p></li></ul><p>然后记得实现<code>@selector()</code>中的方法：<code>- (void)dismissKb</code></p><ul><li><p>点击背景 View 收起键盘<br><code>[self.view endEditing:YES];</code></p></li><li><p>在任何地方加上这句话，统一收起键盘<br><code>[[[UIApplication sharedApplication] keyWindow] endEditing:YES];</code></p></li><li><p>发送 <code>resignFirstResponder</code> 消息<br><code>[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];</code></p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>当你能获取 <code>UITextField</code> 对象时，最好使用 <code>[obj resignFirstResponder]</code> 方法</li></ol><ul><li>如果有很多 <code>UITextField</code> 对象，而且可以获取到 <code>viewController</code> 的 <code>view</code> 时，可以使用 <code>[self.view endEditing:YES]</code> 方法</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何优雅的关闭 iOS 键盘，Objective C 语言。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://blog.superyoung.win/tags/iOS/"/>
    
      <category term="Programming" scheme="http://blog.superyoung.win/tags/Programming/"/>
    
      <category term="Objective C" scheme="http://blog.superyoung.win/tags/Objective-C/"/>
    
      <category term="keyboard" scheme="http://blog.superyoung.win/tags/keyboard/"/>
    
  </entry>
  
</feed>
