<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Tech. Desi. Life</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="iOS, Programming, Code, Technology, Design, Life,">
<meta property="og:type" content="website">
<meta property="og:title" content="Tech. Desi. Life">
<meta property="og:url" content="http://blog.superyoung.win/index.html">
<meta property="og:site_name" content="Tech. Desi. Life">
<meta property="og:description" content="iOS, Programming, Code, Technology, Design, Life,">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tech. Desi. Life">
<meta name="twitter:description" content="iOS, Programming, Code, Technology, Design, Life,">
  
    <link rel="alternate" href="/atom.xml" title="Tech. Desi. Life" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="index.html" id="logo">Tech. Desi. Life</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="index.html">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.superyoung.win"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-PictureProcessing/50gray_buffing" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2017/01/27/PictureProcessing/50gray_buffing/" class="article-date">
  <time datetime="2017-01-27T14:32:36.000Z" itemprop="datePublished">2017-01-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2017/01/27/PictureProcessing/50gray_buffing/">中性灰磨皮以及细节增强</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>使用图章等工具进行斑点的消除</li>
<li>新建一个颜色填充图层，填充50%灰色，设置图层混合模式为柔光</li>
<li>新建一个颜色填充图层，填充黑色，设置图层混合模式为颜色</li>
<li>新建一个颜色填充图层，填充黑色，设置图层混合模式为柔光</li>
<li>使用笔刷在中性灰图层更改高光和阴影，重绘所有需要重绘的地方</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.superyoung.win/2017/01/27/PictureProcessing/50gray_buffing/" data-id="ciyga8ew30000lw0gg6poydvx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Photoshop/">Photoshop</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/修图/">修图</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learning_iOS/Reactive-Programming" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2017/01/25/learning_iOS/Reactive-Programming/" class="article-date">
  <time datetime="2017-01-25T07:47:23.000Z" itemprop="datePublished">2017-01-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2017/01/25/learning_iOS/Reactive-Programming/">手把手教你Rx响应式开发 - 响应式应用开发极简入门教程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>原文在此：[Getting Started With RxSwift and RxCocoa </em>by Ellen Shapiro on October 17, 2016<em>](<a href="https://www.raywenderlich.com/138547/getting-started-with-rxswift-and-rxcocoa" target="_blank" rel="external">https://www.raywenderlich.com/138547/getting-started-with-rxswift-and-rxcocoa</a>)</em></p>
<h2 id="0x00-序"><a href="#0x00-序" class="headerlink" title="0x00 序"></a>0x00 序</h2><p>很多面向对象的开发人员都遇到过这样的问题：软件开发过程中，需要开发人员主动地告诉系统什么东西改变了，以此来触发响应。</p>
<p>通常来说这样并没有什么坏处，但是如果有一个办法可以让系统自动发现状态的改变，是不是更好呢？</p>
<p>这就引出了响应式开发最基本的概念：你的应用可以对状态直接进行响应而不需要开发人员参与。这种开发方式可以让开发人员更加专注于逻辑的表达而不是如何对状态进行保存。</p>
<p>在 iOS 中可以使用 Objc 和 Swift 的 KVO 和 didSet 等方法，但是有时候啊这些方法可能就显得太笨重了，Objc 和 Swift 均有不同的响应式框架来解决这个问题。这里主要介绍的是 swift 的 RxSwift 框架。</p>
<p><a href="https://www.raywenderlich.com/126522/reactivecocoa-vs-rxswift" target="_blank" rel="external">如果你想知道更多的背景信息，关于各大主流框架的区别， <em>Rui Peres</em> 写了一篇文章</a></p>
<h2 id="0x01-什么是-RxSwift-和-RxCocoa"><a href="#0x01-什么是-RxSwift-和-RxCocoa" class="headerlink" title="0x01 什么是 RxSwift 和 RxCocoa"></a>0x01 什么是 RxSwift 和 RxCocoa</h2><p>ReactiveX 是一个支持很多编程语言和平台语言工具库 项目。而 RxSwift 和 RxCocoa 是 ReactiveX 套装的一部分。</p>
<p>RxSwift 是一个和 Swift 语言进行交互的框架，而 RxCocoa 则使得 Cocoa 的 APIs 更容易被 Reactive 技术调用。</p>
<p>RxSwift 和 RxCocoa 可以通过 pod 来安装，具体方法自行查看其 github 项目主页。</p>
<h2 id="0x02-基本概念：Observable可观察的-和-Observer-观察者"><a href="#0x02-基本概念：Observable可观察的-和-Observer-观察者" class="headerlink" title="0x02 基本概念：Observable可观察的 和 Observer 观察者"></a>0x02 基本概念：<code>Observable</code><em>可观察的</em> 和 <code>Observer</code> <em>观察者</em></h2><p>我曾经被这些概念混淆了很久，在不同的文章中有不同的称呼，特别是在中文博客中，什么“流”与“信号”齐飞，却少有人按照英文字面的翻译<br>Observable =&gt; 可观察的，Observer =&gt; 观察者，在这篇文章中我将使用这个字面翻译，原因等你看完文章会体会到的。</p>
<p>其实，这个英文名字起的很有意思，Observable 是一个形容词，其实将形容词作为一个类名非常贴切，其在牛津词典中的解释是：<em>Able to be noticed or perceived</em>，而 Observer 是一个名词，在牛津词典中的解释是：<em>A person who watches or notices something</em>。</p>
<p>而这两个词在 Rx 中的含义是：</p>
<ul>
<li>一个<code>可观察的</code>是一个能够提交通知的东西。</li>
<li>一个<code>观察者</code>可以订阅一个<code>可观察的</code>对象，可以接收对象改变的通知，同时进行一些自定义操作。</li>
</ul>
<h2 id="0x03-基本概念：DisposeBag-销毁包"><a href="#0x03-基本概念：DisposeBag-销毁包" class="headerlink" title="0x03 基本概念：DisposeBag 销毁包"></a>0x03 基本概念：<code>DisposeBag</code> <em>销毁包</em></h2><p>是 RxSwift 和 RxCocoa 的工具，用来帮助和 ARC 内存管理进行交互的工具。这是一个给<code>观察者</code>对象的虚拟的 “包”，当其父对象被 deallocate 后，观察者对象的内存也会被释放。</p>
<p>假设某个观察者对象的一个属性是 DisposeBag ，那么当它的 <code>deinit()</code> 方法被调用的时候，这个 “bag” 被清空，并且每个被销毁的观察者都自动的解除订阅，这就允许 ARC 系统去正常地回收内存了。</p>
<p>没有 <code>DisposeBag</code> 的话，将会有两种结果：</p>
<ol>
<li>要么观察者会创造保留环，造成内存泄漏</li>
<li>要么它会在对象的外面被释放掉，造成程序崩溃</li>
</ol>
<p>所以，一定要记得在设置观察者对象的时候增加 DisposeBag。</p>
<hr>
<h2 id="0x04-接下来举个例子：购买巧克力"><a href="#0x04-接下来举个例子：购买巧克力" class="headerlink" title="0x04 接下来举个例子：购买巧克力"></a>0x04 接下来举个例子：购买巧克力</h2><p><em>项目文件：<a href="https://github.com/shengyang998/Chocolates-starter" target="_blank" rel="external">传送门</a></em></p>
<p>Build 并且运行项目，现在这个 demo 还是没有使用响应式的，接下来的教程中，将会展示如何使用响应式来完成这个 demo。</p>
<h2 id="0x05-响应式操作购物车数量"><a href="#0x05-响应式操作购物车数量" class="headerlink" title="0x05 响应式操作购物车数量"></a>0x05 响应式操作购物车数量</h2><p>打开 <code>ShoppingCart.swift</code>，找到购物车内数组的声明<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> chocolates = [<span class="type">Chocolate</span>]()</div></pre></td></tr></table></figure></p>
<p>现在还不是响应式的，要想响应式，将其改成<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> chocolates: <span class="type">Variable</span>&lt;[<span class="type">Chocolate</span>]&gt; = <span class="type">Variable</span>([])</div></pre></td></tr></table></figure></p>
<p>上面语句的作用详述如下：</p>
<ol>
<li>你定义了一个 RxSwift 的 Variable，这个 Variable 是 Swift 数组类型的，数组用了 Chocolate 类型来定义。</li>
<li><code>Variable</code> 是一个类，所以它是引用类型。也就是 chocolates 是 Variable 的一个实例。</li>
<li><code>Variable</code> 有一个属性叫 <code>value</code>。这里是你的 Chocolate 数组存放的地方。</li>
<li><code>Variable</code> 的膜法来自于一个叫 <code>asObservable()</code> 的方法。你可以增加一个观察者来代替每次去手动 check the value。</li>
<li>另外以后访问那个数组的时候，都要通过 <code>value</code> 来访问了。</li>
</ol>
<p>修复 Xcode 当前提示的所有错误，然后继续下面的操作：</p>
<ol>
<li>在文件 <code>ChocolatesOfTheWorldViewController.swift</code> 中增加</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</div></pre></td></tr></table></figure>
<ol>
<li>在 // MARK: Rx Setup 下面增加</li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupCartObserver</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="type">ShoppingCart</span>.sharedCart.chocolates.asObservable()</div><div class="line">    .subscribe(onNext:&#123;</div><div class="line">        (chocolates) <span class="keyword">in</span></div><div class="line">        <span class="keyword">self</span>.cartButton.title = <span class="string">"\(chocolates.count) \u&#123;1f36b&#125;"</span></div><div class="line">        &#125;)</div><div class="line">    .addDisposableTo(disposeBag)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这将会设置一个响应式的观察者去自动更新购物车。</p>
<p>上面的代码具体做了什么？详述如下：</p>
<ol>
<li>首先，获取购物车的 chocolates as an Observable</li>
<li>每次 Observable 中的值更新后都会调用其观察者的 <code>subscribe(onNext:)</code> ，其中传入的参数就是被改变的值。</li>
<li>记得每次 subscribe 后都要 addDisposableTo。</li>
</ol>
<p>接下来，在 <code>viewDidLoad()</code> 方法中调用 <code>setupCartObserver()</code>，并且删除那个非私有的 <code>updateCartButton()</code> 方法，修复错误。</p>
<h2 id="0x06-响应式操作-TableView"><a href="#0x06-响应式操作-TableView" class="headerlink" title="0x06 响应式操作 TableView"></a>0x06 响应式操作 TableView</h2><p>现在你已经让购物车响应式了，接下来你将会看到如何使用 RxCocoa 来让 UITableView 响应式。</p>
<p>RxCocoa 包含一些 UI 控件的响应式的 API，这使得你可以控制像 UITableView 等控件而不需要 override 代理和数据源方法</p>
<p>为了演示怎么做，删除整个 UITableViewDataSource 和 UITableViewDelegate 扩展，然后删除 viewDidLoad 方法里注册 dataSource 和 delegate 的语句。</p>
<p>编译并且运行一下，你将会发现整个 TableView 都空了，那么好，接下来你需要使 TableView 中的一些东西响应化，首先，在文件 <code>ChocolatesOfTheWorldViewController.swift</code> 中，把属性<code>europeanChocolates</code>改成一个可观察的：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> europeanChocolates = <span class="type">Observable</span>.just(<span class="type">Chocolate</span>.ofEurope)</div></pre></td></tr></table></figure></p>
<p><code>可观察的值</code>不会有任何改变，但是当你仍然想要像一个可观察的值一样访问它的时候，使用<code>just(_:)</code>方法。<br><em>Sometimes, calling <code>just(_:)</code> is an indication that using Reactive programming might be overkill—after all, if a value never changes, why use a programming technique designed to react to changes? In this example, you’re using it to set up reactions of table view cells which will change, but it’s always a good idea to look carefully at how you’re using Rx. Just because you have a hammer doesn’t mean every problem is a nail.</em></p>
<p>现在你已经让 europeanChocolates 变成可观察的了，那么接下来增加下面的函数：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupCellConfig</span><span class="params">()</span></span>&#123;</div><div class="line">    europeanChocolates.bindTo(tableView</div><div class="line">        .rx.items(cellIdentifier: <span class="type">ChocolateCell</span>.<span class="type">Identifier</span>, cellType: <span class="type">ChocolateCell</span>.<span class="keyword">self</span>))&#123;</div><div class="line">            (row, chocolate, cell) <span class="keyword">in</span></div><div class="line">            cell.configureWithChocolate(chocolate: chocolate)</div><div class="line">        &#125;.addDisposableTo(disposeBag)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里做的事是：</p>
<ol>
<li>你调用了<code>bindTo(_:)</code>去关联可观察的 europeanChocolates，上面的代码应该每行都调用一次</li>
<li>通过 <code>rx.</code> 可以访问 RxCocoa 对于 UI 控件的扩展，在这里是 UITableView</li>
<li>调用 Rx 方法，<code>items(cellIdentifier: cellType:)</code>，传入 cell identifier 和 cell 的类型。这将允许 Rx 调用离队方法（dequeuing method）</li>
<li>也可以传入一个 block ，每一个新 item 都会执行这个 block。你会获得关于这一行的返回信息，和 cell，这使得它配置 cell 超级简单。</li>
<li>加入 disposeBag</li>
</ol>
<p>通常情况下经过<code>tableView(_:numberOfRowsInSection:)</code>和<code>numberOfSection(in:)</code>计算的值现在自动根据被观察的值来自动计算。而<code>tableView(_: cellForRowAt:)</code>代理方法已经被闭包代替。</p>
<p>现在，去<code>viewDidLoad()</code>方法中添加下面这行代码，调用你的新设置方法：<br><code>setupCellConfig()</code></p>
<p>现在，如果你点击 tableView 的任何一行，都不会有反应。因为当你删除<code>tableView(_: didSelectRowAt:)</code>的时候，tableView 已经不能识别点击动作了。</p>
<p>为了解决点击问题，RxCocoa 有一个<code>modelSelected(_:)</code>方法，这个方法会返回一个 Observable，你可以使用它去观察关于被选择对象的信息。增加如下方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupCellTapHandling</span><span class="params">()</span></span>&#123;</div><div class="line">    tableView.rx.modelSelected(<span class="type">Chocolate</span>.<span class="keyword">self</span>) <span class="comment">//1</span></div><div class="line">    .subscribe(onNext:&#123; <span class="comment">//2</span></div><div class="line">        chocolate <span class="keyword">in</span></div><div class="line">        <span class="type">ShoppingCart</span>.sharedCart.chocolates.value.append(chocolate)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> selectedRowIndexPath = <span class="keyword">self</span>.tableView.indexPathForSelectedRow&#123;</div><div class="line">            <span class="keyword">self</span>.tableView.deselectRow(at: selectedRowIndexPath, animated:<span class="literal">true</span>)</div><div class="line">        &#125; <span class="comment">//3</span></div><div class="line">        &#125;).addDisposableTo(disposeBag) <span class="comment">//4</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一步一步来解释：</p>
<ol>
<li>给 table view 的扩展方法<code>modelSelected(_:)</code>传入一个<code>Chocolate model</code>来获取返回值的正确类型。这个方法返回一个 Observable。</li>
<li>获取那个 Observable，调用<code>subscribe(onNext:)</code>方法，传入一个尾随闭包，这个闭包将会在每次 model 被选中的时候执行。</li>
<li>当<code>self.tableView.indexPathForSelectedRow</code>有值的时候，也就是被选中的时候，取消选择它。</li>
<li>记得加入 DisposeBag</li>
</ol>
<p>最后记得在 viewDidLoad 中加入对上面函数的调用。</p>
<h2 id="0x07-文本响应式输入"><a href="#0x07-文本响应式输入" class="headerlink" title="0x07 文本响应式输入"></a>0x07 文本响应式输入</h2><p>在一般应用中，文字输入的处理一般都交给<code>UITextFieldDelegate</code>来做，通常其方法里会包含很多的 if/else 来决定哪个操作和逻辑应该被执行。Reactive 则不同。体会一下：</p>
<p>在<code>BillingInfoViewController.swift</code>中增加 DisposeBag<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</div></pre></td></tr></table></figure></p>
<p>下面的代码展示了如何根据用户的输入展示信用卡的图标：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupCardImageDisplay</span><span class="params">()</span></span>&#123;</div><div class="line">    cardType.asObservable()</div><div class="line">    .subscribe(onNext:&#123;</div><div class="line">        cardType <span class="keyword">in</span></div><div class="line">        <span class="keyword">self</span>.careditCardImageView.image = cardType.image</div><div class="line">        &#125;).addDisposableTo(disposeBag)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来处理一些有趣的事，如果用户打字很快，你可能不想立即处理输入的字符，否则可能会导致应用执行缓慢。解决办法很简单，使用<code>throttle</code>，按照间隔时间来执行逻辑而不是每次改变都执行。</p>
<p>废话不多说，直接上代码：</p>
<p>首先，在<code>BillingInfoViewController</code>中增加如下代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">let</span> throttleInterVal = <span class="number">0.1</span></div></pre></td></tr></table></figure></p>
<p>这里以秒为单位定义了 throttle length 的常数。</p>
<p>然后再增加如下代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">setupTextChangeHandling</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">let</span> creditCardValid = creditCardNumberTextField</div><div class="line">    .rx.text.throttle(throttleInterVal, scheduler: <span class="type">MainScheduler</span>.instance) <span class="comment">//1</span></div><div class="line">    .<span class="built_in">map</span>&#123; <span class="keyword">self</span>.validate(cardText: $<span class="number">0</span>) &#125; <span class="comment">//2</span></div><div class="line"></div><div class="line">    creditCardValid.subscribe(onNext:&#123;</div><div class="line">        <span class="keyword">self</span>.creditCardNumberTextField.valid = $<span class="number">0</span> <span class="comment">//3</span></div><div class="line">        &#125;).addDisposableTo(disposeBag) <span class="comment">//4</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Note:如果你在设置 creditCardValid 的时候得到一个“<em>Generic parameter R could not be inferred</em>”错误，你可以显式地指明 creditCardValid 的类型：<code>let creditCardValid: Observable</code>。理论上编译器应该能够自动推断出这个类型，但是有时候它可能需要一点动力🙂</strong></p>
<p>好，那么这些代码做了什么呢？我们继续一步步分析：</p>
<ol>
<li>你对输入进行了 <code>throttle</code> 操作，所以验证逻辑只会根据你在上面设置的时间来执行。<code>scheduler</code>参数是一个更高级的概念，简单来说它是用来绑定一个线程的，如果你要使用主线程的话，则设置为<code>MainScheduler</code>（UI 操作都需要主线程）</li>
<li>通过调用<code>validate(cardText)</code>来把 throttle 输入流 map 成一个 Boolean 类型的流。</li>
<li>获取并且订阅 creditCardValid ，基于输入来改变 text field 的验证状态。</li>
<li>加入 DisposeBag ，不费话了</li>
</ol>
<p>接下来响应式操作 Expiration date 和 CVV Code在<code>setupTextChangeHandling()</code>底部继续增加如下代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> expirationValid = expirationDateTextField</div><div class="line">.rx.text.throttle(throttleInterval, scheduler: <span class="type">MainScheduler</span>.instance)</div><div class="line">  .<span class="built_in">map</span> &#123; <span class="keyword">self</span>.validate(expirationDateText: $<span class="number">0</span>) &#125;</div><div class="line"></div><div class="line">expirationValid.subscribe(onNext: &#123;</div><div class="line">    <span class="keyword">self</span>.expirationDateTextField.valid = $<span class="number">0</span></div><div class="line">    &#125;).addDisposableTo(disposeBag)</div><div class="line"></div><div class="line"><span class="keyword">let</span> cvvValid = cvvTextField</div><div class="line">  .rx.text.<span class="built_in">map</span> &#123; <span class="keyword">self</span>.validate(cvvText: $<span class="number">0</span>) &#125;</div><div class="line"></div><div class="line">cvvValid</div><div class="line">  .subscribe(onNext: &#123; <span class="keyword">self</span>.cvvTextField.valid = $<span class="number">0</span> &#125;)</div><div class="line">  .addDisposableTo(disposeBag)</div></pre></td></tr></table></figure></p>
<p>现在，你获取了三个文本框的所有可观察的值，那么增加下面的代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> everythingValid = <span class="type">Observable</span></div><div class="line">    .combineLatest(creditCardValid, expirationValid, cvvValid)&#123;</div><div class="line">    $<span class="number">0</span> &amp;&amp; $<span class="number">1</span> &amp;&amp; $<span class="number">2</span> <span class="comment">//all must be true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">everythingValid.bindTo(purchaseButton.rx.enable)</div><div class="line">    .addDisposableTo(disposeBag)</div></pre></td></tr></table></figure></p>
<p>这里用到了 Observable 的类方法：<code>combineLatest()</code>，好好体会一下。</p>
<p><code>everythingValid</code>然后和 UIButton 在 rx 扩展内的<code>enabled</code>属性绑定了，所以按钮的状态被 <code>everythingValid</code> 的值来控制。如果所有三个文本域都为真，按钮才能被按下</p>
<p>好的，现在你已经写好设置方法了，在<code>viewDidLoad()</code>中调用它吧：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">setupCardImageDisplay()</div><div class="line">setupTextChangeHandling()</div></pre></td></tr></table></figure></p>
<p>接下来运行一下看看效果，好好体会，如果有什么问题，尽管提交 issue。</p>
<h2 id="0x08-尾声"><a href="#0x08-尾声" class="headerlink" title="0x08 尾声"></a>0x08 尾声</h2><p>如果你想多尝试一下，试试看：</p>
<ol>
<li>让 <code>CartViewController</code> 使用一个响应式的 TableView 来展示购物车的数据，而不是一个 Label。</li>
<li>允许用户直接在购物车页面增加或者移除巧克力，自动更新总价。</li>
</ol>
<p>好了，这只是一个开始，如果你想了解更多关于响应式编程的内容的话，下面的内容你绝对不会错过：</p>
<ol>
<li><a href="http://slack.rxswift.org/" target="_blank" rel="external">RxSwift Slack</a></li>
<li><a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md" target="_blank" rel="external">RxSwift’s Getting Started guide</a></li>
<li><a href="https://realm.io/news/slug-max-alexander-functional-reactive-rxswift/" target="_blank" rel="external">Max Alexander’s talk on Rx at Realm</a></li>
<li><a href="http://rx-marin.com" target="_blank" rel="external">rx-marin</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.superyoung.win/2017/01/25/learning_iOS/Reactive-Programming/" data-id="ciyga8ewf0003lw0gsoxm9epx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/programming/">programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/入门/">入门</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/响应式/">响应式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/开发/">开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learning_iOS/SequenceType" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2017/01/25/learning_iOS/SequenceType/" class="article-date">
  <time datetime="2017-01-25T07:47:23.000Z" itemprop="datePublished">2017-01-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2017/01/25/learning_iOS/SequenceType/">关于 SequenceType</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="从-Array-开始"><a href="#从-Array-开始" class="headerlink" title="从 Array 开始"></a>从 Array 开始</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.superyoung.win/2017/01/25/learning_iOS/SequenceType/" data-id="ciyga8ewh0004lw0gh4ucqt77" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Sequence/">Sequence</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/programming/">programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/type/">type</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learning_iOS/debugPrint" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2017/01/15/learning_iOS/debugPrint/" class="article-date">
  <time datetime="2017-01-15T02:29:44.000Z" itemprop="datePublished">2017-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2017/01/15/learning_iOS/debugPrint/">Debug Print in iOS Programming</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>请先参考<a href="http://swifter.tips/print/" target="_blank" rel="external">王魏的博客 Swifter</a></em></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.superyoung.win/2017/01/15/learning_iOS/debugPrint/" data-id="ciyga8eww000alw0g6xlefg3t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Coming-soon/">Coming soon...</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learning_iOS/get-type-of-instance" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2017/01/15/learning_iOS/get-type-of-instance/" class="article-date">
  <time datetime="2017-01-15T02:17:03.000Z" itemprop="datePublished">2017-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2017/01/15/learning_iOS/get-type-of-instance/">Swift 中如何获取实例类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>关于一门编程语言的动态特性，最基础的就是获取一个实例的类型。</p>
<h2 id="在-ObjC-中我们怎么做？"><a href="#在-ObjC-中我们怎么做？" class="headerlink" title="在 ObjC 中我们怎么做？"></a>在 ObjC 中我们怎么做？</h2><p>在 ObjC 中我们可以通过一个实例的 class 方法来获取其类型名<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDate</span> *date = [<span class="built_in">NSDate</span> date];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="built_in">NSStringFromClass</span>([date <span class="keyword">class</span>]));</div></pre></td></tr></table></figure></p>
<h2 id="在-Swift-中没有实例的-class-方法"><a href="#在-Swift-中没有实例的-class-方法" class="headerlink" title="在 Swift 中没有实例的 class 方法"></a>在 Swift 中没有实例的 class 方法</h2><p>可以求助于 ObjC 运行时，调用 <code>object_getClass(AnyTypeInstance)</code>。例子如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> date = <span class="type">NSDate</span>()</div><div class="line"><span class="built_in">print</span>(object_getClass(date))</div></pre></td></tr></table></figure></p>
<h2 id="object-getClass-方法返回类型是？"><a href="#object-getClass-方法返回类型是？" class="headerlink" title="object_getClass() 方法返回类型是？"></a><code>object_getClass()</code> 方法返回类型是？</h2><p>是 AnyClass! 可以通过 <code>debugPrint</code> 来验证，关于 <code>debugPrint</code>，参见<a href="../debugPrint/README.md">debugPrint()</a></p>
<h2 id="更加符合-Swift-风格的做法"><a href="#更加符合-Swift-风格的做法" class="headerlink" title="更加符合 Swift 风格的做法"></a>更加符合 Swift 风格的做法</h2><p>Swift 2 以前的方法，已抛弃<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> date = <span class="type">NSDate</span>()</div><div class="line"><span class="built_in">print</span>(date.<span class="keyword">dynamicType</span>)</div></pre></td></tr></table></figure></p>
<p>Swift 3.0 以后使用 <code>type(of:AnyTypeInstance)</code>方法<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> date = <span class="type">NSDate</span>()</div><div class="line"><span class="built_in">print</span>(type(of:date))</div></pre></td></tr></table></figure></p>
<p><em>参考:</em></p>
<ol>
<li><em><a href="http://swifter.tips/instance-type/" target="_blank" rel="external">王魏的博客 Swifter</a></em></li>
<li><em><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Types.html" target="_blank" rel="external">Apple 官方文档关于 Metatype Type 的内容</a></em></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.superyoung.win/2017/01/15/learning_iOS/get-type-of-instance/" data-id="ciyga8ewx000clw0go6kb04br" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Programming/">Programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Swift/">Swift</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/instance/">instance</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/language/">language</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/type/">type</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learning_iOS/Block-in-Objc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2017/01/04/learning_iOS/Block-in-Objc/" class="article-date">
  <time datetime="2017-01-03T17:13:54.000Z" itemprop="datePublished">2017-01-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2017/01/04/learning_iOS/Block-in-Objc/">Block 简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>块可以实现闭包。块与函数类似，只不过是直接定义在另一个函数里。块可以访问、捕获它被声明的区域内的所有变量。而且因为有返回类型，块其实也可以作为个值来对待。</p>
<h2 id="定义-Block-的语法结构如下"><a href="#定义-Block-的语法结构如下" class="headerlink" title="定义 Block 的语法结构如下"></a>定义 Block 的语法结构如下</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return_type (^block_name)(parameters)&#123;&#125;</div></pre></td></tr></table></figure>
<h2 id="Block-捕获的变量是不可以在-Block-中修改的"><a href="#Block-捕获的变量是不可以在-Block-中修改的" class="headerlink" title="Block 捕获的变量是不可以在 Block 中修改的"></a>Block 捕获的变量是不可以在 Block 中修改的</h2><p>若要修改，该变量需要在声明的时候加上 <code>__block</code> 修饰符。</p>
<h2 id="Block-和-Grand-Central-Dispatch"><a href="#Block-和-Grand-Central-Dispatch" class="headerlink" title="Block 和 Grand Central Dispatch"></a>Block 和 Grand Central Dispatch</h2><p><code>Grand Central Dispatch</code> 是一种与 <code>Block</code> 有关的技术，它提供了对线程的抽象，这种抽象基于派发队列<code>dispatch queue</code>，开发者可以将 <code>Block</code> 排入队列中，由 <code>GCD</code> 负责调度。</p>
<h2 id="小心保留环"><a href="#小心保留环" class="headerlink" title="小心保留环"></a>小心保留环</h2><p>若在类的实例方法中定义一个块，那么块会捕获 <code>self</code> 变量，如果 <code>self</code> 所指代的那个对象同时也保留了块，则会导致“保留环”。</p>
<h2 id="解决保留环问题"><a href="#解决保留环问题" class="headerlink" title="解决保留环问题"></a>解决保留环问题</h2><p>一般来说，只要适时清理掉换中的某个引用，就不会有问题，然而未必总有机会。在块的最后令 <code>Handler = nil;</code> 即可。</p>
<h2 id="全局快、栈块、堆块"><a href="#全局快、栈块、堆块" class="headerlink" title="全局快、栈块、堆块"></a>全局快、栈块、堆块</h2><p>栈块所占据的内存空间可能会被自动覆写，若被覆写，则运行时将会出错。解决此问题可以给块对象发送 <code>copy</code> 消息，示例如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">block = [^&#123;codeInBlock&#125; <span class="keyword">copy</span>];</div></pre></td></tr></table></figure></p>
<h2 id="为常用块创建-typedef"><a href="#为常用块创建-typedef" class="headerlink" title="为常用块创建 typedef"></a>为常用块创建 typedef</h2><p>创建的语法规则：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>(^block_name)(parameters);</div></pre></td></tr></table></figure></p>
<p>调用的语法规则：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">block_name block = ^(parameters)&#123;&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.superyoung.win/2017/01/04/learning_iOS/Block-in-Objc/" data-id="ciyga8ew80001lw0gmzi2abj1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Block/">Block</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/programming/">programming</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learning_iOS/coordinate-system" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2017/01/04/learning_iOS/coordinate-system/" class="article-date">
  <time datetime="2017-01-03T17:12:31.000Z" itemprop="datePublished">2017-01-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2017/01/04/learning_iOS/coordinate-system/">Coordinate System</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>每一个 view 都有它的 coordinate system。 原点在（0，0）， 拥有宽度和高度属性。<br>在 iOS 中使用 <code>bounds</code> 来描述 coordinate system。<br>iOS 中的 <code>frame</code> 的 <code>origin</code> 属性会含有相对于 superview 的 coordinate system 坐标。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.superyoung.win/2017/01/04/learning_iOS/coordinate-system/" data-id="ciyga8ewq0008lw0gncyz5rol" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Coordinate/">Coordinate</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/System/">System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/programming/">programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/坐标系统/">坐标系统</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learning_iOS/UIAlertController" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2017/01/04/learning_iOS/UIAlertController/" class="article-date">
  <time datetime="2017-01-03T17:09:49.000Z" itemprop="datePublished">2017-01-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2017/01/04/learning_iOS/UIAlertController/">关于UIAlertController</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在 iOS8 以后，苹果推出了一个新的 Alert 类：<code>UIAlertController</code>。原有的<code>UIAlertView</code>已经不推荐使用。故本文主要介绍<code>UIAlertController</code></p>
<h2 id="如何使用UIAlertController"><a href="#如何使用UIAlertController" class="headerlink" title="如何使用UIAlertController"></a>如何使用UIAlertController</h2><ol>
<li>实例化方法：<code>UIAlertController *alert = [UIAlertController alertControllerWithTitle:(NSString*)title message:(NSString*)msg preferredStyle:(UIAlertControllerStyle)style];</code></li>
<li>显示方法：<code>[self presentViewController:(UIAlertController*)con animation:... completion:(^)block];</code><h2 id="关于UIAlertAction"><a href="#关于UIAlertAction" class="headerlink" title="关于UIAlertAction"></a>关于UIAlertAction</h2></li>
<li>实例化方法：<code>[UIAlertAction *action = [UIAlertActionWithTitle:(NSString*)title style:... handler:(^)block]];</code></li>
<li>为了在一个 Alert 中添加选项按钮，可以将一个<code>UIAlertAction</code>对象添加到一个<code>UIAlertController</code>对象。发送如下消息即可：<br><code>[alert addAction:(UIAlertAction*)action];</code><h2 id="如何自定义-UIAlertController"><a href="#如何自定义-UIAlertController" class="headerlink" title="如何自定义 UIAlertController"></a>如何自定义 UIAlertController</h2><h3 id="先定一个小目标，比如说，添加一个-UITextField："><a href="#先定一个小目标，比如说，添加一个-UITextField：" class="headerlink" title="先定一个小目标，比如说，添加一个 UITextField："></a>先定一个小目标，比如说，添加一个 UITextField：</h3></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.superyoung.win/2017/01/04/learning_iOS/UIAlertController/" data-id="ciyga8ewj0005lw0gagaf9u9q" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Objective-C/">Objective C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/UIAlertController/">UIAlertController</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/programming/">programming</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learning_iOS/UITableView" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2017/01/04/learning_iOS/UITableView/" class="article-date">
  <time datetime="2017-01-03T17:07:32.000Z" itemprop="datePublished">2017-01-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2017/01/04/learning_iOS/UITableView/">UITableView</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="设置数据源-（UITableViewDataSource）"><a href="#设置数据源-（UITableViewDataSource）" class="headerlink" title="设置数据源 （UITableViewDataSource）"></a>设置数据源 （UITableViewDataSource）</h2><p>需要<code>数据源</code>来展示数据，dataSource。会向数据源查询一共多少行数据以及每一行显示什么数据</p>
<p>不论什么对象，只要其遵循 <code>UITableViewDataSource</code> 协议即可。</p>
<p>UITableViewDataSource协议中有三个需要实现的函数</p>
<ol>
<li><p>tableview 有几组（section）？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSInteger</span>) numberOfSectionInTableView: (<span class="built_in">UITableView</span>*) tableView;</div></pre></td></tr></table></figure>
</li>
<li><p>每组（section）几行？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSInteger</span>) tableView:(<span class="built_in">UITableView</span>*)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section;</div></pre></td></tr></table></figure>
</li>
<li><p>每组每行分别显示什么内容（cell）？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UITableViewCell</span>*) tableView:(<span class="built_in">UITableView</span>*)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span>*)indexPath;</div></pre></td></tr></table></figure>
</li>
<li><p>每组的 titleForHeader 和 titleForFooter。这两个字体不可更改，如果有需要，使用自定义的 UILabel。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span>*)tableView:(<span class="built_in">UITableView</span>*)tableView titleForHeaderInSection:(<span class="built_in">NSInteger</span>)section;</div><div class="line">- (<span class="built_in">NSString</span>*)tableView:(<span class="built_in">UITableView</span>*)tableView titleForFooterInSection:(<span class="built_in">NSInteger</span>)section;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="怎么判断是哪一组哪一行呢？"><a href="#怎么判断是哪一组哪一行呢？" class="headerlink" title="怎么判断是哪一组哪一行呢？"></a>怎么判断是哪一组哪一行呢？</h3><p>看到上面的参数indexPath了吗？这样判断组：</p>
<ul>
<li><code>if(0 == indexPath.section){}</code></li>
</ul>
<p>这样判断行：</p>
<ul>
<li><code>if(0 == indexPath.row){}</code></li>
</ul>
<h3 id="关于UITableViewCell"><a href="#关于UITableViewCell" class="headerlink" title="关于UITableViewCell"></a>关于UITableViewCell</h3><p>初始化方法：<br><code>UITableViewCell* cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:nil];</code></p>
<h4 id="contentView是什么？"><a href="#contentView是什么？" class="headerlink" title="contentView是什么？"></a>contentView是什么？</h4><p><code>UITableViewCell</code>中有个默认的子视图<code>contentView</code>， <code>contentView</code>是所有其他内容的父视图。<br>可以通过其下的<code>accessoryType</code>来显示辅助指示视图。</p>
<h4 id="UITableViewCellStyle-类型"><a href="#UITableViewCellStyle-类型" class="headerlink" title="UITableViewCellStyle 类型"></a>UITableViewCellStyle 类型</h4><ul>
<li>UITableViewCellStyleDefault</li>
<li>UITableViewCellStyleSubtitle</li>
<li>UITableViewCellStyleValue1</li>
<li>UITableViewCellStyleValue2</li>
</ul>
<h3 id="UITableViewCell-的结构"><a href="#UITableViewCell-的结构" class="headerlink" title="UITableViewCell 的结构"></a>UITableViewCell 的结构</h3><ul>
<li><code>UITableViewCell</code></li>
<li>-&gt;<code>.imageView</code></li>
<li>-&gt;<code>.textLabel</code></li>
<li>-&gt;<code>.detailTextLabel</code></li>
<li>-&gt;<code>.contentView</code></li>
</ul>
<p>cell 里面包含默认一些子控件，不过也可以自己用 xib 定义。</p>
<h2 id="设置代理-delegate"><a href="#设置代理-delegate" class="headerlink" title="设置代理(delegate)"></a>设置代理(delegate)</h2><h3 id="为什么要设置代理？"><a href="#为什么要设置代理？" class="headerlink" title="为什么要设置代理？"></a>为什么要设置代理？</h3><ul>
<li><code>对象A</code>内部发生了一些事情，想要通知<code>对象B</code></li>
<li><code>对象B</code>想监听<code>对象A</code>内部发生的事情</li>
<li><code>对象A</code>想在自己内部调用<code>对象B</code>的一些方法，而又不想有互相的耦合依赖</li>
</ul>
<p>以上情况下，<code>对象B</code>都是<code>对象A</code>的代理。</p>
<h3 id="如何设置代理对象"><a href="#如何设置代理对象" class="headerlink" title="如何设置代理对象"></a>如何设置代理对象</h3><ol>
<li>在<code>Stroyboard</code>的<code>UIScrollView</code>上右键单击，拖<code>delegate</code>到<code>UIViewController</code>上。</li>
<li>在方法<code>viewDidLoad</code>中添加<code>self.tableView.delegate = self;</code><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><code>类名+Delegate</code><br><em>例如<code>UITableViewDelegate</code>就是<code>UITableView</code>+<code>Delegate</code></em></li>
</ol>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>如果是为一个类特别定义的协议，可以直接写在<code>.h</code>文件里，如果多个类使用同一个协议，建议建立一个<code>protocol</code>文件。</p>
<ul>
<li>关于定义格式，举个例子：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UITableView</span>&lt;<span class="title">NSObject</span>, <span class="title">UIScrollView</span>&gt;</span></div><div class="line"><span class="keyword">@required</span></div><div class="line">- (ReturnType) MethodName;</div><div class="line"><span class="keyword">@optional</span></div><div class="line">- (ReturnType) MethodName;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>默认是<code>@required</code>，但是这只能作为编译器检查的标准，使用时需要自己验证是否实现了具体的方法，验证方法如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>([<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(MethodName)])&#123;</div><div class="line">    MethodName</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><h4 id="首先定义一个-protocol"><a href="#首先定义一个-protocol" class="headerlink" title="首先定义一个@protocol"></a>首先定义一个<code>@protocol</code></h4><p>声明协议方法</p>
<h4 id="定义一个委托-interface"><a href="#定义一个委托-interface" class="headerlink" title="定义一个委托@interface"></a>定义一个委托<code>@interface</code></h4><p>引入<code>protocol.h</code></p>
<h4 id="定义一个代理-interface"><a href="#定义一个代理-interface" class="headerlink" title="定义一个代理@interface"></a>定义一个代理<code>@interface</code></h4><p>在<code>@interface</code>声明中声明遵守<code>@protocol</code>协议。例如：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">viewController</span> () &lt;<span class="title">protocolName</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>然后在<code>@implementation</code>中实现具体的协议方法</p>
<h2 id="单组数据和多组数据"><a href="#单组数据和多组数据" class="headerlink" title="单组数据和多组数据"></a>单组数据和多组数据</h2><p>其本质都是 <code>UITableVIew</code> ，具体的差别其实就是UITableView的属性 <code>UITableViewStylePlain</code> 和 <code>UITableViewStyleGrouped</code>的设置。</p>
<h2 id="好，那么接下来梳理一下一个-UITableView-从初始化到展示的流程："><a href="#好，那么接下来梳理一下一个-UITableView-从初始化到展示的流程：" class="headerlink" title="好，那么接下来梳理一下一个 UITableView 从初始化到展示的流程："></a>好，那么接下来梳理一下一个 <code>UITableView</code> 从初始化到展示的流程：</h2><ol>
<li>初始化一个 <code>UITableView</code> 对象</li>
</ol>
<ul>
<li>设置数据源，数据源需要遵循协议至少实现如下三个方法 <code>numberOfSectionInTableView</code> <code>numberOfRowsInSection</code> <code>cellForRowAtIndexPath</code></li>
<li>如有需要自行构造一个 <code>UITableViewCell</code> 并使用上面的第三个方法（<code>cellForRowAtIndexPath</code>）返回。</li>
</ul>
<h2 id="自定义cell"><a href="#自定义cell" class="headerlink" title="自定义cell"></a>自定义cell</h2><p>Coming soon…</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.superyoung.win/2017/01/04/learning_iOS/UITableView/" data-id="ciyga8ewo0007lw0g439rw5we" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/DataSource/">DataSource</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Delegate/">Delegate</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/ObjC/">ObjC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/UITableView/">UITableView</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/programming/">programming</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-learning_iOS/keyboard-dissmissing" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="2017/01/04/learning_iOS/keyboard-dissmissing/" class="article-date">
  <time datetime="2017-01-03T17:04:40.000Z" itemprop="datePublished">2017-01-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="2017/01/04/learning_iOS/keyboard-dissmissing/">iOS 关闭键盘方式的小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="收起键盘方法"><a href="#收起键盘方法" class="headerlink" title="收起键盘方法"></a>收起键盘方法</h2><ol>
<li>点击<code>return</code>键收起，使用<code>UITextFieldDelegate</code>中的方法<br><code>- (BOOL)textFieldShouldReturn:(UITextField *)textField{return [textField resignFirstResponder]; return YES;}</code></li>
</ol>
<ul>
<li>点击<code>done</code>键收起，先将<code>UITextField</code>对象的<code>Return Key</code>属性修改为<code>done</code>，再自定义一个方法并将其和 <code>done</code> 的 <code>Did End On Exit</code> 连接起来：</li>
<li><p>(IBAction) textFieldDoneEditing:(id)sender{[sender resignFirstResponder];}</p>
</li>
<li><p>在键盘外点击关闭键盘<br>在<code>UITextField</code>对象外的视图控制器类的<code>viewDidLoad</code>方法中定义一个<code>UIGestureRecofnizer</code>对象（使用<code>[[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(dismissKb)]</code>方法初始化，并且使用<code>[self.view addGestureRecognizer:tap];</code>加入视图。</p>
</li>
</ul>
<p>然后记得实现<code>@selector()</code>中的方法：<code>- (void)dismissKb</code></p>
<ul>
<li><p>点击背景 View 收起键盘<br><code>[self.view endEditing:YES];</code></p>
</li>
<li><p>在任何地方加上这句话，统一收起键盘<br><code>[[[UIApplication sharedApplication] keyWindow] endEditing:YES];</code></p>
</li>
<li><p>发送 <code>resignFirstResponder</code> 消息<br><code>[[UIApplication sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];</code></p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>当你能获取 <code>UITextField</code> 对象时，最好使用 <code>[obj resignFirstResponder]</code> 方法</li>
</ol>
<ul>
<li>如果有很多 <code>UITextField</code> 对象，而且可以获取到 <code>viewController</code> 的 <code>view</code> 时，可以使用 <code>[self.view endEditing:YES]</code> 方法</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.superyoung.win/2017/01/04/learning_iOS/keyboard-dissmissing/" data-id="ciyga8ewz000flw0ghipwjsl4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Objective-C/">Objective C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/keyboard/">keyboard</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/programming/">programming</a></li></ul>

    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="tags/Block/">Block</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/Coming-soon/">Coming soon...</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/Coordinate/">Coordinate</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/DataSource/">DataSource</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/Delegate/">Delegate</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/ObjC/">ObjC</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/Objective-C/">Objective C</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/Photoshop/">Photoshop</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/Programming/">Programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/Sequence/">Sequence</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/Swift/">Swift</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/System/">System</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/UIAlertController/">UIAlertController</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/UITableView/">UITableView</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/iOS/">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/instance/">instance</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/keyboard/">keyboard</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/language/">language</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/programming/">programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/type/">type</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/修图/">修图</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/入门/">入门</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/响应式/">响应式</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/坐标系统/">坐标系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="tags/开发/">开发</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="tags/Block/" style="font-size: 10px;">Block</a> <a href="tags/Coming-soon/" style="font-size: 10px;">Coming soon...</a> <a href="tags/Coordinate/" style="font-size: 10px;">Coordinate</a> <a href="tags/DataSource/" style="font-size: 10px;">DataSource</a> <a href="tags/Delegate/" style="font-size: 10px;">Delegate</a> <a href="tags/ObjC/" style="font-size: 10px;">ObjC</a> <a href="tags/Objective-C/" style="font-size: 13.33px;">Objective C</a> <a href="tags/Photoshop/" style="font-size: 10px;">Photoshop</a> <a href="tags/Programming/" style="font-size: 10px;">Programming</a> <a href="tags/Sequence/" style="font-size: 10px;">Sequence</a> <a href="tags/Swift/" style="font-size: 10px;">Swift</a> <a href="tags/System/" style="font-size: 10px;">System</a> <a href="tags/UIAlertController/" style="font-size: 10px;">UIAlertController</a> <a href="tags/UITableView/" style="font-size: 10px;">UITableView</a> <a href="tags/iOS/" style="font-size: 20px;">iOS</a> <a href="tags/instance/" style="font-size: 10px;">instance</a> <a href="tags/keyboard/" style="font-size: 10px;">keyboard</a> <a href="tags/language/" style="font-size: 10px;">language</a> <a href="tags/programming/" style="font-size: 16.67px;">programming</a> <a href="tags/type/" style="font-size: 13.33px;">type</a> <a href="tags/修图/" style="font-size: 10px;">修图</a> <a href="tags/入门/" style="font-size: 10px;">入门</a> <a href="tags/响应式/" style="font-size: 10px;">响应式</a> <a href="tags/坐标系统/" style="font-size: 10px;">坐标系统</a> <a href="tags/开发/" style="font-size: 10px;">开发</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="archives/2017/01/">一月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="2017/01/27/PictureProcessing/50gray_buffing/">中性灰磨皮以及细节增强</a>
          </li>
        
          <li>
            <a href="2017/01/25/learning_iOS/Reactive-Programming/">手把手教你Rx响应式开发 - 响应式应用开发极简入门教程</a>
          </li>
        
          <li>
            <a href="2017/01/25/learning_iOS/SequenceType/">关于 SequenceType</a>
          </li>
        
          <li>
            <a href="2017/01/15/learning_iOS/debugPrint/">Debug Print in iOS Programming</a>
          </li>
        
          <li>
            <a href="2017/01/15/learning_iOS/get-type-of-instance/">Swift 中如何获取实例类型</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Yu Shengyang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="index.html" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="fancybox/jquery.fancybox.css">
  <script src="fancybox/jquery.fancybox.pack.js"></script>


<script src="js/script.js"></script>

  </div>
</body>
</html>