{"title":"MySQL 5.5 中 DATE, DATETIME 和 TIMESTAMP 的异同","slug":"learning_mysql/difference_date_datetime_timestamp","date":"2017-03-20T03:10:15.000Z","updated":"2018-03-21T02:31:50.215Z","comments":true,"path":"api/articles/learning_mysql/difference_date_datetime_timestamp.json","photos":[],"link":"","excerpt":"都是用来表示日期和时间的，这三者究竟有什么不同呢？<br>这篇文章介绍了 MySQL 中DATE, DATETIME 和 TIMESTAMP 的相似点和不同点。","covers":null,"content":"<p>都是用来表示日期和时间的，这三者究竟有什么不同呢？<br>这篇文章介绍了 MySQL 中<code>DATE</code>, <code>DATETIME</code> 和 <code>TIMESTAMP</code> 的相似点和不同点。</p><a id=\"more\"></a><h2 id=\"三者简介\"><a href=\"#三者简介\" class=\"headerlink\" title=\"三者简介\"></a>三者简介</h2><p><code>DATE</code> 类型被用作表示日期，而不包括时间部分。 MySQL 用’YYYY-MM-DD’格式检索和展示 DATE 值。支持范围从’1000-01-01’到’9999-12-31’</p><p><code>DATETIME</code> 类型用来保存日期和时间。MySQL 以’YYYY-MM-DD HH:MM:SS’ 格式处理DATETIME 类型。范围从’1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’</p><p><code>TIMESTAMP</code> 类型也用来表示时间和日期。 TIMESTAMP 表示范围是：‘1970-01-01 00:00:01’ 到 ‘2038-01-19 03:14:07’ UTC。</p><h2 id=\"TIMESTAMP\"><a href=\"#TIMESTAMP\" class=\"headerlink\" title=\"TIMESTAMP\"></a>TIMESTAMP</h2><h3 id=\"自动进行时区转换\"><a href=\"#自动进行时区转换\" class=\"headerlink\" title=\"自动进行时区转换\"></a>自动进行时区转换</h3><p>MySQL 在存储 TIMESTAMP 格式的值的时候，会把它从当前时区转换成 UTC 时区，然后在处理的时候把它从 UTC 时区转换回当前时区。而其他类型（比如 DATETIME）不会发生这样的转换。默认情况下，每个链接的当前时区是服务器所在的时区。但是每个链接可以自定义自己的时区。只要时区设置是同一个常数，你就可以获取到你存入的准确时间。注意：如果你在存入 TIMESTAMP 值后更改了时区，再取回数据，这些被取回的数据将会和你存入的不同。详情参见 <a href=\"https://dev.mysql.com/doc/refman/5.5/en/time-zone-support.html\" target=\"_blank\" rel=\"noopener\">Section 10.6, “MySQL Server Time Zone Support”</a></p><h3 id=\"自动初始化和更新\"><a href=\"#自动初始化和更新\" class=\"headerlink\" title=\"自动初始化和更新\"></a>自动初始化和更新</h3><p><code>TIMESTAMP</code> 可以自动初始化和更新当前日期和时间。具体来说，在建表时通过 <code>DEFAULT CURRENT_TIMESTAMP</code>、<code>ON UPDATE CURRENT_TIMESTAMP</code> 来控制是否自动初始和自动更新。详情参见 <a href=\"https://dev.mysql.com/doc/refman/5.5/en/timestamp-initialization.html\" target=\"_blank\" rel=\"noopener\">Section 11.3.5, “Automatic Initialization and Updating for TIMESTAMP”</a></p><h3 id=\"精确度：DATETIME-和-TIMESTAMP-一致，小数点后六位\"><a href=\"#精确度：DATETIME-和-TIMESTAMP-一致，小数点后六位\" class=\"headerlink\" title=\"精确度：DATETIME 和 TIMESTAMP 一致，小数点后六位\"></a>精确度：DATETIME 和 TIMESTAMP 一致，小数点后六位</h3><p><code>DATETIME</code> 或者 <code>TIMESTAMP</code> 值可以在尾部包含小数形式的秒，精确到毫秒级（6位）。虽然这些小数部分可以被识别，但是在存储入 DATETIME 或者 TIMESTAMP 的字段中的时候会被丢弃。</p><h2 id=\"无效值处理：三者一致\"><a href=\"#无效值处理：三者一致\" class=\"headerlink\" title=\"无效值处理：三者一致\"></a>无效值处理：三者一致</h2><p>无效的 DATE，DATETIME 或者 TIMESTAMP 值将会被转换成对应类型的 “零” （’0000-00-00’ or ‘0000-00-00 00:00:00’）。</p><h2 id=\"注意这些特殊情况：\"><a href=\"#注意这些特殊情况：\" class=\"headerlink\" title=\"注意这些特殊情况：\"></a>注意这些特殊情况：</h2><ul><li><p>MySQL 支持一些 “便利格式”。利用分隔符，即使类型不匹配，在一些情况下这种便利语法也可以被接受。比如，一个 <code>&#39;10:11:12</code> 可能因为 <code>:</code> 看起来像时间，但是如果被存入一个日期字段，它会被转换成对应的日期 <code>2010-11-12</code> 。而如果把值 <code>&#39;10:45:15&#39;</code> 存入<code>日期</code>字段，它将会被转换成 <code>&#39;0000-00-00&#39;</code> 再存入，因为 ‘45’ 不是一个有效的月份值。</p></li><li><p>服务器验证月份和日期的有效性的时候，不会仅仅验证1-12和1-31。在关闭严格模式（strict mode）的时候，不正确的值（’2004-04-31’）将会被转换成’0000-00-00’存入数据库，并伴随着一个警告。而当打开严格模式的时候，将不会存入，并产生一个错误。而如果你要让服务器接受这样不正确的值，你需要打开 <code>ALLOW_INVALID_DATES</code>。</p></li><li><p>MySQL 不接受包含 0 的或者无效的 TIMESTAMP 值。唯一的例外是 ‘0000-00-00 00:00:00’</p></li><li><p><code>CAST()</code> 会把 TIMESTAMP 转换成字符串。详情参见 <a href=\"https://dev.mysql.com/doc/refman/5.7/en/cast-functions.html\" target=\"_blank\" rel=\"noopener\">Section 12.10, “Cast Functions and Operators”</a></p></li><li><p>当不指定年份的前两位的时候，为了避免二义性，MySQL 将会这样做：</p><ol><li>00-69 将会被转化为 2000-2069</li><li>70-99 将会被转化为 1970-1999</li></ol></li></ul>","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","count":1,"path":"api/tags/MySQL.json"},{"name":"DATE","slug":"DATE","count":1,"path":"api/tags/DATE.json"},{"name":"DATETIME","slug":"DATETIME","count":1,"path":"api/tags/DATETIME.json"},{"name":"TIMESTAMP","slug":"TIMESTAMP","count":1,"path":"api/tags/TIMESTAMP.json"},{"name":"Difference","slug":"Difference","count":2,"path":"api/tags/Difference.json"}]}