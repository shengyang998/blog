{"title":"《代码整洁之道》笔记","slug":"learning_clean_code/clean_code","date":"2018-07-29T15:32:15.663Z","updated":"2019-01-08T10:07:29.909Z","comments":true,"path":"api/articles/learning_clean_code/clean_code.json","photos":[],"link":"","excerpt":"这座楼，除了我的房间以外，已经彻底基皮化了。”<br>“基皮化？”她莫名其妙。<br>“基皮就是没用的东西，垃圾邮件啊，空火柴盒啊，口香糖包装纸啊，昨天的报纸啊。周围没人的时候，基皮就会自我繁殖。比如，如果你睡前在房间里留了些基皮，第二天醒来就会发现基皮增加了一倍。基皮总是会越变越多。”<br>“我明白了。”女孩迟疑地盯着他，不知该不该相信他，一时无法确定他是不是在开玩笑。<br>“这就是基皮第一定律，”他说，“‘基皮驱逐非基皮’。就像格拉舍姆的劣币驱逐良币定律。那些空房间里头，没有活人在抵抗基皮。”—— P.K.Dick, Do Androids Dream of Electric Sheep?就如房间一样，代码也要时常打理才能保持清洁，否则会被“基皮”占领，最终因‘基皮驱逐非基皮’而崩溃。基皮是小说里的概念，如果借助热力学定律里的“熵”的概念，对于代码这种既抽象又精确的事物来说，熵越低自然就越好。<br>那么如何能写出低熵的代码呢？很遗憾，这需要经验，非常考验程序员之功力。而《代码整洁之道》就是这样一本“低熵代码编写指南”，借助它可以快速入门编写低熵的代码。但是这也只是一本快速入门书而已，尽信书不如无书，具体还是要在遵循规则中突破规则。<br>这本书的核心观点就是要【清晰】，而要做到这一点的方法论就是【分层、短小】……","covers":null,"content":"<blockquote><p>这座楼，除了我的房间以外，已经彻底基皮化了。”<br>“基皮化？”她莫名其妙。<br>“基皮就是没用的东西，垃圾邮件啊，空火柴盒啊，口香糖包装纸啊，昨天的报纸啊。周围没人的时候，基皮就会自我繁殖。比如，如果你睡前在房间里留了些基皮，第二天醒来就会发现基皮增加了一倍。基皮总是会越变越多。”<br>“我明白了。”女孩迟疑地盯着他，不知该不该相信他，一时无法确定他是不是在开玩笑。<br>“这就是基皮第一定律，”他说，“‘基皮驱逐非基皮’。就像格拉舍姆的劣币驱逐良币定律。那些空房间里头，没有活人在抵抗基皮。”</p></blockquote><p>—— P.K.Dick, Do Androids Dream of Electric Sheep?</p><p>就如房间一样，代码也要时常打理才能保持清洁，否则会被“基皮”占领，最终因‘基皮驱逐非基皮’而崩溃。基皮是小说里的概念，如果借助热力学定律里的“熵”的概念，对于代码这种既抽象又精确的事物来说，熵越低自然就越好。<br>那么如何能写出低熵的代码呢？很遗憾，这需要经验，非常考验程序员之功力。而《代码整洁之道》就是这样一本“低熵代码编写指南”，借助它可以<strong>快速入门</strong>编写低熵的代码。但是这也只是一本快速入门书而已，尽信书不如无书，具体还是要在遵循规则中突破规则。<br>这本书的核心观点就是要【清晰】，而要做到这一点的方法论就是【分层、短小】……</p><a id=\"more\"></a><h1 id=\"0x00-童子军军规\"><a href=\"#0x00-童子军军规\" class=\"headerlink\" title=\"0x00 童子军军规\"></a>0x00 童子军军规</h1><blockquote><p>让营地比你来时更干净</p></blockquote><blockquote><p>努力，让世界比你来时干净些</p></blockquote><h1 id=\"0x01-命名\"><a href=\"#0x01-命名\" class=\"headerlink\" title=\"0x01 命名\"></a>0x01 命名</h1><h2 id=\"名副其实\"><a href=\"#名副其实\" class=\"headerlink\" title=\"名副其实\"></a>名副其实</h2><p>命名很重要，首先第一点要做到的就是命名要名副其实。<br>做到名副其实并不简单，选个好名字的确要花时间，但是省下来的时间绝对比花掉的多。<br>一旦发现有更好的命名，马上换掉旧的。<br>名字最好是自解释的，如果你需要注释来补充，那这就不算名副其实。</p><h2 id=\"避免误导\"><a href=\"#避免误导\" class=\"headerlink\" title=\"避免误导\"></a>避免误导</h2><ol><li><p>别用缩写。</p><blockquote><p>e.g. 不要用 xxList 来指代一组数据，除非这组数据真的是 List 类型的，否则就会误导。</p></blockquote></li><li><p>别用双关语<br>避免把同一单词用于不同目的</p><blockquote><p>e.g. 假设要写一个新类，该类中有一个方法，把单个参数放到 collection 中。应该把这额方法叫做 insert 或者 append 而不是 add 之类的。</p></blockquote></li><li><p>谨慎使用不同之处较小的名称</p><blockquote><p>e.g. 名字 ZXCVControllerForEfficientStorageOfString 和 ZXCVControllerForEfficientHandlingOfString。区分这两个名字要花多少时间呢？这两个名字的外形太相似了。</p></blockquote></li></ol><h2 id=\"命名要做有意义的区分\"><a href=\"#命名要做有意义的区分\" class=\"headerlink\" title=\"命名要做有意义的区分\"></a>命名要做有意义的区分</h2><p>不要只为了满足编译器或解释器来写代码，会制造麻烦。<br>如果名称必须相异，那么其意思也应该不同才对。<br>不要写废话。</p><blockquote><p>e.g. 假设你有个 Product 类，如果还有一个 ProductInfo 或者 ProductData 类，虽然它们名称不同，但是含义却无甚区别。那么这里的 Info 和 Data 就是废话了。</p></blockquote><p>冗余的都是废话</p><blockquote><p>e.g. Variable 一词永远不应该出现在变量名中。Table 永远不应该出现在表名中。NameString 会比 Name 更好吗？ 既然 Name 不可能是一个浮点数的话，就不要写冗余的 String 了。</p></blockquote><h2 id=\"使用读得出来的名称\"><a href=\"#使用读得出来的名称\" class=\"headerlink\" title=\"使用读得出来的名称\"></a>使用读得出来的名称</h2><p>嗯，可以想象，不然很难跟人沟通代码。</p><h2 id=\"使用易于搜索的名字\"><a href=\"#使用易于搜索的名字\" class=\"headerlink\" title=\"使用易于搜索的名字\"></a>使用易于搜索的名字</h2><p>就是说不要用单字母的名称和数字常量了，代码多了以后没办法搜索。<br>另外，长名称胜过短名称。名称长短应与其作用于大小相对应。</p><h2 id=\"不必用-m-成员前缀来标明成员变量。\"><a href=\"#不必用-m-成员前缀来标明成员变量。\" class=\"headerlink\" title=\"不必用 m_ 成员前缀来标明成员变量。\"></a>不必用 m_ 成员前缀来标明成员变量。</h2><p>因为类和函数应该足够小。而且现代编辑器和 IDE 都应该有代码高亮功能。</p><h2 id=\"避免思维映射\"><a href=\"#避免思维映射\" class=\"headerlink\" title=\"避免思维映射\"></a>避免思维映射</h2><p>不应该让读者在脑中把你的名称翻译为他们熟知的名称。这很难做到，因为每个人都有自己的经验，这就需要程序员打起十二分的精神了。</p><h2 id=\"类名和方法名\"><a href=\"#类名和方法名\" class=\"headerlink\" title=\"类名和方法名\"></a>类名和方法名</h2><p>类名<strong>不</strong>应该是动词<br>方法名应该是动词</p><h2 id=\"别扮可爱-🐶\"><a href=\"#别扮可爱-🐶\" class=\"headerlink\" title=\"别扮可爱 🐶\"></a>别扮可爱 🐶</h2><blockquote><p>e.g. DeleteItems 明显会比什么 HolyHandGrenade 好得多 🐶</p></blockquote><h2 id=\"每个概念对应一个词\"><a href=\"#每个概念对应一个词\" class=\"headerlink\" title=\"每个概念对应一个词\"></a>每个概念对应一个词</h2><blockquote><p>e.g. 如果在同一堆代码中既有 controller 又有 manager 就会使人困惑。</p></blockquote><h2 id=\"尽量不要使用问题领域内的名称\"><a href=\"#尽量不要使用问题领域内的名称\" class=\"headerlink\" title=\"尽量不要使用问题领域内的名称\"></a>尽量不要使用<strong>问题领域内的</strong>名称</h2><p>因为只有程序员才会读你的代码。如果使用领域名称的话，协作者可能需要再次解码，增加了工程难度。<br>实在不能用程序员熟悉的术语来命名，那就使用领域名称吧。这样协作者就只能去请教领域专家了，这是没办法的办法。</p><h2 id=\"添加有意义的语境-——-使用命名空间\"><a href=\"#添加有意义的语境-——-使用命名空间\" class=\"headerlink\" title=\"添加有意义的语境 —— 使用命名空间\"></a>添加有意义的语境 —— 使用命名空间</h2><h1 id=\"0x02-函数\"><a href=\"#0x02-函数\" class=\"headerlink\" title=\"0x02 函数\"></a>0x02 函数</h1><h2 id=\"短小\"><a href=\"#短小\" class=\"headerlink\" title=\"短小\"></a>短小</h2><p>函数的规则第一是短小，第二是更短小。</p><p>一个函数要做到<strong>只做一件事</strong>。</p><p>严格来说，来说这意味着 if、else、while 等语句中的代码块只有一行，最多两行代码。<br>同时这也意味着函数不应该打到足以容大嵌套结构，所以函数的锁进层级也不应该多于一层或两层。</p><blockquote><p>这正好反驳了那些认为 Python 缩进规则反人类的观点，毕竟你本身就不应该缩进太多层。</p></blockquote><p>如果函数只是做了该函数名下同一抽象层次上的步骤，则函数还是只做了一件事。毕竟，编写函数是为了把一个大的概念拆分为另一个抽象层次上的一系列步骤。<br>要判断函数是否不止做了一件事，还有一个办法，就是尝试着再拆分出一个函数。<br>如果函数可以被切分成很多区段，就是这个函数做了太多事的征兆，一个只做一件事的函数不应该能被切分成多个区段。</p><h2 id=\"每个函数一个抽象层级\"><a href=\"#每个函数一个抽象层级\" class=\"headerlink\" title=\"每个函数一个抽象层级\"></a>每个函数一个抽象层级</h2><p>要确保一个函数只做一件事，那么这个函数的所有语句都要在同一层级上。<br>千万注意<strong>不要在一个函数中混杂不同抽象层级！</strong></p><h2 id=\"自顶向下\"><a href=\"#自顶向下\" class=\"headerlink\" title=\"自顶向下\"></a>自顶向下</h2><p>我们想要这样读程序：程序就像是一系列 To 开头的段落，每一段描述当前抽象层级，并且引用下一层级的后续 To 起头的段落。这叫做<strong>向下规则</strong>。<br>而程序员往往很难遵守这条规则，写出只停留于一个抽象层级的函数。</p><h2 id=\"Switch-语句\"><a href=\"#Switch-语句\" class=\"headerlink\" title=\"Switch 语句\"></a>Switch 语句</h2><p>Switch 天生要做多件事，写出短小的 Switch 语句很难。<br>不过我们可以用 <code>多态</code> 来实现。</p><blockquote><p>将 switch 语句埋藏在抽象工厂地下，不让任何人看到。<br>对于 switch 语句，作者的规则是【如果只出现一次，用于创建多态对象，而且隐藏在某个继承关系中，那么还可以容忍。】</p></blockquote><h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><p>最理想的参数数量是0⃣️，其次是1⃣️，再次是2⃣️，尽量避免3⃣️个参数。<br>如果函数使用三个或三个以上的参数时，就意味着其中一些参数该被封装成类了。<br>请千万谨慎使用 boolean 参数。</p><h2 id=\"无副作用\"><a href=\"#无副作用\" class=\"headerlink\" title=\"无副作用\"></a>无副作用</h2><p>【副作用是一种谎言】函数承诺只做一件事，但是它还是做了其他事。<br>编写无副作用的函数易于调试、易于重构使用多线程的能力。千万别小看副作用的威力，副作用可能引入各种时序问题，很多 Bug 就是由它引起的。<br>无副作用也是函数式编程所需要的最基本的理念。</p><h2 id=\"分隔指令类函数和询问类函数\"><a href=\"#分隔指令类函数和询问类函数\" class=\"headerlink\" title=\"分隔指令类函数和询问类函数\"></a>分隔指令类函数和询问类函数</h2><p>函数要么<strong>做</strong>什么事，要么<strong>回答</strong>什么问题，二者不可得兼。</p><h2 id=\"使用异常而不是返回错误码\"><a href=\"#使用异常而不是返回错误码\" class=\"headerlink\" title=\"使用异常而不是返回错误码\"></a>使用异常而不是返回错误码</h2><p>使用异常替代返回错误码，错误处理流程就能从主流程中分离出来，这很重要。</p><h2 id=\"抽离-Try-Catch\"><a href=\"#抽离-Try-Catch\" class=\"headerlink\" title=\"抽离 Try/Catch\"></a>抽离 Try/Catch</h2><p>Try/Catch 代码块丑陋不堪。把错误处理与正常流程混为一谈。最好把 try 和 catch 从中体部分抽离出来。</p><h2 id=\"D-R-Y\"><a href=\"#D-R-Y\" class=\"headerlink\" title=\"D.R.Y.\"></a>D.R.Y.</h2><p>老生常谈了。【不要重复自己】，一旦你发现有重复的代码，就要停下来，分析一下是否可以再进行抽象。<br>永远不要在自己的代码库里使用 <code>Ctrl - C &amp; Ctrl - V</code> 这样做得不偿失。</p><h2 id=\"Dijkstra-的结构化编程规则\"><a href=\"#Dijkstra-的结构化编程规则\" class=\"headerlink\" title=\"Dijkstra 的结构化编程规则\"></a>Dijkstra 的结构化编程规则</h2><p>【每个函数、函数中的每个代码块都应该只有一个入口、一个出口。】遵循这个规则意味着，在每个函数中只应该有一个 return 语句，循环中不能有 break 或 continue 语句，而且永远不能有 goto 语句。<br>作者赞成结构化编程的目标和规范，但是对于小函数，这些规范没有什么帮助，只有在大函数中，这些规范才有明显的好处。所以又回到了开头，只要保持函数短小就没有问题。偶尔出现的 return、break 或者 continue 语句没有坏处，甚至更具有表达力。</p><h1 id=\"如何写出这样的函数\"><a href=\"#如何写出这样的函数\" class=\"headerlink\" title=\"如何写出这样的函数\"></a>如何写出这样的函数</h1><p>写代码和写文章很像。初稿也许粗陋无序，斟酌推敲，直至达到你心目中的样子。<br>作者写函数时，一开始都很冗长而复杂，名称甚至也是随意取的，也有重复的代码，不过会配上一套单元测试，覆盖每行丑陋的代码。然后开始打磨这些代码，分解函数、修改名称、消除重复、缩短并重新放置方法。最后遵循上述的规则，组装好这些函数。<br>作者也认为【不要一开始就按照规则写函数，没人做得到】</p><h2 id=\"书中的小结\"><a href=\"#书中的小结\" class=\"headerlink\" title=\"书中的小结\"></a>书中的小结</h2><ol><li>代码是演化出来的，没有人能一蹴而就写出完美的代码，所有人都是一边写代码一边重构，在重构的过程中是自己的思路更加清晰，而遵循这些要点可以避免初学者在重构时跑偏。</li><li>大师级的程序员把系统当做故事来讲，而不是当做程序来写。为了讲好那个故事，他们使用特定的编程语言构建一种更为丰富且更具表达力的语言。</li><li>真正的目标在于讲述系统的故事，而你编写的函数必须干净利落的拼装到一起，形成一种精确而清晰的语言，帮助你讲故事。</li></ol><h2 id=\"个人的小结\"><a href=\"#个人的小结\" class=\"headerlink\" title=\"个人的小结\"></a>个人的小结</h2><p>总体来看，上面部分内容的逻辑是：<br>为了遵守沃德原则，需要整洁的代码；为了有整洁的代码，需要取好的名字；为了更容易取好的名字，函数的功能就要越简单；为了让函数的功能更简单，函数就要越短。<br>上述逻辑就是前面提到的 <code>自顶向下</code> 原则，写代码的时候也要用这样的逻辑。</p><h3 id=\"Appendix\"><a href=\"#Appendix\" class=\"headerlink\" title=\"Appendix\"></a>Appendix</h3><ul><li>所谓沃德原则就是：【如果每个例程都让你感到深合己意，那就是整洁代码。】</li></ul><blockquote><p>本书后面还有关于注释、格式、对象和数据结构、错误处理、边界、单元测试、类、系统、迭代、并发编程、逐步改进、JUnit内幕、重构 SerialDate、代码的味道与启发相关的内容。<br>特别是“代码的味道”章节，个人认为这对于形成代码直觉很重要，不过大部分内容我这篇博文也算是覆盖了。感兴趣的童鞋们可以去看看。</p></blockquote>","categories":[],"tags":[{"name":"Programming","slug":"Programming","count":13,"path":"api/tags/Programming.json"},{"name":"Clean Code","slug":"Clean-Code","count":1,"path":"api/tags/Clean-Code.json"}]}